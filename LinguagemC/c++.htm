<html><head><!-- This document was created from RTF source by rtftohtml version
2.7.4 --><title>TUTORIAL:</title></head><body><p>
<p>
<p>
<BODY bgcolor="#FFFFFF"
<BODY>
<p>
<p>
<b><h1>TUTORIAL:</h1></b><p>
<b><h2>"C++ COMO UMA LINGUAGEM  DE PROGRAMA&Ccedil;&Atilde;O ORIENTADA A
OBJETOS."</h2></b><p>
<TT>
Copyright &#169 1996<p>
</TT>

<p>
<b></b><p>
<b>PROGRAMA&Ccedil;&Atilde;O ORIENTADA A OBJETOS
<a name="_Ref342060405"><a name="_Ref342061544"></b><p>
<b></b><p>
	Este tutorial se prop&otilde;e a ensinar programa&ccedil;&atilde;o orientada a
objetos em C++. A maioria dos livros  n&atilde;o apresenta a linguagem nesse
contexto, dando uma aten&ccedil;&atilde;o maior para os recursos de C++ do que
para a metodologia de programa&ccedil;&atilde;o. &Eacute; recomend&aacute;vel
que o leitor tenha acesso a um desses livros visto que n&atilde;o ensinaremos
aqui aspectos considerados b&aacute;sicos que s&atilde;o em geral quase todos
que permitem usar C++ como um C melhorado. Voc&ecirc; pode usar C++, como uma
linguagem procedural com recursos avan&ccedil;ados, mais uma vez n&atilde;o
&eacute; isso que pretendemos ensinar neste texto. <p>
	Na pr&aacute;tica de programa&ccedil;&atilde;o orientada a objetos estaremos
atentos em nossos programas para pontos como:<p>
<p>
-Compatibilidade, portabilidade.<p>
-Seguran&ccedil;a.<p>
-Reusabilidade.<p>
-Facilidade de integra&ccedil;&atilde;o.<p>
-Facilidade de extens&atilde;o.<p>
-Efici&ecirc;ncia.<p>
<p>
	Os t&oacute;picos seguintes nos guiar&atilde;o nesses objetivos, mostrando
numa curva de aprendizado suave,  como programar usando
orienta&ccedil;&atilde;o a objetos em C++.<p>
<a name="_Toc342736940"><a name="_Ref345401243"><a name="_Toc345409386"><a name="_Toc345810891"><a name="_Toc345838211"><a name="_Toc345942346"><a name="_Toc345949506"><a name="_Toc346168623"><a name="_Toc348417062"><a name="_Toc348931314"><a name="_Toc353900761"><a name="_Toc353946290">
<h1>
<a name="RTFToC1">1.
CLASSES E OBJETOS</a></a></a></a></a></a></a></a></a></a></a></a></a></a>
</a></h1>
<p>
	Uma classe &eacute; um tipo definido pelo usu&aacute;rio que cont&eacute;m o
molde, a especifica&ccedil;&atilde;o para os objetos, assim como o tipo inteiro
cont&eacute;m o molde para as vari&aacute;veis declaradas como inteiros. A
classe envolve, associa, fun&ccedil;&otilde;es e dados, controlando o acesso a
estes, defin&iacute;-la implica em especificar os seus atributos (dados) e suas
fun&ccedil;&otilde;es membro (c&oacute;digo).<p>
	Um programa que utiliza uma interface controladora de um motor el&eacute;trico
provavelmente definiria a classe motor. Os atributos desta classe  seriam:
temperatura, velocidade, tens&atilde;o aplicada. Estes provavelmente seriam
representados na classe por tipos como <CODE>float</CODE> ou
<CODE>long </CODE>. As fun&ccedil;&otilde;es membro desta classe
seriam fun&ccedil;&otilde;es para alterar a velocidade, ler a temperatura,
etc.<p>
	Um programa editor de textos definiria a classe par&aacute;grafo que teria
como um de seus atributos uma string ou um vetor de strings, e como
fun&ccedil;&otilde;es membro, fun&ccedil;&otilde;es que operam sobre estas
strings. Quando um novo par&aacute;grafo &eacute; digitado no texto, o editor
cria a partir da classe par&aacute;grafo um objeto contendo as
informa&ccedil;&otilde;es particulares do novo texto. Isto se chama
instancia&ccedil;&atilde;o ou cria&ccedil;&atilde;o do objeto.<p>
	Classes podem ser declaradas usando a palavra reservada  <CODE>struct
</CODE>ou a palavra reservada class, nos exemplos posteriores entraremos
em mais detalhes. As classes do pr&oacute;ximo t&oacute;pico 1.2 s&atilde;o
declaradas com  <CODE>struct </CODE> por raz&otilde;es
did&aacute;ticas. Quando chegarmos em encapsulamento 1.3 mostraremos como
declarar classes com class e n&atilde;o usaremos mais  <CODE>struct
</CODE>no tutorial.<p>
<a name="_Ref342091107"><a name="_Toc342736941"><a name="_Toc345409387"><a name="_Toc345810892"><a name="_Toc345838212"><a name="_Toc345942347"><a name="_Toc345949507"><a name="_Toc346168624"><a name="_Toc348417067"><a name="_Toc348931323"><a name="_Toc353900762"><a name="_Toc353946292">
<h2>
<a name="RTFToC2">1.1.
ESPECIFICANDO UMA CLASSE</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h2>
<p>
	Suponha um programa que controla um motor el&eacute;trico atrav&eacute;s de
uma sa&iacute;da serial. A velocidade do motor &eacute; proporcional a
tens&atilde;o aplicada, e esta proporcional aos bits que v&atilde;o para
sa&iacute;da serial e passando por um conversor digital anal&oacute;gico.<p>
	Vamos abstrair todos estes detalhes por enquanto e modelar somente a interface
do motor como uma classe, a pergunta &eacute; que fun&ccedil;&otilde;es e que
dados membro deve ter nossa classe, e que argumentos e valores de retorno devem
ter essas fun&ccedil;&otilde;es membro:<p>
<p>
Representa&ccedil;&atilde;o da velocidade: <p>
	A velocidade do motor ser&aacute; representada por um atributo, ou dado
membro, inteiro (int). Usaremos a faixa de bits que precisarmos, caso o valor
de bits necess&aacute;rio n&atilde;o possa ser fornecido pelo tipo , usaremos
ent&atilde;o o tipo <CODE> long </CODE>, isto depende do conversor
digital anal&oacute;gico utilizado e do compilador.<p>
<p>
Representa&ccedil;&atilde;o da sa&iacute;da serial:<p>
	O motor precisa conhecer a sua sa&iacute;da serial, a sua
liga&ccedil;&atilde;o com o "motor do mundo real". Suponha uma
representa&ccedil;&atilde;o em hexadecimal do atributo endere&ccedil;o de porta
serial, um poss&iacute;vel nome para o atributo: enderecomotor. N&atilde;o se
preocupe em saber como usar a representa&ccedil;&atilde;o hexadecimal.<p>
<p>
Altera&ccedil;&atilde;o do valor da velocidade:<p>
	Internamente o usu&aacute;rio da classe motor pode desejar alterar a
velocidade, cria-se ent&atilde;o o m&eacute;todo ( em C++ fun&ccedil;&atilde;o
membro): <CODE> void altera_velocidade(int novav); </CODE>. O
c&oacute;digo anterior corresponde ao cabe&ccedil;alho da fun&ccedil;&atilde;o
membro, ela &eacute; definida junto com a classe motor, associada a ela. O
valor de retorno da fun&ccedil;&atilde;o &eacute; <CODE> void
</CODE> (valor vazio), poderia ser criado um valor de retorno
<CODE> (int) </CODE> que indicasse se o valor de velocidade era
permitido e foi alterado ou n&atilde;o era permitido e portanto n&atilde;o foi
alterado. <p>
	N&atilde;o faz sentido usar, chamar, esta fun&ccedil;&atilde;o membro separada
de uma vari&aacute;vel do tipo motor, mas ent&atilde;o porque  na lista de
argumentos n&atilde;o se encontra um motor? Este pensamento reflete a maneira
de associar dados e c&oacute;digo (fun&ccedil;&otilde;es) das linguagens
procedurais. Em linguagens orientadas a objetos o c&oacute;digo e os dados
s&atilde;o ligados de forma diferente, a pr&oacute;pria
declara&ccedil;&atilde;o de um tipo definido pelo usu&aacute;rio j&aacute;
engloba as declara&ccedil;&otilde;es das fun&ccedil;&otilde;es inerentes a este
tipo, isto ser&aacute; explicado em 1.2.2. <p>
	Note que n&atilde;o fornecemos o c&oacute;digo da fun&ccedil;&atilde;o, isto
n&atilde;o &eacute; importante, por hora a preocupa&ccedil;&atilde;o &eacute;
com a interface definida pela classe: suas fun&ccedil;&otilde;es membro e dados
membro. Apenas pense que sua interface deve ser flex&iacute;vel de modo a
n&atilde;o apresentar entraves para a cria&ccedil;&atilde;o do c&oacute;digo
que seria feita numa outra etapa. Nesta etapa ter&iacute;amos que imaginar que
o valor num&eacute;rico da velocidade deve ir para o conversor onde ir&aacute;
se transformar numa diferen&ccedil;a de potencial a ser aplicada nos terminais
do motor, etc.<p>
<p>
Um diagrama simplificado da classe motor com os dados membro e as
fun&ccedil;&otilde;es membro:<p>
<CENTER><IMG SRC="motor.gif" ></CENTER>
<p>
	<p>
<b>Exerc&iacute;cios:</b><p>
1)Lembre-se de algum programa em que voc&ecirc; trabalhou, cite que tipos de
classes seriam criadas se esse programa fosse escrito em C++, que atributos e
que fun&ccedil;&otilde;es membro estariam associadas a esses objetos? <p>
 Exemplo: "Eu trabalhei em um programa de contas a pagar e contas a receber. Se
esse programa fosse escrito em C++ eu definiria a classe conta_bancaria. Os
atributos seriam: <CODE>saldo, taxa_de_juros, limite_de_saque,
</CODE>etc. Minha op&ccedil;&atilde;o seria por represent&aacute;-los
como vari&aacute;veis do tipo <CODE> float. </CODE>"<p>
"Dentre as fun&ccedil;&otilde;es membros desta classe estariam
fun&ccedil;&otilde;es para efetuar saques, dep&oacute;sitos e computar
juros."<p>
<a name="_Ref342060407"><a name="_Ref342093518"><a name="_Toc342736942"><a name="_Toc345409388"><a name="_Toc345810893"><a name="_Toc345838213"><a name="_Toc345942348"><a name="_Toc345949508"><a name="_Toc346168625"><a name="_Toc348417068"><a name="_Toc348931324"><a name="_Toc353900763"><a name="_Toc353946293">
<h2>
<a name="RTFToC3">1.2.
STRUCT EM C++</a></a></a></a></a></a></a></a></a></a></a></a></a>
</a></h2>
<p>
	Objetos s&atilde;o inst&acirc;ncias de uma classe. Quando um objeto &eacute;
criado ele precisa ser inicializado, ou seja para uma &uacute;nica classe :
Estudante de gradua&ccedil;&atilde;o podemos ter v&aacute;rios objetos num
programa: Estudante de gradua&ccedil;&atilde;o Carlos,
Identifica&ccedil;&atilde;o 941218, Curso  Computa&ccedil;&atilde;o; Estudante
de gradua&ccedil;&atilde;o Luiza , Identifica&ccedil;&atilde;o 943249, Curso
Engenharia Civil... A classe representa somente o molde para a
cria&ccedil;&atilde;o dos objetos, estes sim cont&eacute;m
informa&ccedil;&atilde;o, veja t&oacute;pico classes e objetos.<p>
<CENTER><IMG SRC="graduaca.gif" ></CENTER>
<p>
<p>
<a name="_Ref342094660"><a name="_Toc342736943"><a name="_Toc345409389"><a name="_Toc345810894"><a name="_Toc345838214"><a name="_Toc345942349"><a name="_Toc345949509"><a name="_Toc346168626"><a name="_Toc348417069"><a name="_Toc348931325"><a name="_Toc353900764"><a name="_Toc353946294">
<h3>
<a name="RTFToC4">1.2.1.
ATRIBUTOS OU  DADOS MEMBRO.</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
	Este exemplo declara uma  <CODE>struct </CODE> e em seguida cria
um objeto deste tipo em main  alterando o conte&uacute;do  desta
vari&aacute;vel. Uma <CODE> struct </CODE> &eacute; parecida com um
record de Pascal, a nossa  representa um c&iacute;rculo com os atributos raio,
posi&ccedil;&atilde;o x , posi&ccedil;&atilde;o y, que s&atilde;o coordenadas
cartesianas. Note que este objeto n&atilde;o possui fun&ccedil;&otilde;es
membro ainda.<p>
<CODE><p>

<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
struct circulo  <p>
//struct que representa um circulo.<p>
{<p>
float raio;<p>
float x;          <p>
//posicoes em coordenadas cartesianas<p>
float y;<p>
};<p>
<p>
void main()<p>
{<p>
circulo ac;  <p>
//criacao de variavel , veja comentarios.<p>
ac.raio=10.0;  <p>
//modificacao de conteudo (atributos) da struct<p>
ac.x=1.0;  <p>
//colocando o circulo em uma posicao determinada<p>
ac.y=1.0;  <p>
//colocando o circulo em uma posicao determinada<p>
cout &lt;&lt; "Raio:"&lt;&lt;ac.raio &lt;&lt;endl;  <p>
//verificacao dos atributos alterados.<p>
cout &lt;&lt; "X:"&lt;&lt;ac.x &lt;&lt; "\n"; // "\n"==endl<p>
cout &lt;&lt; "Y:" &lt;&lt;ac.y&lt;&lt; endl;<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Resultado do  programa:</b><p>
<b></b>Raio:10<p>
X:1<p>
Y:1<p>
<p>
<b>Coment&aacute;rios:</b> <CODE><b></b><p>
<b></b>struct circulo  <p>
//struct que representa um circulo.<p>
{<p>
float raio;<p>
float x;          <p>
//posicoes em coordenadas cartesianas<p>
float y;<p>
};</CODE><p>
	Este c&oacute;digo &eacute; a declara&ccedil;&atilde;o da classe
c&iacute;rculo, entre chaves vem os dados membro e as fun&ccedil;&otilde;es
membro que n&atilde;o foram apresentadas ainda.<p>
	A sintaxe para cria&ccedil;&atilde;o de objetos da classe
c&iacute;rculo<CODE> (circulo ac;) </CODE> , por enquanto
n&atilde;o difere da sintaxe para a cria&ccedil;&atilde;o de vari&aacute;veis
do tipo int.<p>
	O acesso aos dados membro deve ser feito usando o nome do objeto e o nome do
dado membro, separados por um ponto: <CODE> ac.raio=10.0; </CODE> .
Note que raio sozinho n&atilde;o faz sentido no programa, precisa-se
especificar de que objeto se deseja acessar o raio.<p>
<p>
<b>Aos que programam em C:</b> <p>
	Os programadores C podem notar algo interessante: "C++ n&atilde;o requer a
palavra struct na declara&ccedil;&atilde;o da vari&aacute;vel, ela se comporta
como um tipo qualquer: <CODE>int , float</CODE> ...". Outros
programadores que n&atilde;o haviam usado struct previamente em C n&atilde;o se
preocupem, fa&ccedil;am apenas os exerc&iacute;cios deste exemplo e
estar&atilde;o aptos a prosseguir.<p>
<p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1) Repita o mesmo exemplo s&oacute; que agora mova o c&iacute;rculo
alterando as componentes x e y. Ponha o c&iacute;rculo em (0.0,0.0)
atrav&eacute;s de atribui&ccedil;&otilde;es do tipo<CODE> ac.x=1.0;
</CODE>mova o c&iacute;rculo para (1.0,1.0). Acompanhe todas as
modifica&ccedil;&otilde;es da<CODE> struct</CODE> atrav&eacute;s de
cout's.<p>
<p>
2)Simplifique o programa anterior retirando o atributo raio. Voc&ecirc; pode
dar o nome de ponto ou ponto_geometico para esta classe.<p>
<a name="_Ref342110639"><a name="_Toc342736944"><a name="_Toc345409390"><a name="_Toc345810895"><a name="_Toc345838215"><a name="_Toc345942350"><a name="_Toc345949510"><a name="_Toc346168627"><a name="_Toc348417070"><a name="_Toc348931326"><a name="_Toc353900765"><a name="_Toc353946295">
<h3>
<a name="RTFToC5">1.2.2.
M&Eacute;TODOS OU FUN&Ccedil;&Otilde;ES
MEMBRO.</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
	C++ permite que se acrescente fun&ccedil;&otilde;es de
manipula&ccedil;&atilde;o da struct em sua declara&ccedil;&atilde;o, juntando
tudo numa s&oacute; entidade que &eacute; uma classe. Essas
fun&ccedil;&otilde;es membro podem ter sua declara&ccedil;&atilde;o
(cabe&ccedil;alho) e implementa&ccedil;&atilde;o (c&oacute;digo) dentro da
struct ou s&oacute; o cabe&ccedil;alho (assinatura) na<CODE> struct
</CODE>e a implementa&ccedil;&atilde;o, c&oacute;digo, fora. Este exemplo
apresenta a primeira vers&atilde;o, o pr&oacute;ximo a segunda vers&atilde;o
(implementa&ccedil;&atilde;o fora da classe).<p>
	Essas fun&ccedil;&otilde;es comp&otilde;em a interface da classe. A
terminologia usada para design&aacute;-las &eacute; bastante variada:
fun&ccedil;&otilde;es membro, m&eacute;todos, etc. Quando uma
fun&ccedil;&atilde;o membro &eacute; chamada, se diz que o objeto est&aacute;
recebendo uma mensagem  (para executar uma a&ccedil;&atilde;o).<p>
<p>
Um programa simples para testes sobre fun&ccedil;&otilde;es membro seria o
seguinte: <CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
struct contador <p>
//conta ocorrencias de algo<p>
{<p>
int num; <p>
//numero do contador<p>
void incrementa(void){num=num+1;}; <p>
//incrementa contador<p>
void comeca(void){num=0;}; <p>
//comeca a contar<p>
};<p>
<p>
void main()  <p>
//teste do contador<p>
{<p>
contador umcontador;<p>
umcontador.comeca(); <p>
//nao esqueca dos parenteses, e uma funcao membro e nao atributo!<p>
cout &lt;&lt; umcontador.num &lt;&lt; endl;<p>
umcontador.incrementa();<p>
cout &lt;&lt; umcontador.num &lt;&lt; endl;<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Resultado do programa:</b><p>
<b></b>0<p>
1<b></b><p>
<b></b><p>
<b>Coment&aacute;rios:</b> <p>
	O programa define um objeto que serve como contador, a
implementa&ccedil;&atilde;o representa a contagem no atributo num que &eacute;
um n&uacute;mero inteiro. As fun&ccedil;&otilde;es membro s&atilde;o simples:
<CODE> incrementa </CODE>adiciona um ao contador em qualquer estado
e comeca inicializa a contagem em zero.<p>
<p>
<b>Sintaxe:</b><p>
<b>	</b>A sintaxe para declara&ccedil;&atilde;o de fun&ccedil;&otilde;es membro
dentro de uma classe &eacute; a mesma sintaxe de declara&ccedil;&atilde;o de
fun&ccedil;&otilde;es comuns  : <CODE>tipoderetorno
nomedafuncao(lista_de_argumentos) { /*codigo */ }</CODE>. A
diferen&ccedil;a &eacute; que como a fun&ccedil;&atilde;o membro est&aacute;
definida na classe, ela ganho acesso direto aos dados membros, sem precisar
usar o "ponto", exemplo <CODE>um_objeto.dadomembro; </CODE>.
Lembre-se que as chamadas de fun&ccedil;&otilde;es membro j&aacute; se referem
a um objeto espec&iacute;fico, embora elas sejam definidas de uma forma geral
para toda a classe.<p>
	A sintaxe de chamada ou acesso &agrave; fun&ccedil;&otilde;es membro &eacute;
semelhante a sintaxe de acesso aos dados membro com exce&ccedil;&atilde;o dos
par&ecirc;nteses que cont&eacute;m a lista de argumentos da
fun&ccedil;&atilde;o, mesmo que a lista seja vazia eles devem estar presentes:
<CODE> umcontador.incrementa();.</CODE> Primeiro insere-se o nome
do objeto e depois a chamada da fun&ccedil;&atilde;o, estes s&atilde;o
separados por um ponto. Cuidado para n&atilde;o esquecer os par&ecirc;nteses
nas chamadas de fun&ccedil;&otilde;es membro em programas futuros, este
&eacute; um erro bastante comum.<p>
<p>
Agora o programa mais complicado, por&eacute;m baseado no exemplo 1.2.1:
<CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt; //para cout<p>
<p>
struct circulo<p>
{<p>
float raio;<p>
float x; <p>
//atributo coordenada cartesiana x<p>
float y; <p>
//atributo coordenada cartesiana y<p>
<p>
void move(float dx,float dy)  <p>
//fun&ccedil;&atilde;o membro ou fun&ccedil;&atilde;o membro move<p>
{<p>
x+=dx;   <p>
//equivale a x=x+dx;<p>
y+=dy;<p>
}<p>
<p>
<p>
void mostra(void) //fun&ccedil;&atilde;o membro ou fun&ccedil;&atilde;o membro
mostra<p>
{<p>
cout &lt;&lt; "Raio:"&lt;&lt;raio &lt;&lt;endl;<p>
cout &lt;&lt; "X:"&lt;&lt;x &lt;&lt; endl;<p>
cout &lt;&lt; "Y:" &lt;&lt;y&lt;&lt; endl;<p>
}<p>
};<p>
<p>
<p>
void main()<p>
{<p>
circulo ac;  <p>
// * instancia&ccedil;&atilde;o  de um objeto circulo (criacao)<p>
ac.x=0.0;<p>
ac.y=0.0;<p>
ac.raio=10.0;<p>
<p>
ac.mostra();<p>
ac.move(1.0,1.0);<p>
ac.mostra();<p>
ac.x=100.0;<p>
ac.mostra();<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Resultado do programa:</b><p>
<b></b>Raio:10<p>
X:0<p>
Y:0<p>
Raio:10<p>
X:1<p>
Y:1<p>
Raio:10<p>
X:100<p>
Y:1<p>
<p>
<b>Coment&aacute;rios:</b> <p>
	A fun&ccedil;&atilde;o membro move altera as coordenadas do objeto. O objeto
tem suas coordenadas x e y somadas com os argumentos dessa fun&ccedil;&atilde;o
membro. Note que esta fun&ccedil;&atilde;o membro representa uma maneira mais
segura, clara, elegante de alterar as coordenadas do objeto do que
acess&aacute;-las diretamente da seguinte forma: <CODE>ac.x+=dx;.
ac.y+=dy;. </CODE> Lembre-se que <CODE>ac.x+=dx
</CODE>&eacute; uma abrevia&ccedil;&atilde;o para
<CODE>ac.x=ac.x+dx; </CODE>.<p>
<p>
<b>Como funcionam no compilador as chamadas de fun&ccedil;&otilde;es
membro:</b><p>
	&Eacute; poss&iacute;vel imaginar que as defini&ccedil;&otilde;es de
fun&ccedil;&otilde;es membro ocupam um grande espa&ccedil;o na
representa&ccedil;&atilde;o interna dos objetos, mas lembre-se que elas
s&atilde;o todas iguais para uma classe ent&atilde;o basta manter para cada
classe uma tabela de fun&ccedil;&otilde;es membro que &eacute; consultada no
momento da chamada . Os objetos s&oacute; precisam ter uma refer&ecirc;ncia
para esta tabela.<p>
<p>
<b>Exerc&iacute;cios:  </b><p>
<b></b>1)Neste mesmo programa, crie uma fun&ccedil;&atilde;o para a<CODE>
struct</CODE> chamada "inicializa" que deve ter como argumentos um valor
para x, um para y e outro para o raio, e deve alterar os atributos
inicializando-os com os valores passados. <p>
	Voc&ecirc; pode abstrair o uso dessa fun&ccedil;&atilde;o como uma maneira de
inicializar o objeto de uma s&oacute; vez embora a fun&ccedil;&atilde;o o
fa&ccedil;a seq&uuml;encialmente. Comente as vantagens de faz&ecirc;-lo,
comparando com as outras op&ccedil;&otilde;es, tenha sempre em mente a
quest&atilde;o de seguran&ccedil;a quando avaliar t&eacute;cnicas diferentes de
programa&ccedil;&atilde;o.<p>
<p>
2)No programa anterior, verifique que nada impede que voc&ecirc; acesse
diretamente os valores de x , y e raio e os modifique. Como voc&ecirc; pode
criar um n&uacute;mero enorme de fun&ccedil;&otilde;es : <CODE>
altera_x(float a); move_raio(float dr); </CODE>seria desej&aacute;vel que
somente essas fun&ccedil;&otilde;es pudessem modificar x, y e raio. Voc&ecirc;
ver&aacute; que isso &eacute; poss&iacute;vel em encapsulamento 1.3. Por hora,
crie essas fun&ccedil;&otilde;es.<p>
<p>
3)Teste a fun&ccedil;&atilde;o membro move com argumentos negativos,
exemplo<CODE> ac.move(-1.0,-1.5);. </CODE>O resultado &eacute;
coerente?<p>
<p>
4)Crie uma nova<CODE> struct </CODE>que representa um ponto, que
informa&ccedil;&otilde;es voc&ecirc; precisa armazenar? Que
fun&ccedil;&otilde;es seriam &uacute;teis ? Fa&ccedil;a um programa para testar
sua classe.<p>
<p>
5)Melhore a classe contador, defina uma fun&ccedil;&atilde;o que imprime o
contador na tela. Se voc&ecirc; estivesse fazendo um programa para rodar numa
interface gr&aacute;fica com o usu&aacute;rio esta fun&ccedil;&atilde;o de
imprimir na tela seria a mesma? Definir uma fun&ccedil;&atilde;o que retorna
uma copia do valor atual do contador garante maior portabilidade? Por
qu&ecirc;? Para aprender a retornar valores consulte: 1.2.3.<p>
<p>
6)"H&aacute; uma tend&ecirc;ncia em definir o maior n&uacute;mero de
fun&ccedil;&otilde;es membro em uma classe, porque nunca se pode prever
exatamente o seu uso em programas futuros". Comente esta frase, tendo em vista
o conceito de portabilidade. Voc&ecirc; j&aacute; &eacute; capaz de citar
outras medidas que tornem suas classes mais port&aacute;veis? Leia o
exerc&iacute;cio anterior.<p>
<a name="_Ref342098714"><a name="_Toc342736945"><a name="_Toc345409391"><a name="_Ref345411721"><a name="_Ref345413728"><a name="_Toc345810896"><a name="_Toc345838216"><a name="_Toc345942351"><a name="_Toc345949511"><a name="_Toc346168628"><a name="_Toc348417071"><a name="_Toc348931327"><a name="_Toc353900766"><a name="_Toc353946296">
<h3>
<a name="RTFToC6">1.2.3.
FUN&Ccedil;&Otilde;ES MEMBRO QUE RETORNAM
VALORES.</a></a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
	At&eacute; agora s&oacute; t&iacute;nhamos visto fun&ccedil;&otilde;es membro
com valor de retorno igual a <CODE>void. </CODE> Uma
fun&ccedil;&atilde;o membro, assim como uma fun&ccedil;&atilde;o comum, pode
retornar qualquer tipo, inclusive os definidos pelo usu&aacute;rio. Sendo
assim, sua chamada  no programa se aplica a qualquer lugar onde se espera um
tipo igual ou equivalente ao tipo do seu valor de retorno, seja numa lista de
argumentos de outra fun&ccedil;&atilde;o , numa atribui&ccedil;&atilde;o ou num
operador como o<CODE> cout &lt;&lt; variavel; </CODE><p>
<CODE><p>
<b><hr></b><i></i><p>
<i></i>#include &lt;iostream.h&gt;<p>
<p>
struct contador<p>
//conta ocorrencias de algo<p>
{<p>
int num;<p>
//numero, posicao do contador<p>
void incrementa(void){num=num+1;};<p>
//incrementa contador<p>
void comeca(void){num=0;};<p>
//comeca a contar, "reset"<p>
int retorna_num(void) {return num;};<p>
};<p>
<p>
void main()<p>
//teste do contador<p>
{<p>
contador umcontador;<p>
umcontador.comeca();<p>
//nao esqueca dos parenteses, e uma funcao membro nao dado!<p>
cout &lt;&lt; umcontador.retorna_num() &lt;&lt; endl;<p>
umcontador.incrementa();<p>
cout &lt;&lt; umcontador.retorna_num() &lt;&lt; endl;<p>
}<p>
</CODE><p>
<b><hr></b><i></i><p>
<i></i><b>Resultado do programa:</b><p>
<b></b>0<p>
1<p>
<b>
<a name="_Ref342127682"><a name="_Toc342736946"><a name="_Toc345409392"><a name="_Toc345810897"><a name="_Toc345838217"><a name="_Toc345942352"><a name="_Toc345949512"><a name="_Toc346168629"><a name="_Toc348417072"><a name="_Toc348931328"><a name="_Toc353900767"><a name="_Toc353946297"></b>
<h3>
<a name="RTFToC7">1.2.4.
FUN&Ccedil;&Otilde;ES DECLARADAS EXTERNAS A CLASSE , FUN&Ccedil;&Otilde;ES
MEMBRO CHAMAMANDO FUN&Ccedil;&Otilde;ES
MEMBRO.</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>Este exemplo apresenta a implementa&ccedil;&atilde;o,
defini&ccedil;&atilde;o, das fun&ccedil;&otilde;es fora da
declara&ccedil;&atilde;o da struct. Al&eacute;m disso introduz uma nova
fun&ccedil;&atilde;o chamada "inicializa" e fun&ccedil;&otilde;es float
<CODE>retorna_raio(void);  e void altera_raio(float a). </CODE>
Inicializa coloca o ponto nas coordenadas passadas como seus argumentos.
Introduzimos esta fun&ccedil;&atilde;o membro aqui para preparar a
explica&ccedil;&atilde;o sobre construtores dada no pr&oacute;ximo exemplo:
1.2.6.<p>
<p>
<b>Coment&aacute;rios:</b> <p>
	Em uma declara&ccedil;&atilde;o de uma classe normalmente se coloca a
declara&ccedil;&atilde;o das fun&ccedil;&otilde;es membro depois da
declara&ccedil;&atilde;o dos atributos, por&eacute;m podemos fazer
intercala&ccedil;&otilde;es ou adotar qualquer ordem que nos convenha.<p>
	O programador n&atilde;o &eacute; obrigado a implementar as
fun&ccedil;&otilde;es membro dentro da declara&ccedil;&atilde;o da classe,
basta defini-las e apresentar a implementa&ccedil;&atilde;o em separado segundo
a sintaxe (compil&aacute;vel) descrita a seguir: <CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
struct teste<p>
{<p>
int x;<p>
void altera_x(int v);  <p>
//somente definicao implementacao vem depois, fora da classe<p>
};<p>
<p>
void teste::altera_x(int v) { x=v;} <p>
//esta ja e a implementacao codigo <p>
 void main()<p>
{<p>
teste a;  <p>
//instaciacao de um objeto<p>
a.altera_x(10);<p>
//chamada da funcao membro com valor 10 que sera impresso a seguir<p>
cout &lt;&lt; a.x;<p>
//imprimindo o dado membro<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Resultado do programa anterior:</b><p>
<b></b>10<p>
<b></b><p>
<b></b>Programa exemplo c&iacute;rculo, mais complexo baseado no exemplo de<b>
1.2.2:</b> <CODE><p>
<b><hr></b><p>
<b></b>#include &lt;iostream.h&gt; <p>
//para cout<p>
<p>
struct circulo<p>
{<p>
float raio;<p>
float x;<p>
float y;<p>
<p>
void inicializa(float ax,float by,float cr);<p>
void altera_raio(float a);<p>
float retorna_raio(void);<p>
void move(float dx,float dy);<p>
void mostra(void);<p>
<p>
};<p>
<p>
void circulo::inicializa(float ax,float by,float cr)<p>
{<p>
x=ax;<p>
y=by;<p>
raio=cr;<p>
}<p>
<p>
<p>
void circulo::altera_raio(float a)<p>
{<p>
raio=a;<p>
}<p>
<p>
<p>
float circulo::retorna_raio(void)<p>
{<p>
return raio;<p>
}<p>
<p>
void circulo::move(float dx,float dy)<p>
{<p>
x+=dx;<p>
y+=dy;<p>
}<p>
<p>
void circulo::mostra(void)<p>
{<p>
cout &lt;&lt; "Raio:"&lt;&lt; retorna_raio() &lt;&lt;endl;<p>
cout &lt;&lt; "X:"&lt;&lt;x &lt;&lt; endl;<p>
cout &lt;&lt; "Y:" &lt;&lt;y&lt;&lt; endl;<p>
}<p>
<p>
void main()<p>
{<p>
circulo ac;<p>
ac.inicializa(0.0,0.0,10.0);<p>
ac.mostra();<p>
ac.move(1.0,1.0);<p>
ac.mostra();<p>
ac.x=100.0;<p>
ac.altera_raio(12.0);<p>
ac.mostra();<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Coment&aacute;rios:  </b><p>
<b>	</b>Observe que a fun&ccedil;&atilde;o membro mostra chama a
fun&ccedil;&atilde;o membro<CODE> float retorna_raio(void)
</CODE>que &eacute; da mesma classe. Fica impl&iacute;cito da
defini&ccedil;&atilde;o de<CODE> mostra </CODE>que<CODE>
retorna_raio()</CODE> se aplica ao mesmo objeto instanciado que recebeu a
chamada de mostra, ou seja, n&atilde;o &eacute; necess&aacute;rio usar o<b>
.</b> na chamada de<CODE> retorna_raio()</CODE>. Em programas
maiores, chamadas aninhadas de fun&ccedil;&otilde;es membro s&atilde;o bastante
comuns.<p>
<p>
<b>Programa&ccedil;&atilde;o orientada a objetos e interfaces gr&aacute;ficas
com o usu&aacute;rio:</b><p>
<b>	</b>Existem "libraries" de classes que permitem o programador C++
desenvolver aplica&ccedil;&otilde;es para ambientes como o Microsoft
Windowsreg. de uma maneira bastante abstrata, este &eacute; um exemplo claro de
reuso de c&oacute;digo, afinal o programador n&atilde;o precisa saber de
detalhes da interface para programar nela.<p>
<p>
<b>Resultado do programa:</b><p>
<b></b>Raio:10<p>
X:0<p>
Y:0<p>
Raio:10<p>
X:1<p>
Y:1<p>
Raio:12.0<p>
X:100.0<p>
Y:1<p>
<p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1)Implemente outras fun&ccedil;&otilde;es do estilo void
altera_raio(float a) e float retorna_raio(void) para os atributos X e Y.<p>
<p>
2)Fa&ccedil;a um programa simples para testar uma struct que representa um
mouse e que cont&eacute;m a posi&ccedil;&atilde;o na tela, os indicadores de
estado dos bot&otilde;es e os fun&ccedil;&atilde;o membros:
<CODE>clica_botaoA(void); move(float dx, float dy);. </CODE>
N&atilde;o &eacute; preciso fazer a liga&ccedil;&atilde;o da <CODE>struct
</CODE>com a entrada serial, embora o leitor interessado possa encontrar
na literatura de C exemplos de como faz&ecirc;-lo, esta &eacute; uma tarefa
complicada. <p>
	Seu mouse deve ser capaz de caminhar para qualquer lugar da tela
atrav&eacute;s de chamadas de fun&ccedil;&otilde;es membro, n&atilde;o deve
ultrapassar os limites estabelecidos, e deve indicar se os bot&otilde;es
est&atilde;o pressionados ou n&atilde;o atrav&eacute;s de  uma
fun&ccedil;&atilde;o semelhante a fun&ccedil;&atilde;o <CODE>mostra( )
</CODE>deste exemplo. O mouse pode ter de 1 a 3 bot&otilde;es. E
voc&ecirc; pode substituir a fun&ccedil;&atilde;o membro <CODE>move(float
dx,float dy) por  move_x(float dx); e move_y(float dy); </CODE><p>

<h3>
<a name="RTFToC8">1.2.5.
<a name="_Toc342736947"><a name="_Toc345409393"><a name="_Toc345810898"><a name="_Toc345838218"><a name="_Toc345942353"><a name="_Toc345949513"><a name="_Toc346168630"><a name="_Toc348417073"><a name="_Toc348931329"><a name="_Toc353900768"><a name="_Toc353946298">
ALGO PARECIDO EM UMA LINGUAGEM
PROCEDURAL</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
<b>	</b>Este t&oacute;pico apresenta uma compara&ccedil;&atilde;o entre C++ e
Pascal, para tal implementou-se dois programas semelhantes. O programa C++
&eacute; o programa c&iacute;rculo do t&oacute;pico anterior: 1.2.4. O programa
em Pascal vem a seguir: <CODE><p>
<b><hr></b><p>
<p>
PROGRAM Comparacao;<p>
{COMPARACAO COM UM PROGRAMA C++}<p>
<p>
TYPE Circulo=RECORD<p>
                   x:real;<p>
                   {COORDENADAS X E Y}<p>
                   y:real;<p>
                   r:real;<p>
                   {somente dados}<p>
             END;<p>
<p>
var ac:circulo;<p>
    leitura:integer;<p>
<p>
PROCEDURE Inicializa(var altereme:Circulo;ax,by,cr:real);<p>
 {COLOCA O CIRCULO EM DETERMINADA POSICAO}<p>
BEGIN<p>
 altereme.x:=ax;<p>
 altereme.y:=by;<p>
 altereme.r:=cr;<p>
END;<p>
<p>
PROCEDURE Altera_Raio(var altereme:Circulo;ar:real);<p>
{ALTERA O RAIO DO CIRCULO}<p>
BEGIN<p>
 altereme.r:=ar;<p>
END;<p>
<p>
FUNCTION Retorna_Raio(copieme:Circulo):real;<p>
BEGIN<p>
 Retorna_Raio:=copieme.r;<p>
END;<p>
<p>
PROCEDURE Move(var altereme:Circulo;dx,dy:real);<p>
{MODE AS COORDENADAS X E Y ACRESCENTANDO DX E DY}<p>
BEGIN<p>
 altereme.x:=altereme.x+dx;<p>
 altereme.y:=altereme.y+dy;<p>
END;<p>
<p>
PROCEDURE Mostra(copieme:Circulo);<p>
{MOSTRA O CIRCULO NA TELA}<p>
BEGIN<p>
 writeln('X:',copieme.x,' Y:',copieme.y,' R:',copieme.r);<p>
END;<p>
<p>
<p>
BEGIN<p>
{TESTES}<p>
 Inicializa(ac,0.0,0.0,10.0);<p>
 Mostra(ac);<p>
 Move(ac,1.0,1.0);<p>
 Mostra(ac);<p>
 ac.x:=100.0;<p>
 Altera_Raio(ac,12.0);<p>
 Mostra(ac);<p>
 read(leitura);<p>
END.<p>
</CODE><p>
<b><hr></b><p>
<b>Resultado do programa:</b><p>
<b></b>X: 0.0000000000E+00 Y: 0.0000000000E+00 R: 1.0000000000E+01<p>
X: 1.0000000000E+00 Y: 1.0000000000E+00 R: 1.0000000000E+01<p>
X: 1.0000000000E+02 Y: 1.0000000000E+00 R: 1.2000000000E+01<p>
<b></b><p>
<b>Coment&aacute;rios:</b><p>
<b>C++:</b><p>
	As classes em C++ englobam os dados membros e as fun&ccedil;&otilde;es
membros. Para executar uma a&ccedil;&atilde;o sobre o objeto ou relativa a este
basta chamar uma fun&ccedil;&atilde;o membro para este:
<CODE>ac.mostra();</CODE><p>
	A fun&ccedil;&atilde;o membro n&atilde;o precisa de muitos argumentos, porque
&eacute; pr&oacute;pria da classe e portanto ganha acesso aos dados membro do
objeto para ao qual ela foi associada:<p>
<CODE>float circulo::retorna_raio(void)<p>
{ return <b>raio</b>;  //tenho acesso direto a raio. }</CODE><p>
<p>
<b>Pascal:</b><p>
<b></b>	Em Pascal os procedimentos e os dados s&atilde;o criados de forma
separada, mesmo que s&oacute; tenham sentido juntos.<p>
	A jun&ccedil;&atilde;o entre os dados e procedimentos se d&aacute;
atrav&eacute;s de passagem de par&acirc;metros. No caso de uma linguagem
procedural  como Pascal, o que normalmente &eacute; feito se assemelha ao
c&oacute;digo seguinte: <CODE>Move(ac,1.0,1.0); </CODE>. Ac nesse
caso &eacute; um "record", mas sem fun&ccedil;&otilde;es membro, algo
semelhante ao<CODE> struct </CODE>de C (n&atilde;o
C++).<CODE> Move, </CODE> acessa os dados do "record" alterando os
campos. O par&acirc;metro &eacute; passado por refer&ecirc;ncia e o
procedimento &eacute; definido a parte do registro, embora s&oacute; sirva para
aceitar argumentos do tipo<CODE> Circulo </CODE>e mover suas
coordenadas.<p>
<b></b><p>
<b>Seguran&ccedil;a:</b><p>
<b>	</b>Em ambos programas (Pascal, C++) o programador pode acessar diretamente
os dados do tipo definido pelo usu&aacute;rio: <CODE><b>
</b>ac.x<b>:</b>=100.0; </CODE>(Pascal) ou<CODE> ac.x=100.0;
(C++).</CODE> <p>
	Veremos em 1.3 <i>ENCAPSULAMENTO</i> maneiras de proibir em C++ este tipo de
acesso direto ao dado membro, deixando este ser modificado somente pelas
fun&ccedil;&otilde;es membro. Isto nos garante maior seguran&ccedil;a e
liberdade pois podemos permitir ou n&atilde;o o acesso para cada dado membro de
acordo com nossa vontade.<p>
<p>
<b>Efici&ecirc;ncia: </b><p>
<b>	</b>Algu&eacute;m pode argumentar que programas que usam bastante chamadas
de fun&ccedil;&otilde;es podem se tornar pouco eficientes e que poderia ser
melhor acessar diretamente os dados de um tipo definido pelo usu&aacute;rio ao
env&eacute;s de passar por todo o trabalho de c&oacute;pia de argumentos,
inser&ccedil;&atilde;o da fun&ccedil;&atilde;o no pilha, etc.<p>
	Em verdade n&atilde;o se perde muito em efici&ecirc;ncia, e al&eacute;m disso
muitas vezes n&atilde;o se deseja permitir sempre o acesso direto aos dados de
um tipo definido pelo usu&aacute;rio por raz&otilde;es de seguran&ccedil;a.
Nesse sentido C++ oferece um recurso que permite ganhos em seguran&ccedil;a sem
perder muito em efici&ecirc;ncia, veja: 1.5.2.<p>
<b></b><p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1)Verifique que em main() voc&ecirc; pode modificar o
atributo<CODE> x </CODE>do objeto da classe ponto ou c&iacute;rculo
da seguinte forma: <CODE>a.x=12.2; </CODE> . Isto pode n&atilde;o
ser muito &uacute;til, imagine-se criando uma library que implementa a classe
ponto e uma s&eacute;rie de fun&ccedil;&otilde;es relacionadas, por
raz&otilde;es de seguran&ccedil;a voc&ecirc; gostaria que o usu&aacute;rio se
limitasse ao uso da interface  (fun&ccedil;&otilde;es membro) do objeto, como
faz&ecirc;-lo ser&aacute; explicado em 1.3 encapsulamento.<b> </b>Por hora,
apenas crie fun&ccedil;&otilde;es que ajudem a evitar este tipo de acesso
direto.<p>
<b>
<a name="_Ref342314457"><a name="_Toc342736948"><a name="_Toc345409394"><a name="_Toc345810899"><a name="_Toc345838219"><a name="_Toc345942354"><a name="_Toc345949514"><a name="_Toc346168631"><a name="_Toc348417074"><a name="_Toc348931330"><a name="_Toc353900769"><a name="_Toc353946299"></b>
<h3>
<a name="RTFToC9">1.2.6.
CONSTRUTORES</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>Construtores s&atilde;o fun&ccedil;&otilde;es membro especiais chamadas
pelo sistema no momento da cria&ccedil;&atilde;o de um objeto. Elas n&atilde;o
possuem valor de retorno, porque voc&ecirc; n&atilde;o pode chamar um
construtor para um objeto. Contrutores representam uma oportunidade de
inicializar de forma organizada os objetos, imagine se voc&ecirc; esquece de
inicializar corretamente ou o faz duas vezes, etc. <p>
	 Um construtor tem sempre o mesmo nome da classe e n&atilde;o pode ser chamado
pelo usu&aacute;rio desta. Para uma classe string o construtor teria a forma
<CODE>string(char* a); </CODE>com o argumento
<CODE>char*</CODE> especificado pelo programador. Ele seria chamado
automaticamente no momento da cria&ccedil;&atilde;o, declara&ccedil;&atilde;o
de uma string: <CODE><p>
 string a("Texto");  <p>
//alocacao estatica implica na chamada do construtor<p>
a.mostra();<p>
//chamada de metodos estatica. </CODE><p>
<b>	</b>Existem varia&ccedil;&otilde;es sobre o tema que veremos mais tarde:
Sobrecarga de construtor, "copy constructor", como conseguir construtores
virtuais (avan&ccedil;ado, n&atilde;o apresentado neste texto) , construtor de
corpo vazio.<p>
<b></b><p>
<b>	</b>O exemplo a seguir &eacute; simples, semelhante aos anteriores, preste
aten&ccedil;&atilde;o na fun&ccedil;&atilde;o membro com o mesmo nome que a
classe <CODE> (struct) </CODE>, este &eacute; o construtor:
<CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
struct ponto<p>
{<p>
float x;<p>
float y;<p>
public:<p>
<p>
ponto(float a,float b);<p>
//esse e o contrutor, note a ausencia do valor de retorno<p>
<p>
void mostra(void);<p>
<p>
void move(float dx,float dy);<p>
<p>
};<p>
<p>
ponto::ponto(float a,float b)<p>
//construtor tem sempre o nome da classe.<p>
{<p>
 x=a;<p>
 //incializando atributos da classe<p>
 y=b;<p>
 //colocando a casa em ordem<p>
}<p>
<p>
void ponto::mostra(void)<p>
{cout &lt;&lt; "X:" &lt;&lt; x &lt;&lt; " , Y:" &lt;&lt; y &lt;&lt; endl;}<p>
<p>
void ponto::move(float dx,float dy)<p>
{<p>
 x+=dx;<p>
 y+=dy;<p>
}<p>
<p>
void main()<p>
{<p>
ponto ap(0.0,0.0);<p>
ap.mostra();<p>
ap.move(1.0,1.0);<p>
ap.mostra();<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Resultado do programa:</b><p>
<b></b>X:0 , Y:0<p>
X:1 , Y:1<p>
<b></b><p>
<b>Coment&aacute;rios: </b><p>
<b>	</b>Deixaremos para nos aprofundarmos em aloca&ccedil;&atilde;o
din&acirc;mica e construtores em 1.5.3. Por hora voc&ecirc; pode se ater ao uso
est&aacute;tico de objetos.<p>
	Note que com a defini&ccedil;&atilde;o do construtor, voc&ecirc; &eacute;
obrigado a passar os argumentos deste  no momento da cria&ccedil;&atilde;o do
objeto. Se voc&ecirc; precisa ter a op&ccedil;&atilde;o de n&atilde;o passar
esses valores, as poss&iacute;veis solu&ccedil;&otilde;es ser&atilde;o dadas em
3.<p>
<p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1)Voc&ecirc; sabia que uma fun&ccedil;&atilde;o membro pode chamar outra
fun&ccedil;&atilde;o membro?  Parta do exemplo de 1.2.4 e crie um construtor
que chama a antiga fun&ccedil;&atilde;o <CODE>inicializa(float a,float b)
</CODE>passando os argumentos do construtor: <CODE><p>
	ponto(float a, float b)<p>
	{ inicializa(a,b); }</CODE><p>
	Na chamada de<CODE> inicializa()</CODE>fica impl&iacute;cito que
ela se aplica ao objeto cujo construtor foi chamado. Isto &eacute;
v&aacute;lido tamb&eacute;m para outras fun&ccedil;&otilde;es membro que chamam
fun&ccedil;&otilde;es membro, ou seja, n&atilde;o &eacute; necess&aacute;rio o
operador<CODE> identificador.inicializa(a,b); </CODE>, veja
1.2.3.<p>
	Este exerc&iacute;cio &eacute; &uacute;til para mostrar outro recurso de C++,
o ponteiro<CODE> this. This</CODE> &eacute; uma palavra reservada e
dentro de qualquer fun&ccedil;&atilde;o membro<CODE> this</CODE>
&eacute; um ponteiro para o objeto em quest&atilde;o, ent&atilde;o o
c&oacute;digo descrito acima poderia tamb&eacute;m assumir a seguinte forma
equivalente: <CODE><p>
	ponto(float a, float b)<p>
	{ this-&gt;inicializa(a,b); } //Verifique! </CODE><p>
	&Eacute; l&oacute;gico que neste exemplo this n&atilde;o tem muita utilidade,
mas existem casos onde um objeto precisa passar seu ponteiro para alguma
fun&ccedil;&atilde;o que o modifica, ou fica possuindo uma refer&ecirc;ncia
para ele, ent&atilde;o usa-se this. Veremos outras aplica&ccedil;&otilde;es
mais adiante. <p>
<p>
2) Introduza mensagens no construtor tipo: <CODE> cout &lt;&lt; "Objeto
instanciado."; </CODE> introduza tamb&eacute;m trechos no seu programa
parecidos com: <CODE>cin &gt;&gt; a; </CODE>, s&oacute; para que o
programa n&atilde;o rode todo de uma vez, rapidamente. O objetivo &eacute;
acompanhar visualmente a seq&uuml;&ecirc;ncia de cria&ccedil;&atilde;o e
modifica&ccedil;&atilde;o dos objetos.<p>
<p>
3)Crie uma classe reta que tem como atributos dois objetos da classe ponto.
Dica: <b>N&atilde;o use construtores</b>, use fun&ccedil;&otilde;es do
tipo<CODE> inicializa(),</CODE> j&aacute; apresentadas. Quando seu
programa ficar pronto acrescente fun&ccedil;&atilde;o membros para esta reta
tais como inclina&ccedil;&atilde;o, coeficiente linear, etc. Para acrescentar
construtores leia 1.2.7<b>. </b>Existem maneiras mais eficientes e compactas de
representar uma reta, por&eacute;m fa&ccedil;a como foi sugerido, neste caso o
objetivo n&atilde;o &eacute; efici&ecirc;ncia.<p>

<h3>
<a name="RTFToC10">1.2.7.
<a name="_Ref342217056"><a name="_Toc342736949"><a name="_Toc345409395"><a name="_Toc345810900"><a name="_Toc345838220"><a name="_Toc345942355"><a name="_Toc345949515"><a name="_Toc346168632"><a name="_Toc348417075"><a name="_Toc348931331"><a name="_Toc353900770"><a name="_Toc353946300">
CONSTRUTORES E
AGREGA&Ccedil;&Atilde;O</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
	O programa exemplo deste t&oacute;pico cria uma classe <CODE>reta
</CODE>com dois dados membro da classe ponto este exemplo &eacute; o
resultado do exerc&iacute;cio anterior, com um recurso a mais de C++. C++
permite que no construtor da classe reta, voc&ecirc; chame os construtores dos
atributos da  classe <CODE>ponto, </CODE> se voc&ecirc; n&atilde;o
o fizer o compilador acusar&aacute; um erro, pois os atributos
<CODE>ponto</CODE> possuem construtores e eles precisam ser
chamados para que a inicializa&ccedil;&atilde;o se complete de modo correto
para o conjunto. Observe o c&oacute;digo do construtor da classe
<CODE>reta</CODE> usado no exemplo:<p>
<CODE><b></b><p>
<b></b>reta(float x1,float y1,float x2,float y2):p1(x1,y1),p2(x2,y2)<p>
{<p>
//nada mais a fazer, os construtores de p1 e p2 ja foram chamados<p>
}<p>
<b></b><p>
<b></b>p1(x1,y1) e p2(x2,y2) </CODE>s&atilde;o as chamadas dos
construtores da classe ponto, elas devem ficar fora do corpo {} do construtor,
nesta lista separada por v&iacute;rgulas voc&ecirc; deve inicializar todos os
atributos. Os tipos b&aacute;sicos como int, float, etc <b>podem</b> ser
inicializados nessa lista. <p>
<p>
	Por exemplo se a classe reta tivesse um atributo inteiro de nome
identifica&ccedil;&atilde;o, a lista poderia ser da seguinte forma:<p>
<CODE><b></b><p>
<b></b>reta(float x1,float y1,float x2,float
y2):p1(x1,y1),p2(x2,y2),identificacao(10)<p>
{<p>
//nada mais a fazer, os construtores de p1 e p2 ja foram chamados<p>
}<p>
</CODE><p>
seria como se identifica&ccedil;&atilde;o tivesse um construtor que tem como
argumento seu valor.<p>
<p>
ou<p>
<CODE><p>
reta(float x1,float y1,float x2,float y2):p1(x1,y1),p2(x2,y2)<p>
{<p>
identificacao=10;<p>
//tambem pode, porque tipos b&aacute;sicos (int)  em C++ n&atilde;o s&atilde;o
objetos<p>
// portanto nao tem  construtores<p>
}<p>
</CODE><p>
	Uma outra alternativa seria usar aloca&ccedil;&atilde;o din&acirc;mica para os
atributos pontos que passariam a ser agora ponteiros para pontos, deixaremos
para discutir este t&oacute;pico mais tarde em 1.5.3, mas saiba que nesse caso
o construtor da classe reta n&atilde;o precisaria criar os pontos.<p>
<p>
	Vamos ao exemplo, que novamente &eacute; semelhante aos anteriores, para que o
leitor preste aten&ccedil;&atilde;o somente nas mudan&ccedil;as, que s&atilde;o
os conceitos novos, sem ter que se esfor&ccedil;ar muito para entender o
programa: <CODE><p>
<b><hr></b><p>
<b></b>#include &lt;iostream.h&gt;<p>
<p>
struct ponto<p>
{<p>
float x;<p>
float y;<p>
//coordenadas<p>
<p>
ponto(float a,float b)<p>
{<p>
x=a;<p>
y=b;<p>
}<p>
//construtor<p>
<p>
void move(float dx,float dy)<p>
{ x+=dx; y+=dy; }<p>
//funcao membro comum<p>
<p>
void inicializa(float a,float b)<p>
 {  x=a; y=b; }<p>
<p>
void mostra(void)<p>
 {cout &lt;&lt; "X:" &lt;&lt; x &lt;&lt; " , Y:" &lt;&lt; y &lt;&lt; endl;}<p>
<p>
};<p>
<p>
struct reta<p>
{<p>
ponto p1;<p>
ponto p2;<p>
reta(float x1,float y1,float x2,float y2):p1(x1,y1),p2(x2,y2)<p>
{<p>
//nada mais a fazer, os contrutores de p1 e p2 ja foram chamados<p>
}<p>
<p>
void mostra(void);<p>
};<p>
<p>
void reta::mostra(void)<p>
{<p>
p1.mostra();<p>
p2.mostra();<p>
}<p>
<p>
<p>
void main()<p>
{<p>
reta r1(1.0,1.0,10.0,10.0); //instanciacao da reta r1<p>
r1.mostra();<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Resultado do programa:</b><p>
<b></b>X:1 , Y:1<p>
X:10 , Y:10<p>
<b></b><p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1) Implemente um programa que use a mesma l&oacute;gica do exemplo
anterior para criar uma classe composta de outras . Voc&ecirc; estar&aacute;
usando agrega&ccedil;&atilde;o. Por exemplo um tri&acirc;ngulo  precisa de
tr&ecirc;s pontos para ser definido. <p>
<b></b><p>
<b></b>2)Uma implementa&ccedil;&atilde;o mais eficiente da classe reta seria
feita armazenando apenas um coeficiente angular e um linear, mas esta reta
deveria ent&atilde;o prover um construtor que aceitasse dois pontos como
argumentos. Como voc&ecirc; n&atilde;o aprendeu sobrecarga de construtores
(definir v&aacute;rios construtores), use s&oacute; um construtor que tem
coeficiente angular e linear como argumentos e implemente esta nova classe reta
sem usar agrega&ccedil;&atilde;o agora.<p>
<b></b><p>
<b></b>3)Defina uma fun&ccedil;&atilde;o membro para a classe
<CODE>reta</CODE> que retorna o ponto de intercess&atilde;o com
outra  reta: <CODE> ponto reta::intercessao(reta a);. </CODE>
N&atilde;o se esque&ccedil;a de tratar os casos degenerados, tais como retas
paralelas e coincidentes, use por exemplo mensagens de erro. Verifique que uma
fun&ccedil;&atilde;o membro de uma reta recebe outra reta (mesmo tipo) como
argumento. Dentro da fun&ccedil;&atilde;o membro os dados membro do argumento a
devem ser acessados do seguinte modo:<p>
<CODE>a.p1.x; </CODE><p>
	Mais tarde, em 4.5 tratamento de exce&ccedil;&otilde;es, veremos maneiras
melhores de lidar com esses casos degenerados.<p>
<b></b><p>
<b></b>4)Defina uma fun&ccedil;&atilde;o membro chamada<CODE> move
</CODE>para a classe reta, lembre-se de mover os dois pontos juntos (a
inclina&ccedil;&atilde;o n&atilde;o deve mudar).<p>
<b></b><p>
<b></b>6)Defina uma fun&ccedil;&atilde;o membro <CODE>void gira(tipox
angulo); </CODE>para a classe reta. Esta fun&ccedil;&atilde;o membro
recebe um &acirc;ngulo como argumento, voc&ecirc; pode optar por representar o
&acirc;ngulo em radianos (float) ou criar a classe &acirc;ngulo (graus,
minutos, segundos). Resolva tamb&eacute;m o problema da escolha do ponto em
torno do qual a reta deve ser girada. Use fun&ccedil;&otilde;es
matem&aacute;ticas (seno cosseno) da library
<CODE>&lt;math.h&gt;.</CODE><p>
<b>
<a name="_Toc342736950"><a name="_Toc345409396"><a name="_Toc345810901"><a name="_Toc345838221"><a name="_Toc345942356"><a name="_Toc345949516"><a name="_Toc346168633"><a name="_Toc348417076"><a name="_Toc348931332"><a name="_Toc353900771"><a name="_Toc353946301"></b>
<h3>
<a name="RTFToC11">1.2.8.
DESTRUTORES.</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b>	</b><p>
<b>	</b>An&aacute;logos aos construtores, os destrutores tamb&eacute;m
s&atilde;o fun&ccedil;&otilde;es membro chamadas pelo sistema, s&oacute; que
elas s&atilde;o chamadas quando o objeto sai de escopo ou em
aloca&ccedil;&atilde;o din&acirc;mica, tem seu ponteiro desalocado, ambas
(construtor e destrutor) n&atilde;o possuem valor de retorno. <p>
	Voc&ecirc; n&atilde;o pode chamar o destrutor, o que voc&ecirc; faz &eacute;
fornecer ao compilador o c&oacute;digo a ser executado quando o objeto &eacute;
destru&iacute;do, apagado. Ao contr&aacute;rio dos construtores, os destrutores
n&atilde;o tem argumentos.<p>
	Os destrutores s&atilde;o muito &uacute;teis para "limpar a casa"  quando um
objeto deixa de ser usado, no escopo de uma fun&ccedil;&atilde;o em que foi
criado, ou mesmo num bloco de c&oacute;digo. Quando usados em conjunto com
aloca&ccedil;&atilde;o din&acirc;mica eles fornecem uma maneira muito
pr&aacute;tica e segura de organizar o uso do "heap". A import&acirc;ncia dos
destrutores em  C++ &eacute; aumentada pela aus&ecirc;ncia de "garbage
collection" ou coleta autom&aacute;tica de lixo.<p>
	A sintaxe do destrutor &eacute; simples, ele tamb&eacute;m tem o mesmo nome da
classe s&oacute; que precedido por <CODE>~</CODE> , ele n&atilde;o
possui valor de retorno e seu argumento &eacute; void sempre:<p>
<CODE><p>
~nomedaclasse(void) { /* Codigo do destrutor */ }<p>
</CODE><p>
	O exemplo a seguir &eacute; simples, porque melhorias e extens&otilde;es sobre
o tema destrutores ser&atilde;o apresentadas ao longo do texto: <CODE><p>
<b><hr></b><p>
//destrutor de uma classe<p>
#include &lt;iostream.h&gt;<p>
<p>
struct contador{<p>
int num;<p>
contador(int n) {num=n;}<p>
//construtor<p>
void incrementa(void) {num+=1;}<p>
//funcao membro comum, pode ser chamada pelo usuario<p>
~contador(void)<p>
  {cout &lt;&lt; "Contador destruido, valor:" &lt;&lt; num &lt;&lt;endl;}<p>
//destrutor<p>
};<p>
<p>
void main()<p>
{<p>
contador minutos(0);<p>
minutos.incrementa();<p>
cout &lt;&lt; minutos.num &lt;&lt; endl;<p>
   {<p>
   //inicio de novo bloco de codigo<p>
    contador segundos(10);<p>
    segundos.incrementa();<p>
    cout &lt;&lt; segundos.num &lt;&lt;endl;<p>
   //fim de novo bloco de codigo<p>
   }<p>
minutos.incrementa();<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Resultado do programa:</b><p>
1<p>
11<p>
Contador destruido, valor:11<p>
Contador destruido, valor:2<p>
<p>
<b>Coment&aacute;rios:</b><p>
<b></b>No escopo de <CODE>main</CODE> &eacute; criado o contador
minutos com valor inicial==0.<p>
<CODE>Minutos </CODE>&eacute; incrementado, agora
<CODE>minutos.num==1. </CODE><p>
O valor de <CODE>num</CODE> em minutos &eacute; impresso na tela.<p>
	Um novo bloco de c&oacute;digo &eacute; criado.<p>
	<CODE>Segundos</CODE> &eacute; criado, instanciado como uma
vari&aacute;vel deste bloco de c&oacute;digo, o valor inicial de<CODE>
segundos</CODE> &eacute; 10, para n&atilde;o confundir com o objeto
j&aacute; criado.<p>
	<CODE>Segundos</CODE> &eacute; incrementado atingindo o valor
11.<p>
	O valor de <CODE>segundos</CODE> &eacute; impresso na tela.<p>
	Finalizamos o bloco de c&oacute;digo em que foi criado
<CODE>segundos</CODE>, agora ele sai de escopo, &eacute; apagado,
mas antes o sistema chama automaticamente o destrutor.<p>
Voltando ao bloco de c&oacute;digo de <CODE>main(),</CODE> minutos
&eacute; novamente incrementado.<p>
Finalizamos main(), agora, todas as vari&aacute;veis declaradas em
<CODE>main()</CODE>saem de escopo, mas antes o sistema chama os
destrutores daquelas que os possuem.	
<a name="_Ref342107894"><a name="_Toc342736951"><a name="_Toc345409397"><a name="_Toc345810902"><a name="_Toc345838222"><a name="_Toc345942357"><a name="_Toc345949517"><a name="_Toc346168634"><a name="_Toc348417077"><a name="_Toc348931333"><a name="_Toc353900772"><a name="_Toc353946302">
<h2>
<a name="RTFToC12">1.3.
ENCAPSULAMENTO</a></a> COM <CODE>
"CLASS</a></a></a></a></a></a></a></a></a></a>" </CODE></a>
</a></h2>
<b></b><p>
<b>	</b>Encapsulamento, "data hiding". Neste t&oacute;pico vamos falar das
maneiras de restringir o acesso as declara&ccedil;&otilde;es de uma classe,
isto &eacute; feito em C++ atrav&eacute;s do uso das palavras reservadas
<CODE>public, private e protected. </CODE><CODE>
Friends</CODE> tamb&eacute;m restringe o acesso a uma classe e &eacute;
apresentado em 4.1.<p>
            Considera&ccedil;&otilde;es sobre
C++:<i>CONSIDERA&Ccedil;&Otilde;ES C++:</i>1.5, apresenta tamb&eacute;m um
recurso de C++ para declarar objetos constantes e  proteger argumentos de
chamadas de m&eacute;todos que possam modific&aacute;-los, usando
<CODE>const </CODE>1.5.1. <b></b><p>
<b>	</b>N&atilde;o mais apresentaremos exemplos de classes declaradas
com<CODE> struct. </CODE> Tudo que foi feito at&eacute; agora pode
ser feito com a palavra<CODE> class</CODE> ao env&eacute;s de
<CODE>struct, </CODE> incluindo pequenas
modifica&ccedil;&otilde;es. <b> </b>Mas porque usar s&oacute; class nesse
tutorial? A diferen&ccedil;a &eacute; que os dados membro e
fun&ccedil;&otilde;es membro de uma <CODE>struct</CODE> s&atilde;o
acess&iacute;veis por "default" fora da<CODE> struct</CODE>
enquanto que os atributos e m&eacute;todos de uma classe n&atilde;o s&atilde;o,
acess&iacute;veis fora dela<CODE> (main) </CODE> por "default".
Voc&ecirc; nem deve ter se preocupado com isso porque usando<CODE> struct
</CODE>da forma como us&aacute;vamos, tudo ficava acess&iacute;vel.<p>
<b>	</b>Ent&atilde;o como controlar o acesso de atributos e m&eacute;todos em
uma classe? Simples, atrav&eacute;s das palavras reservadas<CODE>
private, public e protected<b>.</b> </CODE><b> </b><p>
<b>	</b><CODE>Protected </CODE>ser&aacute; explicada em 2.1 pois
est&aacute; relacionada com heran&ccedil;a, por hora vamos focalizar nossa
aten&ccedil;&atilde;o em <CODE>private e public</CODE> que
qualificam os dados membro e fun&ccedil;&otilde;es membro de uma classe quanto
ao tipo de acesso (onde eles s&atilde;o vis&iacute;veis) . <CODE> Public,
private e protected</CODE> podem ser vistos como qualificadores,
"specifiers".<p>
<b></b><p>
<b></b>Para facilitar a explica&ccedil;&atilde;o suponha a seguintes
declara&ccedil;&otilde;es <b>equivalentes<u> </u></b>de classes:<p>
1) <CODE><p>
class ponto <b>{</b>

<pre>
float x;                                                                                      
//dados membro                                                                                
float y;                                                                                      

</pre>
<b>public:</b>


<pre>
//qualificador                                                                                 
void inicializa(float a, float b) {x=a; y=b;};                                                 
//funcao membro                                                                                
void move(float dx, float dy) {x+=dx; y+=dy; };                                                

</pre>
<b>}</b>;<p>
</CODE><b></b><p>
<b></b>a declara&ccedil;&atilde;o 1 equivale totalmente &agrave;:<p>
<b></b><p>
<b></b>2) <CODE><p>
class ponto <b>{</b><p>
<b>private:</b>

<pre>
float x;                                                                                      
float y;                                                                                      

</pre>
<b>
public:</b>  

<pre>
//qualificador                                                                                
void inicializa(float a, float b) {x=a;                                                       
y=b;};                                                                                        
void move(float dx, float dy)  {x+=dx;                                                        
y+=dy; };                                                                                     

</pre>
<b>}</b>;<p>
</CODE><b></b><p>
<b></b>que equivale totalmente &agrave;:<p>
<p>
3) <CODE><p>
struct ponto <b>{</b><p>
<b>private:</b> 

<pre>
//se eu nao colocar private eu perco o encapsulamento em struct.                              
float x;                                                                                      
float y;                                                                                      

</pre>
<b>public:</b>

<pre>
//qualificador                                                                                
void inicializa(float a, float b) {x=a;                                                       
y=b;};                                                                                        
void move(float dx, float dy) {x+=dx; y+=dy;                                                  
};                                                                                            

</pre>
<b>}</b>;<p>
</CODE><b></b><p>
<b>	</b>Fica f&aacute;cil entender essas declara&ccedil;&otilde;es se
voc&ecirc; pensar no seguinte: esses qualificadores se aplicam aos
m&eacute;todos e atributos que vem ap&oacute;s eles, se houver ent&atilde;o um
outro qualificador, teremos agora um novo tipo de acesso para os m&eacute;todos
declarados posteriormente.<p>
	Mas ent&atilde;o porque as declara&ccedil;&otilde;es s&atilde;o equivalentes?
&Eacute; porque o qualificador <CODE>private</CODE> &eacute;
"default" para class, ou seja se voc&ecirc; n&atilde;o especificar nada ,
at&eacute; que se insira um qualificador, tudo o que for declarado numa classe
&eacute; private. J&aacute; em struct, o que &eacute; default &eacute; o
qualificador<CODE> public. </CODE><p>
	Agora vamos entender o que &eacute; private e o que &eacute; public:<p>
Vamos supor que voc&ecirc; instanciou (criou)  um objeto do tipo
<CODE>ponto</CODE>  em seu programa:<p>
<CODE><p>
ponto meu; //instanciacao<p>
</CODE><b></b><p>
<b></b>	Segundo o uso de qualquer uma das defini&ccedil;&otilde;es da classe
ponto dadas acima voc&ecirc; <b>n&atilde;o</b> pode escrever no seu programa:<p>
<CODE><b></b><p>
<b></b>meu.x=5.0;  //<b>erro !</b><p>
</CODE><p>
,como faz&iacute;amos nos exemplos de 1.2 , a n&atilde;o ser que x fosse
declarado depois de <CODE>public</CODE> na defini&ccedil;&atilde;o
da classe o que n&atilde;o ocorre aqui. Mas voc&ecirc; pode
escrever<CODE> x=5.0; </CODE>na implementa&ccedil;&atilde;o
(dentro) de um m&eacute;todo porque enquanto n&atilde;o for feito uso de
heran&ccedil;a, porque uma fun&ccedil;&atilde;o membro tem acesso a tudo que
&eacute; de sua classe, veja o programa seguinte.<p>
	Voc&ecirc; pode escrever: <CODE> meu.move(5.0,5.0); </CODE>
,porque sua declara&ccedil;&atilde;o <CODE> (move) </CODE>
est&aacute; na parte<CODE> public </CODE>da classe. Aqui o leitor
j&aacute; percebe que podem existir fun&ccedil;&otilde;es membro<CODE>
private</CODE> tamb&eacute;m, e estas s&oacute; s&atilde;o
acess&iacute;veis dentro do c&oacute;digo da classe (outras
fun&ccedil;&otilde;es membro).<p>
	Visibilidade das declara&ccedil;&otilde;es de uma classe, fora dela e de sua
hierarquia. Veja que s&oacute; a parte <CODE>public</CODE> &eacute;
vis&iacute;vel neste caso:<p>
<p>
<p>
<p>
Visibilidade das declara&ccedil;&otilde;es de uma classe, dentro dela mesma:<p>
<b></b><p>
<b></b><p>
<b></b><p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1) Qual das seguintes declara&ccedil;&otilde;es permite que se acesse em
main <b>somente</b> os m&eacute;todos <CODE>move e
inicializa</CODE>, encapsulando todos os outros elementos da classe?
Obs.: A ordem das &aacute;reas <CODE>private e public</CODE> pode
estar invertida com rela&ccedil;&atilde;o aos exemplos anteriores.<p>
<p>
a) <CODE><p>
<b>struct</b> ponto <b>{</b><p>
<b></b>//se eu nao colocar private eu perco o encapsulamento em struct.<p>
float x;<p>
float y;<p>
<b>public:</b><p>
<b></b> //qualificador<p>
void inicializa(float a, float b) {x=a; y=b;};<p>
void move(float dx, float dy) ; {x+=dx; y+=dy; };<p>
<b>}</b>;</CODE><p>
<p>
b) <CODE><p>
class ponto <b>{</b><p>
<b>public:</b>  <p>
//qualificador<p>
void inicializa(float a, float b) {x=a; y=b;};<p>
void move(float dx, float dy) ; {x+=dx; y+=dy; };<b></b><p>
<b>private:</b><p>
<b></b>float x;<p>
float y;<b></b><p>
<b>}</b>;</CODE><p>
<p>
c) <CODE><p>
class ponto <b>{</b><p>
<b>public:</b> <p>
//qualificador<p>
void inicializa(float a, float b) {x=a; y=b;}; <p>
//funcao membro<p>
void move(float dx, float dy) ; {x+=dx; y+=dy; };<p>
float x;  <p>
//dados membro<p>
float y;  <p>
<b>}</b>;</CODE><p>

<h3>
<a name="RTFToC13">1.3.1.
<a name="_Ref342221443"><a name="_Toc342736952"><a name="_Toc345409398"><a name="_Toc345810903"><a name="_Toc345838223"><a name="_Toc345942358"><a name="_Toc345949518"><a name="_Toc346168635"><a name="_Toc348417078"><a name="_Toc348931334"><a name="_Toc353900773"><a name="_Toc353946303">
ATRIBUTOS <CODE>PRIVATE, </CODE>FUN&Ccedil;&Otilde;ES MEMBRO
<CODE>PUBLIC</a></a></a></a></a></a></a></a></a></a></a> </CODE></a>
</a></h3>
<b></b><p>
<b>	</b>Aplicando encapsulamento a classe ponto definida anteriormente.
<CODE><p>
<b><hr></b><p>
<b></b>#include &lt;iostream.h&gt;<p>
<p>
class ponto<p>
{<p>
private:<p>
//nao precisaria por private, em class e default<p>
float x;  <p>
//sao ocultos por default<p>
float y;   <p>
//sao ocultos por default<p>
public:  <p>
//daqui em diante tudo e acessivel.<p>
<p>
void inicializa(float a,float b)<p>
 {  x=a; y=b; } <p>
//as funcoes de uma classe podem acessar os atributos private dela mesma.<p>
<p>
void mostra(void)<p>
 {cout &lt;&lt; "X:" &lt;&lt; x &lt;&lt; " , Y:" &lt;&lt; y &lt;&lt; endl;}<p>
};<p>
<p>
void main()<p>
{<p>
ponto ap; //instanciacao<p>
ap.inicializa(0.0,0.0); //metodos public<p>
ap.mostra(); //metodos public<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Resultado do programa:</b><p>
<b></b>X:0 , Y:0<p>
<b></b><p>
<b>Coment&aacute;rios: </b><p>
<b>	</b>Este programa n&atilde;o deixa voc&ecirc; tirar o ponto de<CODE>
(0,0) </CODE>a n&atilde;o ser que seja chamada<CODE> inicializa
</CODE>novamente. Fica claro que agora, encapsulando <CODE>x e y
</CODE>precisamos de mais m&eacute;todos para que a classe n&atilde;o
tenha sua funcionalidade limitada. <p>
Novamente: escrever <CODE>ap.x=10; </CODE>em main &eacute; um erro!
Pois<CODE> x </CODE>est&aacute; qualificada como<CODE>
private</CODE>. Leia os exerc&iacute;cios.<p>
<p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1) Implemente os m&eacute;todos<CODE> void altera_x(float a) ,
float retorna_x(void), void move (float dx,float dy ); </CODE>.Implemente
outros m&eacute;todos que achar importantes exemplo <CODE>void
distancia(ponto a) { return dist(X,Y,a.X,a.Y); },</CODE> onde dist
representa o conjunto de opera&ccedil;&otilde;es matem&aacute;ticas
necess&aacute;rias para obter a dist&acirc;ncia entre <CODE> (X,Y)
(a.X,a.Y). </CODE> Voc&ecirc; provavelmente usar&aacute; a
funcao<CODE> sqr()</CODE> da "library" <CODE>
&lt;math.h&gt;</CODE> que define a raiz quadrada de um<CODE> float.
</CODE><p>
Veja que no m&eacute;todo<CODE> distancia</CODE>, podemos acessar
os dados membro X e Y do argumento a, isto &eacute; permitido porque distancia
&eacute; uma fun&ccedil;&atilde;o membro da mesma classe de a, embora
n&atilde;o do mesmo objeto, uma maneira de prover este tipo de acesso para
outras classes &eacute; dotar a classe ponto de m&eacute;todos do tipo
<CODE>float retorna_x(void);. </CODE>
<CODE>Friends</CODE> 4.1 &eacute; um t&oacute;pico avan&ccedil;ado
sobre encapsulamento que lida com visibilidade entre classes distintas.<p>
	Quando voc&ecirc; precisar de outras fun&ccedil;&otilde;es matem&aacute;ticas
(seno, coseno), lembre-se da "library" <CODE>&lt;math.h&gt;,</CODE>
&eacute; s&oacute; pesquisar o manual do compilador ou usar ajuda
sens&iacute;vel ao contexto para &lt;math.h&gt; ou at&eacute; mesmo dar uma
olhadinha na interface dela, no diret&oacute;rio das "libraries", alias essa
&eacute; uma boa maneira de aprender sobre como implementa-las.<p>
<p>
2) Retorne ao in&iacute;cio deste t&oacute;pico e releia as
defini&ccedil;&otilde;es equivalentes de classes declaradas com<CODE>
struct </CODE>e com <CODE>class. </CODE> Refa&ccedil;a o
programa exemplo anterior usando <CODE>struct, </CODE>use
encapsulamento em outros programas que voc&ecirc; implementou.<p>

<h3>
<a name="RTFToC14">1.3.2.
<a name="_Toc342736953"><a name="_Toc345409399"><a name="_Toc345810904"><a name="_Toc345838224"><a name="_Toc345942359"><a name="_Toc345949519"><a name="_Toc346168636"><a name="_Toc348417079"><a name="_Toc348931335"><a name="_Toc353900774"><a name="_Toc353946304">
UM DADO MEMBRO &Eacute;
<CODE>PUBLIC</a></a></a></a></a></a></a></a></a></a></CODE></a>
</a></h3>
<p>
<b>	</b>Este programa &eacute; uma variante do anterior, a &uacute;nica
diferen&ccedil;a &eacute; que Y &eacute; colocado na parte<CODE> public
</CODE>da defini&ccedil;&atilde;o da classe e &eacute; acessado
diretamente. Al&eacute;m disso fornecemos aqui a fun&ccedil;&atilde;o
membro<CODE>  move</CODE>, para que voc&ecirc; possa tirar o ponto
do lugar. <CODE><p>
<b><hr></b><p>
<b></b>#include &lt;iostream.h&gt;<p>
<p>
class ponto<p>
{<p>
float x; <p>
//sao ocultos por default<p>
public:  <p>
//daqui em diante tudo e acessivel.<p>
<p>
ponto(float a,float b);<p>
//construtor tambem pode ser inline ou nao<p>
<p>
void mostra(void);<p>
void move(float dx,float dy);<p>
float y;  <p>
//* Y nao e' mais ocultado<p>
<p>
};<p>
<p>
ponto::ponto(float a,float b)<p>
{<p>
 x=a;<p>
 y=b;<p>
}<p>
void ponto::mostra(void)<p>
{cout &lt;&lt; "X:" &lt;&lt; x &lt;&lt; " , Y:" &lt;&lt; y &lt;&lt; endl;}<p>
<p>
void ponto::move(float dx,float dy)<p>
{<p>
 x+=dx;<p>
 y+=dy;<p>
}<p>
<p>
void main()<p>
{<p>
ponto ap(0.0,0.0);<p>
ap.mostra();<p>
ap.move(1.0,1.0);<p>
ap.mostra();<p>
ap.y=100.0;<p>
ap.mostra();<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Resultado do programa:</b><p>
<b></b>X:0 , Y:0<p>
X:1 , Y:1<p>
X:1 , Y:100<b></b><p>
<b></b><p>
<b>Coment&aacute;rios: </b><p>
<b>	</b>Observe que agora nada impede que voc&ecirc; acesse diretamente y:
<CODE> ap.y=100.0</CODE>, por&eacute;m<CODE>
ap.x=10.00</CODE> &eacute; um erro. Observe em que parte (&aacute;rea) da
classe cada um desses dados membro foi declarado.<p>
<b></b><p>
<b>Exerc&iacute;cios: </b><p>
<b></b>1)Crie os m&eacute;todos  <CODE>float retorna_x(void), void
altera_x(float a); </CODE> que devem servir para retornar o valor
armazenado em <CODE>x </CODE>e para alterar o valor armazenado
em<CODE> x </CODE>respectivamente. Crie tamb&eacute;m as
respectivas fun&ccedil;&otilde;es retorna e altera para todos os outros
atributos.<p>
<b>
<a name="_Toc342736954"><a name="_Toc345409400"><a name="_Toc345810905"><a name="_Toc345838225"><a name="_Toc345942360"><a name="_Toc345949520"><a name="_Toc346168637"><a name="_Toc348417080"><a name="_Toc348931336"><a name="_Toc353900775"><a name="_Toc353946305"></b>
<h3>
<a name="RTFToC15">1.3.3.
COMPILANDO UM PROGRAMA COM V&Aacute;RIOS
ARQUIVOS.</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>Compilando um programa dividido em v&aacute;rios arquivos. Normalmente
os programas C++ s&atilde;o divididos em arquivos para melhor
organiza&ccedil;&atilde;o e encapsulamento, por&eacute;m nada impede que o
programador fa&ccedil;a seu programa em um s&oacute; arquivo. O programa
exemplo da classe<CODE> ponto </CODE>de 1.3.1 poderia ser dividido
da seguinte forma:<p>
<CODE><p>
<b><hr></b><p>
<b></b>//Arquivo 1 ponto.h, definicao para a classe ponto.<p>
class ponto<p>
{<p>
public:  <p>
//daqui em diante tudo e acessivel.<p>
void inicializa(float a,float b);<p>
void mostra(void);<p>
private:<p>
float x;   <p>
//sao ocultos por default<p>
float y;   <p>
//sao ocultos por default<p>
};<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//Arquivo 2 , ponto.cpp , implementacao para a classe ponto.<p>
#include &lt;iostream.h&gt;<p>
#include "ponto.h"<p>
<p>
void ponto::inicializa(float a,float b)<p>
 {  x=a; y=b; } <p>
//as funcoes de uma classe podem acessar os atributos private dela mesma.<p>
<p>
void ponto::mostra(void)<p>
 {cout &lt;&lt; "X:" &lt;&lt; x &lt;&lt; " , Y:" &lt;&lt; y &lt;&lt; endl;}<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//Arquivo 3 . Programa principal: princ.cpp<p>
#include "ponto.h"<p>
<p>
void main()<p>
{<p>
ponto ap; <p>
//instanciacao<p>
ap.inicializa(0.0,0.0);<p>
//metodos public<p>
ap.mostra(); <p>
//metodos public<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>	</b>Os arquivos com extens&atilde;o .h indicam header files. &Eacute;
costume deixar nesses arquivos somente a interface das classes e
fun&ccedil;&otilde;es para que o usu&aacute;rio possa olh&aacute;-lo, como numa
"library". Note que a parte <CODE>public</CODE> da classe foi
colocada antes da parte <CODE>private</CODE>, isto porque
normalmente &eacute; essa parte da defini&ccedil;&atilde;o da classe que
interessa para o leitor. <p>
<b>	</b>No nosso caso o &uacute;nico arquivo `header' (.h) que temos &eacute; o
<CODE> "ponto.h" </CODE>que define a classe<CODE> ponto.
</CODE> Caso as dimens&otilde;es de seu programa permitam, opte por
separar cada classe em um `header file', ou cada grupo de entidades
(fun&ccedil;&otilde;es, classes) relacionadas.<p>
<b>	</b>O arquivo 2  "ponto.cpp" &eacute; um arquivo de
implementa&ccedil;&atilde;o. Ele tem o mesmo nome do arquivo <CODE>
"ponto.h" </CODE>, embora  isto n&atilde;o seja obrigat&oacute;rio.
&Eacute; mais organizado ir formando pares de arquivos "header /
implementation". <p>
<b>	</b>Este arquivo fornece o c&oacute;digo para as opera&ccedil;&otilde;es da
classe<CODE> ponto</CODE>, da&iacute; a declara&ccedil;&atilde;o:
<CODE> #include "ponto.h".</CODE> As aspas indicam que se trata de
um arquivo criado pelo usu&aacute;rio e n&atilde;o uma "library" da linguagem
como <CODE>&lt;iostream.h&gt;,</CODE> portanto o diret&oacute;rio
onde se deve encontrar o arquivo &eacute; diferente do diret&oacute;rio onde se
encontra <CODE>&lt;iostream.h&gt;.</CODE><p>
<b>	</b>O arquivo 3 <CODE> "princ.cpp" </CODE> &eacute; o arquivo
principal do programa, n&atilde;o &eacute; costume relacionar seu nome com
nomes de outros arquivos como no caso do arquivo 2 e o arquivo 1. <p>
	Observe que o arquivo 3 tamb&eacute;m declara<CODE> #include "ponto.h",
</CODE> isto porque ele faz uso das dos tipos definidos em<CODE>
"ponto.h" </CODE>, por&eacute;m <CODE> "princ.cpp"
</CODE>n&atilde;o precisa declarar <CODE>#include
&lt;iostream.h&gt;</CODE> porque este n&atilde;o usa diretamente as
defini&ccedil;&otilde;es de <CODE>iostream</CODE> em nenhum
momento, caso <CODE> "princ.cpp" </CODE>o fizesse, o
<CODE>include &lt;iostream&gt; </CODE>seria necess&aacute;rio.<p>
	O leitor encontrar&aacute; em alguns dos exemplos seguintes as diretivas de
compila&ccedil;&atilde;o. Quando da elabora&ccedil;&atilde;o de uma library
para ser usada por outros programadores, n&atilde;o se esque&ccedil;a de
us&aacute;-las:<p>
<CODE><b></b><p>
<b></b>#ifndef MLISTH_H <p>
#define MLISTH_H <p>
//Codigo<p>
#endif<p>
</CODE><p>
<p>
<p>
<p>
<CODE><p>
<p>
#ifndef MLISTH_H<p>
#define MLISTH_H<p>
<p>
//defina aqui seu header file.<p>
//perceba que "Nomearq.h" e escrito na diretiva como NOMEARQ_H<p>
<p>
#endif<p>
</CODE><p>
<p>
<p>
<p>
<p>
<p>
<p>
Essas diretivas servem para evitar que um header file seja inclu&iacute;do mais
de uma vez no mesmo projeto. O seu uso se d&aacute; da seguinte forma:<p>
<p>
Diagrama sugest&atilde;o para organiza&ccedil;&atilde;o de programas
relativamente simples:<p>
<CENTER><IMG SRC="hiera.gif" ></CENTER>
<b></b><p>
<b></b><p>
<b>	</b>Saber compilar programas divididos em v&aacute;rios arquivos &eacute;
muito importante. Isto requer um certo esfor&ccedil;o por parte do programador,
porque os m&eacute;todos podem variar de plataforma para plataforma. Pergunte
para um programador experiente de seu grupo.<p>
	Se o seu compilador &eacute; de linha de comando, provavelmente voc&ecirc;
poder&aacute; compilar programas divididos em v&aacute;rios arquivos usando
makefiles. J&aacute; se seu compilador opera num ambiente gr&aacute;fico, esta
tarefa pode envolver a cria&ccedil;&atilde;o de um projeto.<p>
<b>
<a name="_Ref342453770"><a name="_Toc342736955"><a name="_Toc345409401"><a name="_Toc345810906"><a name="_Toc345838226"><a name="_Toc345942361"><a name="_Toc345949521"><a name="_Toc346168638"><a name="_Toc348417081"><a name="_Toc348931337"><a name="_Toc353900776"><a name="_Toc353946306"></b>
<h2>
<a name="RTFToC16">1.4.
TIPO ABSTRATO DE DADOS</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h2>
<b> </b><p>
<b>	</b>Tipo abstrato de dados, TAD, se preocupa em proporcionar uma
abstra&ccedil;&atilde;o sobre uma estrutura de dados em termos de uma interface
bem definida.  S&atilde;o importantes os aspectos de encapsulamento, que
mant&eacute;m a integridade do objeto evitando acessos inesperados, e o fato de
o c&oacute;digo estar armazenado em um s&oacute; lugar o que cria um programa
modific&aacute;vel, leg&iacute;vel, coeso.<p>
	Uma classe implementa um tipo abstrato de dados.<b></b><p>
<b></b><p>
<b></b>S&atilde;o exemplos de tipos abstratos de dados:<p>
1) Uma &aacute;rvore bin&aacute;ria com as opera&ccedil;&otilde;es usuais de
inser&ccedil;&atilde;o, remo&ccedil;&atilde;o, busca ...<p>
<b></b><p>
<b></b>2)Uma representa&ccedil;&atilde;o para n&uacute;meros racionais
(numerador, denominador) que possua as opera&ccedil;&otilde;es
aritm&eacute;ticas b&aacute;sicas e outras de convers&atilde;o de tipos.<p>
<b></b><p>
<b></b>3)Uma representa&ccedil;&atilde;o para &acirc;ngulos na forma (Graus,
Minutos, Segundos). Tamb&eacute;m com as opera&ccedil;&otilde;es relacionadas,
bem como as opera&ccedil;&otilde;es para converter para radianos, entre
outras.<p>
<b></b><p>
<b></b>	Tipo abstrato de dados &eacute; um conceito muito importante em
programa&ccedil;&atilde;o orientada a objeto e por este motivo &eacute; logo
apresentado neste tutorial. Os exemplos seguintes s&atilde;o simples devido ao
fato de n&atilde;o podermos usar todos os recursos  C++ por raz&otilde;es
did&aacute;ticas. Devido a esta import&acirc;ncia, a medida em que formos
introduzindo novos recursos exemplificaremos tamb&eacute;m com
aplica&ccedil;&otilde;es na implementa&ccedil;&atilde;o tipos abstratos de
dados.
<h3>
<a name="RTFToC17">1.4.1.
<a name="_Ref342701933"><a name="_Toc342736956"><a name="_Toc345409402"><a name="_Toc345810907"><a name="_Toc345838227"><a name="_Toc345942362"><a name="_Toc345949522"><a name="_Toc346168639"><a name="_Toc348417082"><a name="_Toc348931338"><a name="_Toc353900777"><a name="_Toc353946307">
TAD FRA&Ccedil;&Atilde;O</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>Tipo abstrato de dados fra&ccedil;&atilde;o. Baseado no conceito de
n&uacute;mero racional do campo da matem&aacute;tica. Algumas
opera&ccedil;&otilde;es n&atilde;o foram implementadas por serem semelhantes
&agrave;s existentes. O exemplo mais completo se encontra em 4.1.2. Por hora
n&atilde;o podemos fazer uso de recursos avan&ccedil;ados como sobrecarga de
operador e templates.<p>
<b></b><p>
<b></b>Resumo das opera&ccedil;&otilde;es matem&aacute;ticas envolvidas:<p>
<p>
Simplifica&ccedil;&atilde;o de fra&ccedil;&atilde;o: (a/b)=( (a/mdc(a,b))  /
(b/mdc(a,b)) ) <p>
Onde mdc(a,b) retorna o m&aacute;ximo divisor comum de ab.<p>
<p>
Soma de fra&ccedil;&atilde;o: (a/b)+(c/d)=( (a.d+c.b) / b.d ) simplificada.<p>
<p>
Multiplica&ccedil;&atilde;o de fra&ccedil;&atilde;o: (a/b) * (c/d)= ( (a*c) /
(b*d) ) simplificada.<p>
<p>
Igualdade: (a/b)== (c/d) se a*d == b*c. <p>
<p>
N&atilde;o igualdade: (a/b) != (c/d) se a*d b*c<p>
<p>
Maior ou igual que: (a/b)(c/d) se a*d  b*c<p>
<p>
<p>
<b>T&oacute;picos abordados:</b> <p>
	Construtores em geral, destrutores, tipo <CODE>long, </CODE>
criando m&eacute;todos de convers&atilde;o de tipos, m&eacute;todos chamando
m&eacute;todos do mesmo objeto, operador % que retorna o resto da
divis&atilde;o de dois inteiros.<p>
<CODE><p>
<b><hr></b><p>
//header file para o TAD fracao.<p>
//File easyfra.h<p>
<p>
long mdc(long n,long d);<p>
//maximo divisor comum metodo de Euclides.<p>
<p>
class fracao {<p>
	private:<p>
		long num;<p>
//numerador<p>
		long den;<p>
//denominador<p>
	public:<p>
		fracao(long t,long m);<p>
//construtor comum<p>
		void simplifica(void);<p>
//divisao pelo mdc<p>
		~fracao() { /* nao faz nada*/ }<p>
//Nao e preciso fazer nada.<p>
<p>
//operacoes matematicas basicas<p>
		fracao soma (fracao j);<p>
		fracao multiplicacao(fracao j);<p>
<p>
//operacoes de comparacao<p>
		int igual(fracao t);<p>
		int diferente(fracao t);<p>
		int maiorouigual(fracao t);<p>
<p>
<p>
//operacoes de input output<p>
	  void mostra(void);<p>
//exibe fracao no video<p>
	  void cria(void);<p>
//pergunta ao usuario o valor da fracao<p>
<p>
//operacoes de conversao de tipos<p>
	  double convertedbl(void);<p>
//converte para double<p>
	  long convertelng(void);<p>
//converte para long<p>
};<p>
<p>
<b><hr></b><p>
<p>
//implementacao para a classe fracao.<p>
#include &lt;iostream.h&gt;<p>
#include "easyfra.h"<p>
<p>
<p>
long mdc(long n,long d)<p>
//maximo divisor comum<p>
//metodo de Euclides +- 300 anos AC.<p>
{<p>
 if (n&lt;0) n=-n;<p>
 if (d&lt;0) d=-d;<p>
 while (d!=0) {<p>
	long r=n % d;<p>
//%=MOD=Resto da divisao inteira.<p>
	n=d;<p>
	d=r;<p>
	}<p>
	return n;<p>
}<p>
<p>
void fracao::simplifica(void)<p>
{<p>
long commd;<p>
commd=mdc(num,den);<p>
//divisor comum<p>
num=num/commd;<p>
den=den/commd;<p>
if (den&lt;0) { den=-den; num=-num;};<p>
//move sinal para cima<p>
}<p>
<p>
fracao::fracao(long t,long m)<p>
{<p>
 num=(t);<p>
 den=(m);<p>
 simplifica();   //chamada para o mesmo objeto.<p>
}<p>
<p>
fracao fracao::soma(fracao j)<p>
{<p>
fracao g((num*j.den)+(j.num*den),den*j.den);<p>
return g;<p>
}<p>
fracao fracao::multiplicacao(fracao j)<p>
{<p>
 fracao g(num*j.num,den*j.den);<p>
 return g;<p>
}<p>
<p>
<p>
int fracao::igual(fracao t)<p>
{<p>
 return ((num*t.den)==(den*t.num));<p>
//funciona bem mesmo para nao simplificada<p>
}<p>
<p>
int fracao::diferente(fracao t)<p>
{<p>
 return ((num*t.den)!=(den*t.num));<p>
}<p>
<p>
int fracao::maiorouigual(fracao t)<p>
{<p>
 return ((num*t.den)&gt;=(t.num*den));<p>
}<p>
<p>
void fracao::mostra(void)<p>
{<p>
 cout &lt;&lt; "(" &lt;&lt; num &lt;&lt; "/" &lt;&lt; den &lt;&lt; ")";<p>
}<p>
<p>
void fracao::cria(void)<p>
 {<p>
  cout &lt;&lt; "Numerador:";<p>
  cin &gt;&gt; num;<p>
  cout &lt;&lt; "Denominador:";<p>
  cin &gt;&gt; den;<p>
  simplifica();<p>
 }<p>
<p>
double fracao::convertedbl(void)<p>
{<p>
double dbl;<p>
dbl=(double(num)/double(den));<p>
return dbl;<p>
}<p>
<p>
//conversao para long<p>
long fracao::convertelng(void)<p>
{<p>
long lng;<p>
lng=num/den;<p>
return lng;<p>
}<p>
<p>
<b><hr></b><p>
<p>
#include &lt;iostream.h&gt;<p>
#include "easyfra.h"<p>
//nossa definicao da classe<p>
#include &lt;stdio.h&gt;<p>
main()<p>
{<p>
fracao a(0,1),b(0,1);<p>
cout &lt;&lt; " Entre com fracao a: ";<p>
a.cria();<p>
a.mostra();<p>
cout &lt;&lt; " Entre com fracao b: ";<p>
b.cria();<p>
b.mostra();<p>
fracao c(a.soma(b));<p>
//c(a+b)<p>
cout &lt;&lt; endl &lt;&lt; "c de a+b:";<p>
c.mostra();<p>
cout &lt;&lt; endl &lt;&lt; "a*b";<p>
c=a.multiplicacao(b);<p>
c.mostra();<p>
cout &lt;&lt; endl &lt;&lt; "a+b";<p>
c=a.soma(b);<p>
c.mostra();<p>
cout &lt;&lt; endl &lt;&lt; "a&gt;=b";<p>
cout &lt;&lt; a.maiorouigual(b);<p>
cout &lt;&lt; endl &lt;&lt; "a==b";<p>
cout &lt;&lt; a.igual(b);<p>
cout &lt;&lt; endl &lt;&lt; "a!=b";<p>
cout &lt;&lt; a.diferente(b);<p>
cout &lt;&lt; endl &lt;&lt; "long(a) ";<p>
cout &lt;&lt; a.convertelng();<p>
cout &lt;&lt; endl &lt;&lt; "double(a) ";<p>
cout &lt;&lt; a.convertedbl();<p>
return 0;<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b></b><p>
<b>Coment&aacute;rios: </b><p>
<b>	</b>Observe o seguinte c&oacute;digo usado no programa: <CODE> fracao
c(a.soma(b));. </CODE> O resultado de <CODE>a.soma(b)
</CODE>&eacute; uma fra&ccedil;&atilde;o, mas n&atilde;o criamos um
construtor que recebe uma fra&ccedil;&atilde;o como argumento, como isso foi
poss&iacute;vel no programa? <p>
	Simples, a linguagem oferece para as classes que voc&ecirc; cria a
c&oacute;pia bit a bit. Cuidado com o uso dessa c&oacute;pia em conjunto com
aloca&ccedil;&atilde;o din&acirc;mica, objetos poder&atilde;o ter c&oacute;pias
iguais de ponteiros, ou seja compartilhar uso de posi&ccedil;&otilde;es na
mem&oacute;ria. De qualquer forma, em 0 explicaremos como redefinir esta
c&oacute;pia de modo a evitar situa&ccedil;&otilde;es indesej&aacute;veis como
a c&oacute;pia de ponteiros e em 1.5.3 explicaremos melhor os perigos de usar
este tipo de c&oacute;pia em conjunto com aloca&ccedil;&atilde;o
din&acirc;mica.<b></b><p>
<b></b><p>
<b>Resultado do programa:</b><p>
<b></b> Entre com fracao a: Numerador:4<p>
Denominador:2<p>
(2/1) Entre com fracao b: Numerador:5<p>
Denominador:3<p>
(5/3)<p>
c de a+b:(11/3)<p>
a*b(10/3)<p>
a+b(11/3)<p>
a&gt;=b1<p>
a==b0<p>
a!=b1<p>
long(a) 2<p>
double(a) 2<p>
<b></b><p>
<b>Exerc&iacute;cios:	</b><p>
<b></b>1) Modifique  o tipo fra&ccedil;&atilde;o para aceitar as seguintes
fun&ccedil;&otilde;es membro.<p>
<CODE><b></b><p>
<b></b>long retorna_num(void) {return num;}<p>
long altera_den(float a) { den=a;}<p>
</CODE><b></b><p>
<b>	</b>Considerando que os atributos declarados em
<CODE>private</CODE> n&atilde;o s&atilde;o acess&iacute;veis fora
da classe, descreva a utilidade dessas fun&ccedil;&otilde;es. Eles s&atilde;o
&uacute;teis  se usadas pelas pr&oacute;prias fun&ccedil;&otilde;es membro de
fra&ccedil;&atilde;o?<p>
<b></b><p>
<b></b>*2) Implemente o tipo abstrato de dados n&uacute;mero complexo com as
opera&ccedil;&otilde;es matem&aacute;ticas inerentes. Fa&ccedil;a antes um
projeto das fun&ccedil;&otilde;es membro que ser&atilde;o implementadas
descrevendo tamb&eacute;m as opera&ccedil;&otilde;es matem&aacute;ticas
necess&aacute;rias.<p>
<b></b><p>
<b></b>*3) Outro tipo abstrato de dados extremamente &uacute;til &eacute; o
tipo abstrato de dados string que deve fornecer: copy constructor,
opera&ccedil;&otilde;es de compara&ccedil;&atilde;o ( ordem
lexicogr&aacute;fica ), concatena&ccedil;&atilde;o, substring , entre outras.
Implemente este tipo abstrato de dados, tendo em mente a seguinte pergunta:
"Voc&ecirc; poderia substituir um tipo fracao ou inteiro usado em uma rotina de
ordenacao pela sua implementa&ccedil;&atilde;o de string sem fazer grandes
modifica&ccedil;&otilde;es?". Essa pergunta final ser&aacute; muito importante
quando come&ccedil;armos a discutir templates 4.3.<p>
<b></b><p>
<b></b>4)Continue trabalhando no TAD fra&ccedil;&atilde;o, implemente os
m&eacute;todos restantes (menor que, subtra&ccedil;&atilde;o)  de modo
an&aacute;logo &agrave;s implementa&ccedil;&otilde;es fornecidas.<p>
<b></b><p>
<b></b>5)Pesquise sobre matrizes em C++. Crie um tipo abstrato de dados matriz
que suporte atribui&ccedil;&otilde;es e leituras de c&eacute;lulas contendo
elementos do tipo float. Crie outros m&eacute;todos para este tipo abstrato de
dados como multiplica&ccedil;&atilde;o por uma constante.<b></b><p>
<b>
<a name="_Ref342218514"><a name="_Toc342736957"><a name="_Toc345409403"><a name="_Toc345810908"><a name="_Toc345838228"><a name="_Toc345942363"><a name="_Toc345949523"><a name="_Toc346168640"><a name="_Toc348417083"><a name="_Toc348931339"><a name="_Toc353900778"><a name="_Toc353946308"></b>
<h2>
<a name="RTFToC18">1.5.
CONSIDERA&Ccedil;&Otilde;ES
C++:</a></a></a></a></a></a></a></a></a></a></a></a> 
</a></h2>
<p>
	Neste t&oacute;pico iremos explicar recursos mais particulares de C++,
por&eacute;m n&atilde;o menos importantes para a programa&ccedil;&atilde;o
orientada a objetos na linguagem. Alguns recursos como const que est&aacute;
relacionado com encapsulamento poder&atilde;o ser retirados deste t&oacute;pico
em novas vers&otilde;es do tutorial.
<a name="_Ref342381426">
<h3>
<a name="RTFToC19">1.5.1.
<a name="_Ref342702773"><a name="_Toc342736958"><a name="_Toc345409404"><a name="_Toc345810909"><a name="_Toc345838229"><a name="_Toc345942364"><a name="_Toc345949524"><a name="_Toc346168641"><a name="_Toc348417084"><a name="_Toc348931340"><a name="_Toc353900779"><a name="_Toc353946309">
CONST</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
	Este exemplo mostra o uso de fun&ccedil;&otilde;es const e sua
import&acirc;ncia para o encapsulamento. <CODE>Const</CODE> pode
qualificar um par&acirc;metro de fun&ccedil;&atilde;o (assegurando que este
n&atilde;o ser&aacute; modificado),  uma fun&ccedil;&atilde;o membro
(assegurando que esta n&atilde;o modifica os dados membro de sua classe), ou
uma inst&acirc;ncia de objeto/tipo (assegurando que este n&atilde;o ser&aacute;
modificado.)<p>
	Os modos de qualifica&ccedil;&atilde;o descritos atuam em conjunto, para
assegurar que um objeto const n&atilde;o ser&aacute; modificado, C++ s&oacute;
permite que sejam chamados para este objeto fun&ccedil;&otilde;es membro
qualificadas como <CODE>const. Const </CODE>&eacute; tamb&eacute;m
um qualificador, "specifier".<p>
<CODE><p>
<p>
<b><hr></b><p>
<p>
#include &lt;iostream.h&gt;<p>
#include &lt;math.h&gt;<p>
//double sqrt(double x); de math.h retorna raiz quadrada do numero<p>
//double pow(double x, double y); de math.h calcula x a potencia de y<p>
<p>
<p>
const float ZERO=0.0;<p>
<p>
class ponto<p>
{<p>
private:<p>
float x;<p>
//sao ocultos por default nao precisaria private mas e' bom<p>
float y;<p>
//sao ocultos por default<p>
public:<p>
//daqui em diante tudo e acessivel em main.<p>
<p>
ponto(float a,float b)<p>
 {  x=a; y=b; }<p>
<p>
void mostra(void) const<p>
 {cout &lt;&lt; "X:" &lt;&lt; x &lt;&lt; " , Y:" &lt;&lt; y &lt;&lt; endl;}<p>
<p>
float distancia(const ponto hi) const<p>
 {<p>
  return<p>
	float(<p>
		  sqrt(<p>
				  (<p>
					 pow(double(hi.x-x),2.0)<p>
					 +<p>
					 pow(double(hi.y-y),2.0)<p>
				  )<p>
				)<p>
		  );<p>
  //teorema de Pitagoras<p>
 }<p>
<p>
};<p>
<p>
<p>
void main()<p>
{<p>
ponto ap(3.0,4.0);<p>
//instanciacao<p>
ap.mostra();<p>
//funcoes membro public<p>
const ponto origem(ZERO,ZERO);<p>
//defino objeto constante<p>
origem.mostra();<p>
cout &lt;&lt; "Distancia da origem:" &lt;&lt; origem.distancia(ap); <p>
}<p>
<p>
<b><hr></b><p>
</CODE><p>
<p>
<b>Resultado do programa:</b><p>
<b></b>X:3 , Y:4<p>
X:0 , Y:0<p>
Distancia da origem:5<p>
<p>
<b>Coment&aacute;rios:</b><p>
<b></b>Const qualificando inst&acirc;ncias de objetos/tipos: <CODE><p>
const ponto origem(ZERO,ZERO);<p>
const float ZERO=0.0;<p>
</CODE><p>
Const qualificando fun&ccedil;&otilde;es: <CODE><p>
float distancia(const ponto hi) <b>const</b>;<p>
</CODE><p>
Const qualificando argumentos: <CODE><p>
float distancia(<b>const</b> ponto hi) const;<p>
</CODE><p>
<b>Exerc&iacute;cios:</b><p>
1)Use tudo o que voc&ecirc; aprendeu sobre const na classe reta, definida em
CONSTRUTORES E AGREGA&Ccedil;&Atilde;O 1.2.7. <p>
<a name="_Ref342132315"><a name="_Toc342736959"><a name="_Toc345409405"><a name="_Toc345810910"><a name="_Toc345838230"><a name="_Toc345942365"><a name="_Toc345949525"><a name="_Toc346168642"><a name="_Toc348417085"><a name="_Toc348931341"><a name="_Toc353900780"><a name="_Toc353946310">
<h3>
<a name="RTFToC20">1.5.2.
FUN&Ccedil;&Otilde;ES
INLINE</a></a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>Requisitos</b>: <p>
	Saber como um programa se comporta na mem&oacute;ria, em termos de chamadas de
fun&ccedil;&atilde;o e gerenciamento da pilha, "stack".<p>
<b>	</b>O que s&atilde;o fun&ccedil;&otilde;es inline: Imagine uma chamada de
uma fun&ccedil;&atilde;o membro void altera_raio(float a)  da classe circulo
j&aacute; apresentada, <CODE>ac.altera_raio(a). </CODE> Esta
chamada envolve a passagem de par&acirc;metros, inser&ccedil;&atilde;o da
fun&ccedil;&atilde;o na pilha (stack), retorno de um valor <CODE> (void),
</CODE> tudo isso representa uma diminui&ccedil;&atilde;o da velocidade
do programa com rela&ccedil;&atilde;o a um simples: <CODE>ac.raio=a;
</CODE>que nesse caso funcionaria muito bem.<p>
	Ocorre que n&oacute;s desejamos usar chamadas de m&eacute;todos, vimos
inclusive meios de esconder, encapsular o atributo raio para que a &uacute;nica
alternativa para alterar seu valor seja atrav&eacute;s da chamada de
<CODE>altera_raio(a). </CODE> Porque programar desta forma? Porque
&eacute; mais seguro, mais pr&oacute;ximo dos princ&iacute;pios de
orienta&ccedil;&atilde;o a objetos. Em verdade POO se caracteriza por muitas
chamadas de m&eacute;todos e uso do "heap", &aacute;rea de mem&oacute;ria usada
pela aloca&ccedil;&atilde;o din&acirc;mica.<p>
	O que as fun&ccedil;&otilde;es declaradas como inline fazem &eacute; traduzir
a chamada do m&eacute;todo em tempo de compila&ccedil;&atilde;o em um
equivalente <CODE>ac.raio=17.0. </CODE>evitando  todo o contratempo
descrito. Essa tradu&ccedil;&atilde;o do m&eacute;todo &eacute; colocada na
sequ&ecirc;ncia de c&oacute;digo do programa, voc&ecirc; pode ter v&aacute;rios
trechos que chamariam fun&ccedil;&otilde;es,  desviariam o fluxo do programa
at&eacute; o retorno desta, convertidos em instru&ccedil;&otilde;es simples.
Como desvantagem temos o aumento do tamanho do programa, visto que
passar&atilde;o a existir v&aacute;rias c&oacute;pias diferentes da
fun&ccedil;&atilde;o no programa (uma para cada argumento) ao env&eacute;s de
um s&oacute; prot&oacute;tipo de fun&ccedil;&atilde;o que era colocado na pilha
no momento da chamada e ent&atilde;o tinha os argumentos substitu&iacute;dos.<p>
	Nos programa anteriores sobre a classe c&iacute;rculo, se a
fun&ccedil;&atilde;o membro mostra fosse <CODE>inline
</CODE>haveria uma convers&atilde;o da chamada interna (dentro de mostra)
de <CODE>retorna_raio()</CODE>em simplesmente<CODE> ac.raio.
</CODE> Pode haver convers&atilde;o de v&aacute;rias
fun&ccedil;&otilde;es<CODE> inline</CODE> aninhadas, estas
convers&otilde;es s&atilde;o seguras, porque s&atilde;o feitas pelo
compilador.<p>
	Normalmente &eacute; vantajoso usar<CODE> inline</CODE> para
fun&ccedil;&otilde;es pequenas que n&atilde;o aumentem muito o tamanho do
programa ou fun&ccedil;&otilde;es onde velocidade &eacute; crucial. Aqui vale a
conhecida regra  80:20, oitenta porcento do tempo do programa &eacute; gasto em
vinte por cento dos m&eacute;todos. Por&eacute;m o programador n&atilde;o
precisa se preocupar muito com fun&ccedil;&otilde;es <CODE>inline
</CODE>na fase de desenvolvimento, este &eacute; um recurso C++ para
aumento de efici&ecirc;ncia que pode muito bem ser deixado para o final do
projeto. Saiba por&eacute;m que as diferen&ccedil;as de tempo decorrentes de
seu uso s&atilde;o sens&iacute;veis.<p>
<p>
	Este exemplo explora as possibilidades que temos para declarar
fun&ccedil;&otilde;es membro e como declar&aacute;-las para que sejam do
tipo<CODE> inline: </CODE><CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
struct ponto<p>
{<p>
float x;<p>
float y;<p>
<p>
void inicializa(float a,float b)<p>
 {  x=a; y=b; } //Apesar de nao especificado compilador tenta<p>
 //expandir chamada da funcao como inline porque esta dentro da definicao da
classe.<p>
<p>
void mostra(void); //com certeza nao e' inline, externa a classe e sem
qualificador.<p>
inline void move(float dx,float dy); //e' inline , prototipo, definicao<p>
};<p>
<p>
void ponto::mostra(void)<p>
{cout &lt;&lt; "X:" &lt;&lt; x &lt;&lt; " , Y:" &lt;&lt; y &lt;&lt; endl;}<p>
<p>
inline void ponto::move(float dx,float dy) //implementacao, codigo<p>
{<p>
 x+=dx;<p>
 y+=dy;<p>
}<p>
<p>
void main()<p>
{<p>
ponto ap;<p>
ap.inicializa(0.0,0.0);<p>
ap.mostra();<p>
ap.move(1.0,1.0);<p>
ap.mostra();<p>
ap.x=100.0;<p>
ap.mostra();<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Coment&aacute;rios</b>: <p>
	O compilador tenta converter a fun&ccedil;&atilde;o<CODE>
inicializa</CODE> em<CODE> inline, </CODE> embora n&atilde;o
esteja especificado com a palavra reservada inline que isto &eacute; para ser
feito. Esta &eacute; uma regra, sempre que a fun&ccedil;&atilde;o estiver
definida na pr&oacute;pria classe <CODE> (struct{}) </CODE>o
compilador tentar&aacute; convert&ecirc;-la em <CODE>inline.
</CODE> Foi dito que o compilador tenta porque isto pode variar de
compilador para compilador, se ele n&atilde;o consegue converter em
<CODE>inline</CODE> , devido a complexidade da
fun&ccedil;&atilde;o, voc&ecirc; &eacute; normalmente  avisado, tendo que
trocar o lugar da defini&ccedil;&atilde;o da fun&ccedil;&atilde;o membro. <p>
	Note que se a fun&ccedil;&atilde;o membro &eacute; implementada fora da
classe, tanto o prot&oacute;tipo da fun&ccedil;&atilde;o membro, quanto a
implementa&ccedil;&atilde;o devem vir especificados com<CODE>
inline</CODE> para que a convers&atilde;o ocorra.<p>
<p>
<b>Resultado do programa:</b> <p>
X:0 , Y:0<p>
X:1 , Y:1<p>
X:100 , Y:1<b></b><p>
<b>
<a name="_Ref342134358"></b>
<h3>
<a name="RTFToC21">1.5.3.
<a name="_Ref342297067"><a name="_Toc342736960"><a name="_Toc345409406"><a name="_Toc345810911"><a name="_Toc345838231"><a name="_Toc345942366"><a name="_Toc345949526"><a name="_Toc346168643"><a name="_Toc348417086"><a name="_Toc348931342"><a name="_Toc353900781"><a name="_Toc353946311">
ALOCA&Ccedil;&Atilde;O DIN&Acirc;MICA COM NEW E
DELETE</a></a></a></a></a></a></a></a></a></a></a></a></a>.
</a></h3>
<p>
	Neste t&oacute;pico ser&atilde;o apresentados os recursos de C++ para
aloca&ccedil;&atilde;o din&acirc;mica de vari&aacute;veis de tipos simples e
objetos, ou seja, estudaremos a aloca&ccedil;&atilde;o de estruturas em tempo
de execu&ccedil;&atilde;o.<p>
<a name="_Ref342376580"><a name="_Toc342736961"><a name="_Toc345838232"><a name="_Toc345942367"><a name="_Toc345949527"><a name="_Toc346168644"><a name="_Toc348417087"><a name="_Toc348931343"><a name="_Toc353900782"><a name="_Toc353946312">
<h4>
<a name="RTFToC22">1.5.3.1.
PONTEIROS, "POINTERS"</a></a></a></a></a></a></a></a></a></a>
</a></h4>
<i></i><p>
<i></i>	Este exemplo mostra como trabalhar com ponteiros para vari&aacute;veis
de tipos pr&eacute;-definidos (n&atilde;o definidos pelo usu&aacute;rio)
usando<CODE> new e delete. </CODE><p>
<p>
	O programa a seguir cria um ponteiro para uma vari&aacute;vel inteira, aloca
mem&oacute;ria para esta vari&aacute;vel e imprime seu valor. <CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
void main()<p>
{<p>
int* a;<p>
//declara um ponteiro para endereco de variavel inteira<p>
<p>
a=new int(3);<p>
//aloca memoria para o  apontado por a, gravando neste o valor 3<p>
<p>
cout &lt;&lt; (*a) &lt;&lt; endl ;<p>
//imprime o valor do apontado por a<p>
<p>
delete a;<p>
//desaloca memoria<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Resultado do programa:</b><p>
<b></b>3<p>
<b></b>

<pre>
Diagrama das vari&aacute;veis na mem&oacute;ria:                                                            <CENTER><IMG SRC="pointer.gif" ></CENTER>

</pre>
<b></b><p>
<b></b><p>
<b>Coment&aacute;rios: </b><p>
	Se a fosse uma <CODE>struct </CODE>ou <CODE>class
</CODE>e tivesse um dado membro chamado<CODE> dd</CODE>,
poder&iacute;amos obter o valor de <CODE>dd </CODE>atrav&eacute;s
de <CODE> (*a).dd </CODE>que pode ser todo abreviado em
<CODE>a-&gt;dd</CODE> onde<CODE> -&gt;</CODE> &eacute;
uma seta, ou flecha que voc&ecirc; pode ler como "o apontado" novamente. Os
par&ecirc;nteses em <CODE> (*a).dd </CODE>s&atilde;o
necess&aacute;rios devido a preced&ecirc;ncia do operador . com
rela&ccedil;&atilde;o ao<CODE> *</CODE>. Esta sintaxe abreviada
ser&aacute; bastante usada quando alocarmos dinamicamente objetos.<p>
<i></i><p>
<i></i><b>Observa&ccedil;&atilde;o:</b> <CODE><p>
int* a;<p>
a=new int(3);<p>
</CODE><p>
pode ser abreviado por:<p>
<CODE><p>
int* a=new int(3);<p>
</CODE><b></b>
<h4>
<a name="RTFToC23">1.5.3.2.
<a name="_Ref342371105"><a name="_Toc342736962"><a name="_Toc345838233"><a name="_Toc345942368"><a name="_Toc345949528"><a name="_Toc346168645"><a name="_Toc348417088"><a name="_Toc348931344"><a name="_Toc353900783"><a name="_Toc353946313">
VETORES CRIADOS ESTATICAMENTE</a></a></a></a></a></a></a></a></a></a>
</a></h4>
<p>
	O exemplo a seguir aloca estaticamente, em tempo de compila&ccedil;&atilde;o,
um vetor de inteiros com tr&ecirc;s posi&ccedil;&otilde;es. Em seguida,
gravamos as tr&ecirc;s posi&ccedil;&otilde;es e as mostramos na tela:
<CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
void main()<p>
{<p>
int a[3];<p>
//aloca o vetor de tamanho 3,  estaticamente<p>
<p>
a[0]=1;<p>
//atribui a posicao indice 0 do vetor<p>
<p>
a[1]=2;<p>
//atribui 2 a posicao indice 1 do vetor<p>
<p>
a[2]=3;<p>
//atribui 3 a posicao indice 2 do vetor<p>
<p>
cout &lt;&lt; a[0] &lt;&lt; " " &lt;&lt; a[1] &lt;&lt; " " &lt;&lt; a[2]
&lt;&lt; endl;<p>
//mostra o vetor<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Resultado do programa:</b><p>
<b></b>1 2 3<p>
<p>
<b>Resumo da sintaxe de vetores:</b> <CODE><b></b><p>
<b></b>int a[3]; //cria um vetor de inteiros a com tres posicoes, indices uteis
de 0 ate 2<p>
float b[9]; //cria um vetor de float b com nove posicoes, indices uteis de 0
ate 8<p>
<p>
b[8]=3.14156295; //grava 3.1415... na ultima posicao do vetor b<p>
<p>
if (b[5]==2.17) { /*acao*/} ; //teste de igualdade<p>
</CODE><p>
<b>Diagrama do vetor:</b><p>
<b></b><p>
<b></b><p>
<b>	</b><p>
<b>	</b>Perceba que a faixa &uacute;til do vetor vai de 0 at&eacute; (n-1) onde
n &eacute; o valor dado como tamanho do vetor no momento de sua
cria&ccedil;&atilde;o, no nosso caso 3. <p>
	Nada impede que voc&ecirc; grave ou leia &iacute;ndices fora dessa &aacute;rea
&uacute;til, isso &eacute; muito perigoso, porque  fora dessa &aacute;rea, o
que voc&ecirc; tem s&atilde;o outras vari&aacute;veis de mem&oacute;ria e
n&atilde;o o espa&ccedil;o reservado para seu vetor. &Eacute; perfeitamente
aceit&aacute;vel, embora desastroso escrever em nosso programa<CODE>
a[4]=3;. </CODE> O compilador calcula o endere&ccedil;o de mem&oacute;ria
da posi&ccedil;&atilde;o 4 com base na posi&ccedil;&atilde;o inicial do vetor e
o tamanho do tipo alocado. Ap&oacute;s calculado o endere&ccedil;o da
posi&ccedil;&atilde;o 4 o valor 3 &eacute; copiado, apagando o conte&uacute;do
anterior!<p>
<p>
<b>Coment&aacute;rios:</b> <p>
	Note que n&atilde;o estamos usando ponteiros neste exemplo e &eacute; por isso
que o vetor &eacute; alocado estaticamente, em tempo de
compila&ccedil;&atilde;o, &eacute; tamb&eacute;m por este motivo que o
argumento que vai no lugar do 3 no c&oacute;digo <CODE>int a[3];
</CODE>deve ser uma express&atilde;o constante e n&atilde;o uma
vari&aacute;vel.<p>
<b></b>
<h4>
<a name="RTFToC24">1.5.3.3.
<a name="_Ref342371083"><a name="_Toc342736963"><a name="_Toc345838234"><a name="_Toc345942369"><a name="_Toc345949529"><a name="_Toc346168646"><a name="_Toc348417089"><a name="_Toc348931345"><a name="_Toc353900784"><a name="_Toc353946314">
COPIA DE OBJETOS COM VETORES ALOCADOS
ESTATICAMENTE.</a></a></a></a></a></a></a></a></a></a>
</a></h4>
<b>	</b><p>
<b>	</b>No primeiro exemplo do TAD fra&ccedil;&atilde;o vimos que o compilador
fornece c&oacute;pia bit a bit para objetos, alertamos tamb&eacute;m sobre o
perigo de usar este tipo de c&oacute;pia em conjunto com aloca&ccedil;&atilde;o
din&acirc;mica. O exemplo seguinte mostra um caso onde esta c&oacute;pia
oferecida pelo compilador &eacute; segura, o t&oacute;pico seguinte 1.5.3.4
mostra um caso onde esta c&oacute;pia n&atilde;o &eacute; segura, leia ambos
para ter uma vis&atilde;o geral do assunto: <CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
class vetor_tres<p>
{<p>
public:<p>
 int vet[3];<p>
//vetor alocado estaticamente numa classe.<p>
<p>
 vetor_tres(int a,int b,int c)<p>
 { vet[0]=a; vet[1]=b; vet[2]=c; }<p>
//construtor do vetor<p>
<p>
 void mostra(void)<p>
 { cout &lt;&lt; vet[0] &lt;&lt; " " &lt;&lt; vet[1] &lt;&lt; " " &lt;&lt;
vet[2] &lt;&lt; endl;}<p>
//funcao membro para mostrar o conteudo do vetor<p>
};<p>
<p>
<p>
void main()<p>
{<p>
vetor_tres v1(1,2,3);<p>
//criacao de um objeto vetor.<p>
<p>
vetor_tres v2(15,16,17);<p>
//criacao de um objeto vetor.<p>
<p>
v1.mostra();<p>
//mostrando o conteudo de v1.<p>
<p>
v2.mostra();<p>
//mostrando o conteudo de v2.<p>
<p>
v2=v1;<p>
//atribuindo objeto v1 ao objeto v2.<p>
<p>
v2.mostra();<p>
//mostrando v2 alterado.<p>
<p>
v1.vet[0]=44;<p>
<p>
v1.mostra();<p>
//mostrando o conteudo de v1.<p>
<p>
v2.mostra();<p>
//mostrando o conteudo de v2.<p>
}<p>
<b><hr></b><p>
</CODE><p>
<b>Resultado do programa:</b><p>
<b></b>1 2 3<p>
15 16 17<p>
1 2 3<p>
44 2 3<p>
1 2 3<p>
<p>
<b>Coment&aacute;rios:</b> <p>
	Perceba que no caso de aloca&ccedil;&atilde;o est&aacute;tica, quando o
tamanho do vetor &eacute; conhecido em tempo de compila&ccedil;&atilde;o a
c&oacute;pia &eacute; segura. Por c&oacute;pia segura entenda: as
posi&ccedil;&otilde;es do vetor s&atilde;o copiadas uma a uma e os objetos
n&atilde;o ficam fazendo refer&ecirc;ncia a um mesmo vetor, isto pode ser visto
no resultado do programa, quando alteramos a c&oacute;pia de <CODE>v1,
v1</CODE> n&atilde;o se altera.<p>

<h4>
<a name="RTFToC25">1.5.3.4.
<a name="_Ref342353774"><a name="_Toc342736964"><a name="_Toc345838235"><a name="_Toc345942370"><a name="_Toc345949530"><a name="_Toc346168647"><a name="_Toc348417090"><a name="_Toc348931346"><a name="_Toc353900785"><a name="_Toc353946315">
VETORES CRIADOS DINAMICAMENTE</a></a></a></a></a></a></a></a></a></a>
</a></h4>
<b></b><p>
<b></b>	O exemplo a seguir &eacute; an&aacute;logo ao de 1.5.3.2, mas os
vetores s&atilde;o alocados dinamicamente, ou seja, voc&ecirc; determina em
tempo de execu&ccedil;&atilde;o qual o tamanho do vetor, Pascal n&atilde;o
permite isso.<p>
	<CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
void main()<p>
{<p>
int tamanho;<p>
//armazena o tamanho do vetor a criar.<p>
int* vet;<p>
//ponteiro para inteiro ou vetor de inteiro ainda nao criado<p>
<p>
cout &lt;&lt; "Entre com o tamanho do vetor a criar";<p>
cin &gt;&gt; tamanho;<p>
<p>
vet=new int[tamanho];<p>
//alocando vetor de "tamanho" posicoes comecando em a[0]<p>
<p>
for (int i=0;i&lt;tamanho;i++)<p>
{<p>
cout &lt;&lt; "Entre com o valor da posicao " &lt;&lt; i &lt;&lt; ":";<p>
cin &gt;&gt; vet[i];<p>
cout &lt;&lt; endl;<p>
}<p>
//loop de leitura no vetor<p>
<p>
for (int j=0;j&lt;tamanho;j++)<p>
{<p>
cout &lt;&lt; "Posicao " &lt;&lt; j &lt;&lt; ":" &lt;&lt; vet[j]&lt;&lt;endl;<p>
}<p>
//loop de impressao do vetor<p>
<p>
<p>
}<p>
</CODE><p>
<b><hr></b><i></i><p>
<i></i><b>Resultado do programa:</b><p>
<b></b>Entre com o tamanho do vetor a criar3<p>
Entre com o valor da posicao 0:1<p>
<p>
Entre com o valor da posicao 1:2<p>
<p>
Entre com o valor da posicao 2:3<p>
<p>
Posicao 0:1<p>
Posicao 1:2<p>
Posicao 2:3<p>
<p>
<b>Coment&aacute;rios:</b> <CODE><b></b><p>
<b></b>int* a;<p>
<p>
Declara um ponteiro para inteiro.<p>
<p>
a=new int[10];<p>
</CODE><p>
Diferente de <CODE>new int(10); </CODE>os colchetes indicam que
&eacute; para ser criado um vetor de tamanho 10 e n&atilde;o uma
vari&aacute;vel de valor 10 como em 1.5.3.1. Ao contr&aacute;rio de
aloca&ccedil;&atilde;o est&aacute;tica, o par&acirc;metro que vai no lugar do
valor 10 n&atilde;o precisa ser uma express&atilde;o constante.<p>
<CODE><b></b><p>
<b></b>int* a;<p>
a=new int[10];<p>
</CODE><p>
equivale a forma abreviada:<p>
<CODE><p>
int* a=new int[10];<p>
</CODE><p>
A faixa de &iacute;ndices &uacute;teis do vetor novamente vai de 0 at&eacute;
(10-1) ou (n-1).<p>
<b></b>
<h4>
<a name="RTFToC26">1.5.3.5.
<a name="_Ref342451473"><a name="_Toc342736965"><a name="_Toc345838236"><a name="_Toc345942371"><a name="_Toc345949531"><a name="_Toc346168648"><a name="_Toc348417091"><a name="_Toc348931347"><a name="_Toc353900786"><a name="_Toc353946316">
COPIA DE OBJETOS COM VETORES ALOCADOS
DINAMICAMENTE.</a></a></a></a></a></a></a></a></a></a>
</a></h4>
<p>
	Essa determina&ccedil;&atilde;o do tamanho do vetor em tempo de
execu&ccedil;&atilde;o vai tornar a c&oacute;pia de objetos feita pelo
compilador diferente, ele vai copiar o ponteiro para o vetor, ou seja os
objetos passam a compartilhar a estrutura na mem&oacute;ria, o que nem sempre
pode ser desej&aacute;vel! Existem maneiras de redefinir esta c&oacute;pia
feita pelo compilador o que veremos em 0.<p>
<CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
class vetor_tres<p>
{<p>
public:<p>
 int* vet;<p>
//vetor alocado estaticamente numa classe.<p>
<p>
 vetor_tres(int a,int b,int c)<p>
 {<p>
  vet=new int[3];<p>
  vet[0]=a;<p>
  vet[1]=b;<p>
  vet[2]=c;<p>
 }<p>
//construtor do vetor<p>
<p>
 void mostra(void)<p>
 { cout &lt;&lt; vet[0] &lt;&lt; " " &lt;&lt; vet[1] &lt;&lt; " " &lt;&lt;
vet[2] &lt;&lt; endl;}<p>
//funcao membro para mostrar o conteudo do vetor<p>
};<p>
<p>
<p>
void main()<p>
{<p>
vetor_tres v1(1,2,3);<p>
//criacao de um objeto vetor.<p>
<p>
vetor_tres v2(15,16,17);<p>
//criacao de um objeto vetor.<p>
<p>
v1.mostra();<p>
//mostrando o conteudo de v1.<p>
<p>
v2.mostra();<p>
//mostrando o conteudo de v2.<p>
<p>
v2=v1;<p>
//atribuindo objeto v1 ao objeto v2.<p>
<p>
v2.mostra();<p>
//mostrando v2 alterado.<p>
<p>
v1.vet[0]=44;<p>
<p>
v1.mostra();<p>
//mostrando o conteudo de v1.<p>
<p>
v2.mostra();<p>
//mostrando o conteudo de v2.<p>
}<p>
<b><hr></b><p>
</CODE><p>
<b>Resultado do programa:</b><p>
<b></b>1 2 3<p>
15 16 17<p>
1 2 3<p>
44 2 3<p>
44 2 3<p>
<p>
<b>Coment&aacute;rios: </b><p>
<b>	</b>Note que quando alteramos a c&oacute;pia de v1, v1 se altera. Isto
ocorre porque  o vetor n&atilde;o &eacute; copiado casa a casa como em 1.5.3.3,
s&oacute; se copia o ponteiro para a posi&ccedil;&atilde;o inicial do vetor,  a
partir do qual se calcula os endere&ccedil;os das posi&ccedil;&otilde;es
seguintes <CODE>v[3]==*(v+3). </CODE><p>
<p>
	Sobre o texto acima: "a partir do qual se calcula os endere&ccedil;os das
posi&ccedil;&otilde;es seguintes", veja o programa exemplo: <CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
void main()<p>
{<p>
int* v;<p>
v=new int[3];<p>
<p>
cout &lt;&lt; *(v+1)&lt;&lt;endl;<p>
//imprime o lixo contido na memoria de v[1]<p>
<p>
cout &lt;&lt; v[1] &lt;&lt;endl;<p>
//imprime o lixo contido na memoria de v[1]<p>
<p>
//*(v)==v[0] &eacute; uma expressao sempre verdadeira<p>
}<p>
<b><hr></b><p>
</CODE><p>
<b>Resultado do programa:</b><p>
<b></b>152<p>
152<p>
<p>
<b>Coment&aacute;rios:</b> <p>
	O que &eacute; importante deste exerc&iacute;cio &eacute; que s&oacute; se
armazena a posi&ccedil;&atilde;o inicial do vetor, as outras
posi&ccedil;&otilde;es s&atilde;o calculadas com base no tamanho do tipo
alocado e regras de aritm&eacute;tica de ponteiros. N&atilde;o podemos nos
estender muito neste tema, leia sobre aritm&eacute;tica de ponteiros,
por&eacute;m para este tutorial, basta usar os vetores de forma que esta
aritm&eacute;tica fique por conta da linguagem.<p>
	Vetores alocados dinamicamente e ponteiros s&atilde;o a mesma coisa, isto pode
ser visto nesse programa exemplo que mistura a sintaxe de vetores e de
ponteiros. <p>
 <b></b>
<h4>
<a name="RTFToC27">1.5.3.6.
<a name="_Ref342454699"><a name="_Toc342736966"><a name="_Toc345838237"><a name="_Toc345942372"><a name="_Toc345949532"><a name="_Toc346168649"><a name="_Toc348417092"><a name="_Toc348931348"><a name="_Toc353900787"><a name="_Toc353946317">
TAD E ALOCA&Ccedil;&Atilde;O
DIN&Acirc;MICA.</a></a></a></a></a></a></a></a></a></a>
</a></h4>
<p>
Tipo abstrato de dados vetor.<p>
<p>
	Um dos grandes problemas de trabalhar com vetores comuns de C++<CODE> (
int * a; a=new int[10]; a[22]=3; ) </CODE>&eacute; que
freq&uuml;entemente lemos &iacute;ndices inv&aacute;lidos, ou pior gravamos
encima deles.<p>
	Gravar encima de um &iacute;ndice fora dos limites de um vetor &eacute; um
erro freq&uuml;ente em programa&ccedil;&atilde;o C++. Saiba que fazendo isso
voc&ecirc; pode estar apagando instru&ccedil;&otilde;es de outros programas na
mem&oacute;ria e outras informa&ccedil;&otilde;es importantes! Em alguns casos
quando isso ocorre obt&eacute;m-se inclusive mensagens do sistema operacional
avisando que algo est&aacute; errado e que &eacute; necess&aacute;rio
reinicializar a m&aacute;quina. <p>
<p>
<b>Curiosidade</b>:<p>
	Houve um caso de v&iacute;rus na internet que se baseava no acesso a
&iacute;ndices fora de um vetor para gravar por cima de
instru&ccedil;&otilde;es do sistema operacional, c&oacute;digo que garantisse a
sua multiplica&ccedil;&atilde;o.<p>
	Algumas linguagens de programa&ccedil;&atilde;o como Pascal e M&oacute;dula-3
checam os &iacute;ndices para que n&atilde;o se acesse &aacute;reas
inv&aacute;lidas de um vetor. M&oacute;dula-3 fornece inclusive os limites dos
vetores simples da linguagem atrav&eacute;s de chamadas<CODE> last(vetor)
ou first(vetor) </CODE> . Em C++ tal tipo de checagem pode ser
implementada pelo programador como faremos neste exemplo.<p>
<p>
<b>Dica de Programa&ccedil;&atilde;o:</b><p>
<b>	</b>Lembre-se: seu sucesso em programa&ccedil;&atilde;o vai depender em
muito de sua disciplina e organiza&ccedil;&atilde;o tenha sempre em mente que
C++ &eacute; uma linguagem poderosa e que se n&atilde;o usada corretamente pode
criar transtornos e erros n&atilde;o percept&iacute;veis em testes do programa.
<p>
	N&atilde;o checar os &iacute;ndices de um vetor em programas grandes &eacute;
como instalar uma bomba rel&oacute;gio em seu c&oacute;digo, &eacute; muito
prov&aacute;vel que em algum instante voc&ecirc; ou at&eacute; mesmo outra
pessoa usando seu programa se distraia e acabe por escrever uma rotina que
acessa um &iacute;ndice inv&aacute;lido de um vetor, fazendo na maioria das
vezes o programa falhar.<p>
	A proposta deste exemplo &eacute; criar um tipo abstrato de dados vetor com
uma interface flex&iacute;vel que sirva para v&aacute;rias
aplica&ccedil;&otilde;es e possa ser facilmente estendida. Este exemplo
&eacute; simples e vai ser reapresentado com  muitas melhorias no decorrer do
tutorial, dentre elas: "templates" 4.3, "exception handling" 4.5,  e a
cria&ccedil;&atilde;o de uma classe iterador para o vetor4.1 . A primeira vista
voc&ecirc; pode achar que este programa n&atilde;o oferece muito mais que o uso
comum de vetores em C++, mas com as melhorias que apresentaremos, certamente
voc&ecirc; vai preferir representar vetores como tipos abstratos de dados ou
TAD's.<p>
<CODE><p>
<b><hr></b><p>
//file exvet1.h<p>
//header file para classe vetor <p>
const int inicio=0;<p>
<p>
class vetor{<p>
private:<p>
int* v;            <p>
//este e' o vetor<p>
int tamanho;  <p>
//tamanho maximo do vetor,<p>
public:<p>
vetor (int tam); 			 <p>
//construtor, aloca mem&oacute;ria para o vetor.<p>
void atribui(int index,int valor);    <p>
//altera uma posicao do vetor<p>
int conteudo(int index);               <p>
//retorna conteudo de posicao do vetor<p>
int maximo(void);                      <p>
//retorna o maior elemento do vetor<p>
int primeiro(void);                   <p>
 //primeiro  indice do vetor<p>
int ultimo(void);                      <p>
//ultimo indice do vetor<p>
~vetor() {delete v;}               <p>
//inline function ou use delete v[];<p>
};<p>
<b><hr></b><p>
//codigo, implementacao, para o header file<p>
#include &lt;iostream.h&gt;<p>
#include &lt;stdlib.h&gt;<p>
#include "exvet1.h"<p>
<p>
vetor::vetor (int tam)<p>
{v=new int[tam]; tamanho=tam;}<p>
<p>
void vetor::atribui(int index,int valor)<p>
{<p>
if (index&lt;tamanho &amp;&amp; index&gt;=inicio)<p>
v[index]=valor;<p>
}<p>
<p>
int vetor::conteudo(int index)<p>
{<p>
 if (index&gt;=tamanho || index&lt;inicio) {cerr &lt;&lt; "Fora dos limites";
exit(1);}<p>
 return v[index];<p>
 }<p>
<p>
int vetor::primeiro(void)<p>
{ return inicio;}<p>
<p>
int vetor::ultimo(void)<p>
{ return tamanho-1;}<p>
<p>
int vetor:: maximo(void)<p>
{int candidato=inicio;  //candidato ao maximo<p>
 for (int i=inicio;i&lt;tamanho;i++)<p>
 if (v[i]&gt;v[candidato]) candidato=i;<p>
 return v[candidato];}<p>
<b><hr></b><p>
//programa pricipal<p>
#include &lt;iostream.h&gt;<p>
#include "exvet1.h"<p>
<p>
main()<p>
{<p>
int aux; <p>
//para ler valor a atribuir<p>
vetor meu(5);<p>
<p>
for (int i=meu.primeiro();i&lt;=meu.ultimo();i++)<p>
{<p>
 cout &lt;&lt; "Entre com valor da posicao:" &lt;&lt; i &lt;&lt; "\n";<p>
 cin &gt;&gt; aux;<p>
 meu.atribui(i,aux);<p>
}<p>
for (int j=meu.primeiro();j&lt;=meu.ultimo();j++) cout&lt;&lt;
meu.conteudo(j)&lt;&lt; " ";<p>
cout &lt;&lt;endl &lt;&lt; "Maximo:" &lt;&lt; meu.maximo();<p>
return 0;<p>
}<p>
</CODE><p>
<b><hr></b><p>
<b>Coment&aacute;rios:</b> <p>
	O m&eacute;todo<b> </b><CODE><b></b><p>
<b></b>~vetor() {delete v;}               //use delete []v;depende do
compilador</CODE><p>
&eacute; um destrutor, assim como o construtor ele n&atilde;o tem valor de
retorno porque &eacute; chamado pelo sistema operacional quando o objeto sai de
escopo ou quando voc&ecirc; desaloca mem&oacute;ria de um  ponteiro para o
objeto. A &uacute;nica a&ccedil;&atilde;o do destrutor &eacute; liberar a
mem&oacute;ria ocupada pelo atributo vetor de inteiros<CODE> (int * v)
</CODE>da classe vetor. De um modo geral os destrutores servem para
"arrumar a casa" quando objetos s&atilde;o desalocados  ou saem de escopo. A
sintaxe dos m&eacute;todos para dele&ccedil;&atilde;o de vetores
<CODE>delete v; </CODE> ou <CODE>delete []v; </CODE>
podem variar de compilador para compilador, o usu&aacute;rio deve checar que
sintaxe seu compilador suporta.<p>
	Note que quando n&atilde;o disp&uacute;nhamos do destrutor o programador era
obrigado a deletar passo a passo todas as estruturas din&acirc;micas dos
objetos que saiam de escopo, existem t&eacute;cnicas avan&ccedil;adas para
obter coleta autom&aacute;tica de lixo em C++ baseadas neste ponto.<p>
<p>
<b>Resultado do programa:</b><p>
<b></b>Entre com valor da posicao:0<p>
4<p>
Entre com valor da posicao:1<p>
5<p>
Entre com valor da posicao:2<p>
9<p>
Entre com valor da posicao:3<p>
2<p>
Entre com valor da posicao:4<p>
1<p>
4 5 9 2 1<p>
Maximo:9<p>
<b></b><p>
<b>Dica de programa&ccedil;&atilde;o: </b> <p>
	Saiba que uma pr&aacute;tica bastante &uacute;til na fase de testes de um
programa &eacute; introduzir mensagens informativas em pontos convenientes.
Quando trabalhando com objetos tal pr&aacute;tica pode ser usada de
v&aacute;rios modos, por exemplo pode-se inserir uma mensagem no destrutor de
uma classe para verificar quando os objetos s&atilde;o eliminados e se
s&atilde;o eliminados corretamente.<p>
<p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1) Note que os m&eacute;todos atribui e conte&uacute;do  apresentam
estilos diferentes de lidar com &iacute;ndices fora dos limites do vetor. Um
apresenta uma mensagem de erro e termina o programa. Outro simplesmente
n&atilde;o executa a a&ccedil;&atilde;o se os par&acirc;metros n&atilde;o
estiverem corretos. Escolha um dos estilos e uniformize o programa. Quando
voc&ecirc; estudar "exception handling" 4.5 ver&aacute; maneiras melhores de
lidar com esses problemas.<p>
<p>
2) Implemente uma fun&ccedil;&atilde;o membro chamada ordena para o tipo
abstrato de dados vetor definido acima. Use qualquer algoritmo de
ordena&ccedil;&atilde;o.<p>
<p>
3)Crie destrutores para as classes que voc&ecirc; j&aacute; implementou, mesmo
que elas n&atilde;o tenham atributos que usem aloca&ccedil;&atilde;o
din&acirc;mica. Introduza mensagens tipo <CODE>cout &lt;&lt;
"Goodbye..."; </CODE> nos destrutores destas classes . Como essas
mensagens podem ser &uacute;teis? Defina v&aacute;rios n&iacute;veis de blocos
de c&oacute;digo, fazendo assim com que objetos saiam de escopo em tempos
diferentes e teste seus destrutores.<p>
<p>
4)Melhore o exerc&iacute;cio anterior introduzindo um nome para o objeto. Este
nome deve ir nas sa&iacute;das de tela e &eacute; &#127;  nome dado para o
construtor como uma<CODE> string (char*). </CODE>N&atilde;o
esque&ccedil;a de deletar esta string no destrutor da classe depois de imprimir
a mensagem.<p>
<p>
5)Crie uma fun&ccedil;&atilde;o membro de nome preenche, que inicializa todas
as posi&ccedil;&otilde;es de um vetor com o valor de um de seus argumentos.<p>
<p>
6)Defina um programa chamado grandes que implementa o tipo abstrato de dados
n&uacute;meros grandes e inteiros, este tipo deve usar um vetor do tipo
num&eacute;rico que voc&ecirc; achar conveniente para representar os
algarismos. Talvez estudar circuitos l&oacute;gicos como somadores, etc  o
ajude a implementar as quatro opera&ccedil;&otilde;es matem&aacute;ticas
b&aacute;sicas para estes tipo em termos de "look ahead carrier" e outras
t&eacute;cnicas de performance para implementar as opera&ccedil;&otilde;es.<p>
<p>
7)Note que na aloca&ccedil;&atilde;o do vetor:<p>
<CODE><p>
 vetor::vetor (int tam)<p>
{v=new int[tam]; tamanho=tam;}<p>
</CODE><p>
, n&atilde;o &eacute; checado se o valor passado tam &eacute; maior que 0,
fa&ccedil;a este teste.<p>
<p>
Quando explicarmos "exception handling" voc&ecirc; ter&aacute; m&eacute;todos
melhores de lidar com esses erros.<p>
<b></b>
<h4>
<a name="RTFToC28">1.5.3.7.
<a name="_Toc342736967"><a name="_Toc345838238"><a name="_Toc345942373"><a name="_Toc345949533"><a name="_Toc346168650"><a name="_Toc348417093"><a name="_Toc348931349"><a name="_Toc353900788"><a name="_Toc353946318">
ALOCANDO OBJETOS</a></a></a></a></a></a></a></a></a>
</a></h4>
<p>
	Pula, em Modula-3 j&aacute; s&atilde;o alocados.<p>
	Este exemplo mostra como trabalhar com ponteiros para objetos, new e delete,
como alocar mem&oacute;ria e chamar corretamente os construtores.<p>
		<p>
<b>Coment&aacute;rios: </b><p>
<b>	</b>Perceba que agora n&atilde;o estamos alocando um vetor de inteiros com
tr&ecirc;s posi&ccedil;&otilde;es<CODE> (new int[3]), </CODE> mas
um inteiro que cont&eacute;m o valor 3. Voc&ecirc; pode ler o c&oacute;digo
<CODE> (*a) </CODE>como: "O apontado de a".<p>
	Se a fosse uma<CODE> struct </CODE>ou <CODE>class
</CODE>e tivesse um dado membro chamado dd, poder&iacute;amos obter o
valor de dd atrav&eacute;s de (*a).dd que pode ser todo abreviado em
<CODE>a-&gt;dd </CODE>onde <CODE>-&gt; </CODE>&eacute;
uma seta, ou flecha que voc&ecirc; pode ler como "o apontado" novamente.<p>
	Os par&ecirc;nteses em <CODE> (*a).dd</CODE> s&atilde;o
necess&aacute;rios devido a preced&ecirc;ncia do operador<b> .</b> com
rela&ccedil;&atilde;o ao<CODE> *</CODE>.<p>
<p>
<a name="_Toc342736968"><a name="_Toc345409407"><a name="_Toc345810912"><a name="_Toc345838239"><a name="_Toc345942374"><a name="_Toc345949534"><a name="_Toc346168651"><a name="_Toc348417094"><a name="_Toc348931350"><a name="_Toc353900789"><a name="_Toc353946319">
<h3>
<a name="RTFToC29">1.5.4.
REFER&Ecirc;NCIA &amp;</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
	Aqui vou ensinar passagem por refer&ecirc;ncia, lembre-se que objetos
s&atilde;o passados por refer&ecirc;ncia, porque eles s&atilde;o
refer&ecirc;ncia, ponteiros.<p>
	 Este t&oacute;pico vai explicar como usar o operador<CODE> &amp;,
</CODE>tamb&eacute;m chamado de operador "endere&ccedil;o de...". Este
operador fornece o endere&ccedil;o, a posi&ccedil;&atilde;o na mem&oacute;ria
de uma vari&aacute;vel, de um argumento, etc.  Sua utiliza&ccedil;&atilde;o
&eacute; muito simples, se a &eacute; uma vari&aacute;vel inteira, <CODE>
&amp;a </CODE>retorna um ponteiro para a.<p>
<p>
O programa a seguir ilustra a sintaxe do operador: <CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
<p>
void main()<p>
{<p>
int a; <p>
a=10;<p>
int* p;<p>
p=&amp; a;<p>
(*p)=13;<p>
cout &lt;&lt; a;<p>
}<p>
<b><hr></b><p>
</CODE><p>
<b>Explicando o programa passo a passo:</b><p>
<CODE><p>
int a; <p>
</CODE><p>
Declara uma vari&aacute;vel inteira com nome a.<p>
<CODE><p>
a=10;<p>
</CODE><p>
atribui valor 10 a vari&aacute;vel a.<p>
<CODE><p>
int* p;<p>
</CODE><p>
Declara um ponteiro de vari&aacute;vel inteira , o nome do ponteiro &eacute;
p.<p>
<CODE><p>
 p=&amp; a;<p>
</CODE><p>
Atribui o "endere&ccedil;o de a" , <CODE>"&amp; a" </CODE>ao
ponteiro p. <p>
<CODE><p>
(*p)=13;<p>
</CODE><p>
Atribui 13 ao "apontado de p", "<CODE>(*p) </CODE>", mas como
<CODE>p</CODE> aponta para <CODE>a</CODE>, a passa de
valor 10 para valor treze atrav&eacute;s de <CODE>p</CODE>.
<CODE>P</CODE> &eacute; um "alias" para a.<p>
<CODE><p>
cout &lt;&lt; a;<p>
</CODE><p>
Imprime o valor esperado que &eacute; treze.<p>
<p>
	O programa a seguir usa o operador "endere&ccedil;o de" para modificar
argumentos, par&acirc;metros de uma fun&ccedil;&atilde;o, ou seja utiliza
passagem por refer&ecirc;ncia, equivalente ao VAR de Pascal. Lembre-se que
at&eacute; agora os argumentos das nossas fun&ccedil;&otilde;es s&oacute; eram
passados por valor.<p>
<CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
void incrementa(int&amp; a)<p>
{<p>
a++;<p>
}<p>
//primeira funcao que usa passagem por referencia<p>
<p>
void troca(int&amp; a,int&amp; b)<p>
{<p>
int aux=a;<p>
a=b;<p>
b=aux;<p>
}<p>
//segunda funcao que usa passagem por referencia<p>
<p>
void main()<p>
{<p>
int i1=10;<p>
int i2=20;<p>
incrementa(i1);<p>
cout &lt;&lt; i1 &lt;&lt; endl;<p>
troca(i1,i2);<p>
cout &lt;&lt; i1 &lt;&lt; endl;<p>
}<p>
<b><hr></b><p>
</CODE><p>
<b>Resultado do programa:</b><p>
<b></b>11<p>
20<p>
<p>
<b>Explicando passo a passo:</b><p>
<b>	</b>As fun&ccedil;&otilde;es criadas no programa, s&atilde;o como dissemos,
capazes de alterar seus par&acirc;metros, <CODE>incrementa </CODE>,
incrementa seu &uacute;nico par&acirc;metro e <CODE>troca</CODE>,
troca os dois par&acirc;metros inteiros.<p>
<a name="_Toc342736969"><a name="_Toc345409408"><a name="_Toc345810913"><a name="_Toc345838240"><a name="_Toc345942375"><a name="_Toc345949535"><a name="_Toc346168652"><a name="_Toc348417095"><a name="_Toc348931351"><a name="_Toc353900790"><a name="_Toc353946320">
<h2>
<a name="RTFToC30">1.6.
RECAPITULANDO</a></a></a></a></a></a></a></a></a></a></a>
</a></h2>
<b>	</b><p>
<b>	</b>Neste t&oacute;pico apresentaremos programas que revisam todos
conceitos j&aacute; vistos e acrescentam mais alguns detalhes da
linguagem.<b></b><p>
<b>
<a name="_Toc342736970"><a name="_Toc345409409"><a name="_Toc345810914"><a name="_Toc345838241"><a name="_Toc345942376"><a name="_Toc345949536"><a name="_Toc346168653"><a name="_Toc348417096"><a name="_Toc348931352"><a name="_Toc353900791"><a name="_Toc353946321"></b>
<h3>
<a name="RTFToC31">1.6.1.
ARGUMENTOS DE LINHA DE COMANDO.</a></a></a></a></a></a></a></a></a></a></a> 
</a></h3>
<b></b><p>
<b></b><p>
<b>	</b>Neste t&oacute;pico vamos apresentar um exemplo que usa tudo o que foi
aprendido at&eacute; agora e introduz mais alguns outros conceitos.<b> </b>Este
exemplo &eacute; um jogo de quebra cabe&ccedil;a. Provavelmente voc&ecirc;
j&aacute; viu um quebra cabe&ccedil;a deste tipo, ele &eacute; chamado quebra
cabe&ccedil;a de tijolos deslizantes. &Eacute; composto de um tabuleiro
(matriz) quadrado preenchido com pe&ccedil;as de 0 at&eacute; (lado^2-1) onde
lado &eacute; a dimens&atilde;o de um lado do tabuleiro. A
representa&ccedil;&atilde;o no programa &eacute; num&eacute;rica, mas
normalmente esses quebra cabe&ccedil;as s&atilde;o vendidos com desenhos
pintados sobre as pecas. No lugar onde deveria estar a &uacute;ltima
pe&ccedil;a  deixa-se um espa&ccedil;o vazio para que se possa mover  as
pe&ccedil;as do tabuleiro. O objetivo &eacute; colocar todos os tijolos em
ordem, como no esquema  abaixo:<p>
<p>
<p>
<p>
<CENTER><IMG SRC="jogo.gif" ></CENTER>
Solucionado!
<p>
<b>	</b><p>
<b>	</b>O que um quebra cabe&ccedil;a tem a ver com encapsulamento? Simples o
jogador &eacute; obrigado a seguir as regras do jogo, portanto n&atilde;o pode
conhecer todas as opera&ccedil;&otilde;es que se aplicam ao quebra
cabe&ccedil;a, e tamb&eacute;m n&atilde;o pode acessar sua
representa&ccedil;&atilde;o interna. Vamos ver como isso &eacute; feito usando
as palavras reservadas <CODE>private e public </CODE>, conceitos de
agrega&ccedil;&atilde;o e reuso de c&oacute;digo de uma classe matriz.<b>
</b>Al&eacute;m disso usamos const para garantir a integridade da matriz do
quebra-cabe&ccedil;a.<p>
<b></b><p>
<b>	</b>Veja tamb&eacute;m que  estamos abordando o t&oacute;pico
representa&ccedil;&atilde;o, n&atilde;o raro voc&ecirc; ter&aacute; que modelar
objetos que representem algo do mundo real como motor, quebra-cabe&ccedil;a,
conta banc&aacute;ria, circuito el&eacute;trico e assim por diante. Outros
objetos podem ser mais abstratos, exemplo: &aacute;rvore
bin&aacute;ria.<b></b><p>
<b></b>	<p>
<b>Mais sobre as regras:</b><p>
<b>	</b>Voc&ecirc; concorda que dada uma situa&ccedil;&atilde;o onde o
espa&ccedil;o vazio se encontra no meio do quebra-cabe&ccedil;a dado como
exemplo o usu&aacute;rio s&oacute; tem 4 op&ccedil;&otilde;es? S&atilde;o elas:
mover para cima (fun&ccedil;&atilde;o membro
<CODE>movecima</CODE>), mover para baixo , mover para a esquerda ou
ent&atilde;o para a direita. Note que essas fun&ccedil;&otilde;es membro
s&oacute; trocam pe&ccedil;as vizinhas, isso &eacute; importante pois &eacute;
provado matematicamente que algumas trocas de pe&ccedil;as distantes  ("Odd
permutations") podem tornar o quebra-cabe&ccedil;a insol&uacute;vel. Isto
&eacute; facil de ser verificado para um quebra cabe&ccedil;a 2x2.<b></b><p>
<b></b>	Garantimos a solu&ccedil;&atilde;o do quebra-cabe&ccedil;a  pelo
caminho inverso do embaralhamento das pe&ccedil;as, que parte do
quebra-cabe&ccedil;a solucionado e aplica aleatoriamente sequ&ecirc;ncias de
movimentos iguais aos que o usu&aacute;rio usa para solucionar o jogo.<b></b><p>
<b>	</b>A matriz bidimensional &eacute; representada linearmente (vetor) e as
fun&ccedil;&otilde;es membro de convers&atilde;o de &iacute;ndice linear para
colunas e/ou linhas e atribui&ccedil;&otilde;es s&atilde;o fornecidas, mas
somente as necess&aacute;rias para o jogo .<p>
<p>
<b>Recursos utilizados:</b><p>
<b>	</b>Argumentos de linha de comando, fun&ccedil;&otilde;es de
convers&atilde;o da<CODE> stdlib, </CODE>
representa&ccedil;&atilde;o linear de uma matriz, <CODE>const.
</CODE><b></b><p>
<b></b><p>
<b>Argumentos de linha de comando:</b><p>
<b></b>	Voc&ecirc; pode fazer programas que aceitem argumentos de linha de
comandos, resultando em algo equivalente a: <CODE><p>
dir /w   //dos<p>
format A: //dos<p>
ou ls -la   //unix<p>
</CODE><b></b><p>
<b></b>	Esses argumentos podem ficar dispon&iacute;veis na chamada da
fun&ccedil;&atilde;o main de seu programa como os par&acirc;metros "argument
counter" e "argument values", veja  trecho de programa abaixo.<p>
<CODE>void main(int argc, char *argv[]) {.../*use argv e argc*/ ...}
</CODE><p>
<b></b><p>
<b></b><CODE>argc<b> </b></CODE>&eacute; um inteiro<p>
<CODE>argv</CODE><b> </b>&eacute; um vetor de<b>
</b><CODE>char* </CODE>contendo os argumentos passados. (/w
...)<b></b><p>
<b></b><CODE>argv [0]<b> </b></CODE>&eacute; o nome do programa
chamado.<b></b><p>
<b></b>A faixa &uacute;til de argvalues &eacute; :
<CODE>argv[1]...argv[argc-1] </CODE><p>
<p>
Portanto se <CODE>argc==2</CODE>, temos um &uacute;nico argumento
de linha de comando, dispon&iacute;vel como string em <CODE>argv[1]
</CODE>. Fa&ccedil;a alguns testes com o mesma main usada no programa
abaixo e alguns <CODE>cout's</CODE> imprimindo os argumentos para
entender melhor o assunto.<p>
<p>
<b>Const: </b><p>
<b>	</b>J&aacute; exemplificado em 1.5.1<p>
<b></b><p>
<b>Representa&ccedil;&atilde;o linear de uma matriz: </b><p>
<CENTER><IMG SRC="matrixqc.gif" ></CENTER>
<b>	</b>Pode-se representar uma matriz de qualquer dimens&atilde;o em um vetor.
Veja o exemplo de uma matriz bidimensional de inteiros mostrada no formato
indicelinear:valor armazenado<p>
<p>
<p>
<b></b><p>
<b>	</b>Vantagem da representa&ccedil;&atilde;o linear (vetor): para
referenciar uma posi&ccedil;&atilde;o gasta-se somente um inteiro contra dois
da representa&ccedil;&atilde;o matriz (linha,coluna). Podemos agora considerar
posi&ccedil;&otilde;es que apontam para outras posi&ccedil;&otilde;es, basta
interpretar o conte&uacute;do do vetor como um &iacute;ndice linear.<b></b><p>
<b>	</b>Desvantagem da representa&ccedil;&atilde;o linear (vetor): &eacute;
necess&aacute;rio criar fun&ccedil;&otilde;es de  convers&atilde;o de
&iacute;ndice na forma (linha,coluna) para (&iacute;ndice linear) e de
(&iacute;ndice linear)  para (coluna) ou (linha). Veja as fun&ccedil;&otilde;es
<CODE>lin </CODE>e <CODE>col </CODE>e<CODE>
linear </CODE>do exemplo seguinte.<p>
<p>
<b>Fun&ccedil;&otilde;es de convers&atilde;o da Stdlib:</b><p>
<b>	</b>A fun&ccedil;&atilde;o<CODE> int atoi(char* a)
</CODE>converte uma string para um inteiro.<p>
<CODE><p>
<b><hr></b><p>
<b></b>#include &lt;stdlib.h&gt;<p>
<p>
class matriz  //quebra cabeca de tijolos deslizantes<p>
{<p>
private:<p>
int linhas;    //numero de linhas da matriz<p>
int colunas;  //numero de colunas na matriz<p>
int tam;     //=linhas*colunas<p>
int *lc;    //vetor de tamanho linha*colunas representando matriz:0..(tam-1)<p>
public:<p>
matriz(const int l,const int c); //cria matriz LxC<p>
<p>
//qualquer uma das funcoes abaixo retorna nil se nao conseguiu<p>
int* linear(const int lin,const int col)const ; //ind linear a partir de linha
e coluna<p>
int* col(const int indlin)const ;//coluna a partir do indice linear<p>
int* lin(const int indlin)const ; //linha a partir do indice linear<p>
<p>
int trocaindlin(const int i,const int j); //argumentos: 2 indices lineares<p>
//retorna 1 conseguiu, 0 nao conseguiu<p>
<p>
int atribuiindlin(const int i,const int v); //atribui v ao indice i<p>
//retorna 1 conseguiu, 0 nao conseguiu<p>
<p>
int* retornaindlin(const int i);  //retorna conteudo do indice i<p>
//retorna nil se nao conseguiu<p>
<p>
int getl(void);    //retorna numero de linhas<p>
int getc(void);   //retorna numero de colunas<p>
int gett(void); //retorna tamanho = linhas*colunas<p>
<p>
~matriz();<p>
};<b></b><p>
<b><hr></b><p>
<b></b>#include "matriz.h"<p>
<p>
matriz::matriz(const int l,const int c) //cria matriz<p>
{<p>
  lc=new int[l*c];  //l,c dimensoes ; lc vetor[l*c]<p>
  linhas=l;<p>
  colunas=c;<p>
  tam=linhas*colunas;<p>
}<p>
<p>
int* matriz::linear(const int alin,const int acol) const<p>
//ind linear a partir de linha e coluna<p>
{<p>
int* result=new int;  //valor de retorno<p>
if ( (0&lt;alin) &amp;&amp; (alin&lt;=linhas) &amp;&amp; (0&lt;acol) &amp;&amp;
(acol&lt;=colunas) )<p>
 {<p>
  (*result)=(alin-1)*colunas+acol;<p>
  return result;<p>
 }<p>
else<p>
 return NULL;<p>
}<p>
<p>
int* matriz::col(const int indlin)const //coluna a partir do indice linear<p>
{<p>
int* result=new int;<p>
if ( (0&lt;indlin) &amp;&amp; (indlin&lt;=tam) )<p>
 {<p>
  (*result)=(indlin % colunas);<p>
  if ((*result)==0) (*result)=colunas;<p>
  return result;<p>
 }<p>
else<p>
 return NULL;<p>
}<p>
<p>
int* matriz::lin(const int indlin)const  //linha a partir do indice linear<p>
{<p>
int* result=new int;<p>
if ( (0&lt;indlin) &amp;&amp; (indlin&lt;=tam) )<p>
 {<p>
  (*result)=(int((indlin-1) / colunas)+1);<p>
  return result;<p>
 }<p>
else<p>
 return NULL;<p>
}<p>
<p>
int matriz::trocaindlin(const int i,const int j) //argumentos: 2 indices
lineares<p>
//retorna 1 conseguiu, 0 nao conseguiu<p>
{<p>
int aux;<p>
if ( (0&lt;i) &amp;&amp; (i&lt;=tam) &amp;&amp; (0&lt;j) &amp;&amp; (j&lt;=tam)
)<p>
{ aux=lc[i-1];   //efetua a troca<p>
  lc[i-1]=lc[j-1]; //embora para usuario a matriz vai de 1 ate l*c<p>
						//para mim vai de o ate l*c-1<p>
  lc[j-1]=aux;<p>
  return 1; //sucesso<p>
}<p>
else return 0; //falhou<p>
}<p>
<p>
int matriz::atribuiindlin(const int i,const int v)<p>
//retorna 1 conseguiu, 0 nao conseguiu<p>
{<p>
if ( (0&lt;i) &amp;&amp; (i&lt;=tam) )<p>
 {<p>
  lc[i-1]=v;   //efetua a atribuicao<p>
  return 1;<p>
 }<p>
else return 0; //falhou<p>
}<p>
<p>
<p>
int* matriz::retornaindlin(const int indlin)<p>
//retorna nil se nao conseguiu<p>
{<p>
int* result=new int;<p>
if ( (0&lt;indlin) &amp;&amp; (indlin&lt;=tam) )<p>
 {<p>
 *result=lc[indlin-1];<p>
 return result;<p>
 }<p>
else<p>
 return NULL;<p>
}<p>
<p>
int matriz::getl(void)    //retorna numero de linhas<p>
{<p>
return linhas;<p>
}<p>
<p>
int matriz::getc(void)   //retorna numero de colunas<p>
{<p>
return colunas;<p>
}<p>
<p>
int matriz::gett(void)   //retorna tamanho<p>
{<p>
return tam;<p>
}<p>
<p>
matriz::~matriz()<p>
{<p>
delete lc;<p>
}<b></b><p>
<b><hr></b><p>
<b></b>//quebra cabecas de tijolos deslizantes<p>
#include &lt;iostream.h&gt;   //para cin cout<p>
#include &lt;iomanip.h&gt;   //formatar cout output com &gt;&gt; setwidth()<p>
#include &lt;stdlib.h&gt;   //uso rand() em embaralha<p>
#include &lt;string.h&gt;  //atoi() para converter argumentos de linha de
comando<p>
#include "matriz.h"<p>
<p>
const int min_lado=2; //minimo tamanho lateral do quebracab.<p>
const int tam_padrao=5; //tamanho padrao<p>
<p>
class quebracab  //quebra cabeca de tijolos deslizantes<p>
{<p>
private:<p>
<p>
int vazio;   //indice linear da casa vazia<p>
int mov;   //numero de movimentos<p>
matriz* mqc;  //matriz interna do quebra cabecas<p>
<p>
public:<p>
<p>
quebracab(const int ld=tam_padrao); //cria quebra cabeca, ld=lado<p>
void mostra() const;       //mostra quebra cabeca<p>
<p>
void movedir(); //move celula a esq de vazio  para direita.<p>
void moveesq(); //analogo<p>
void movebaixo(); //analogo<p>
void movecima(); //analogo<p>
<p>
void embaralha();  //embaralha quebracabeca<p>
int tstsolucao() const; //testa se quebracabeca esta solucionado<p>
int retorna_mov() { return mov; } //retorna numero de movimentos<p>
<p>
~quebracab();  //destroi quebra cabecas<p>
};<p>
<p>
quebracab::quebracab(const int ld) //argumento padrao desnessario, ja
declarado<p>
{<p>
   int ldc=abs(ld);  //ld copia = valor positivo de ld<p>
	if (ldc&lt;min_lado) ldc=min_lado;<p>
	mqc=new matriz(ldc,ldc); //inicializa objeto matriz<p>
	for(int i=1;i&lt;mqc-&gt;gett();i++)<p>
	mqc-&gt;atribuiindlin(i,i);           //initializa casas da matriz<p>
	mqc-&gt;atribuiindlin(mqc-&gt;gett(),0);//atribui zero a posicao da celula
vazia<p>
	vazio=mqc-&gt;gett();               //define posicao da celula vazia<p>
	mov=0;                          //sem nenhum movimento<p>
	embaralha();                   //embaralha quebracabeca<p>
}<p>
<p>
void quebracab::mostra() const       //mostra quebra cabeca<p>
{<p>
 int i,j;   //linha e coluna<p>
 int* ind;  //valor atual<p>
 for(i=1;i&lt;=mqc-&gt;getl();i++)   			 //loop das linhas<p>
 { //linhas<p>
	for(j=1;j&lt;=mqc-&gt;getc();j++) 			//loop das colunas<p>
	{  //colunas<p>
	  ind=mqc-&gt;linear(i,j);  				//resultado tambem e ponteiro<p>
	 if<p>
	  ((*ind)==vazio) cout &lt;&lt; setw(4)&lt;&lt;" "; //vazio=espaco<p>
	 else<p>
	  cout &lt;&lt; setw(4) &lt;&lt; (*mqc-&gt;retornaindlin(*ind)); //nao e o
vazio, mostra conteudo<p>
	} //colunas<p>
	cout &lt;&lt; endl; //mudanca de linha<p>
 } //linhas<p>
 cout &lt;&lt; endl;<p>
}<p>
<p>
void quebracab::movedir() //move celula a esq de vazio  para direita<p>
									//espaco move para esquerda<p>
{<p>
if ( (*(mqc-&gt;col(vazio))) !=1) /*nao esta na borda esquerda*/<p>
 {<p>
 mqc-&gt;trocaindlin(vazio,vazio-1);<p>
 mov++;<p>
 vazio=vazio-1;<p>
 }<p>
}<p>
<p>
void quebracab::moveesq() //espaco move para direita<p>
{<p>
if (  (*(mqc-&gt;col(vazio)))!=mqc-&gt;getc()  ) /*nao esta na borda
direita*/<p>
 {<p>
 mqc-&gt;trocaindlin(vazio,vazio+1);<p>
 mov++;<p>
 vazio=vazio+1;<p>
 }<p>
}<p>
<p>
void quebracab::movebaixo()  //espaco move para cima<p>
{<p>
if ((*(mqc-&gt;lin(vazio)))!=1) /*nao esta no topo*/<p>
 {<p>
 mqc-&gt;trocaindlin(vazio,vazio-(mqc-&gt;getc()));  //chama funcao private<p>
 mov++;<p>
 vazio=vazio-(mqc-&gt;getc());<p>
 }<p>
}<p>
<p>
void quebracab::movecima()  //espaco move para baixo<p>
{<p>
if ((*mqc-&gt;lin(vazio))!=mqc-&gt;getl()) /*nao esta em baixo*/<p>
 {<p>
 mqc-&gt;trocaindlin(vazio,vazio+(mqc-&gt;getc()));<p>
 mov++;<p>
 vazio=vazio+(mqc-&gt;getc());<p>
 }<p>
}<p>
<p>
void quebracab::embaralha()  //embaralha quebracabeca<p>
{<p>
 int i,j; //loop principal, loop secundario<p>
 int r;  //r times<p>
 for(j=0;j&lt;mqc-&gt;gett();j++)<p>
 {<p>
 r=(rand()% mqc-&gt;getc());<p>
 for(i=0;i&lt;r;i++) {this-&gt;movedir();} //move r vezes<p>
 r=(rand()% mqc-&gt;getl());<p>
 for(i=0;i&lt;r;i++) {this-&gt;movebaixo();}<p>
 r=(rand()% mqc-&gt;getc());<p>
 for(i=0;i&lt;r;i++) {this-&gt;moveesq();}<p>
 r=(rand()% mqc-&gt;getl());<p>
 for(i=0;i&lt;r;i++) {this-&gt;movecima();}<p>
 }<p>
 mov=0; //inicializa movimentos<p>
}<p>
<p>
int quebracab::tstsolucao() const    //testa se quebracabeca esta solucionado<p>
{<p>
 int i=1,cont=1;<p>
 while(     cont &amp;&amp; (i&lt; (mqc-&gt;gett()) )     )<p>
 {<p>
  if ((*(mqc-&gt;retornaindlin(i)))==(i)) cont=1; else cont=0;<p>
  i++;<p>
 }<p>
 return (cont); //i=qctam esta solucionado 1 2 3... 24 0<p>
}<p>
<p>
quebracab::~quebracab()<p>
 {if (mqc!=NULL) delete mqc; cout &lt;&lt; " Quebra cabeca destruido!\n";}
//destroi quebracab<p>
<p>
<p>
<p>
<p>
<p>
main(int argc,char *argv[])  //argumentos sao declarados aqui<p>
{ //main<p>
int ladocomp;<p>
char opcao; //usada em menu como variavel de opcao<p>
<p>
if (argc&gt;1) ladocomp=atoi(argv[1]);<p>
//convertendo argumento de linha de comando para inteiro<p>
else ladocomp=tam_padrao;  //valor default<p>
<p>
quebracab aquebracab(ladocomp);  //criando quebracab<p>
do {<p>
 aquebracab.mostra();<p>
 cout &lt;&lt;"\n";   //menu de opcoes<p>
 cout &lt;&lt;" Movimentos:" &lt;&lt; aquebracab.retorna_mov()&lt;&lt; "\n";<p>
 cout &lt;&lt;" 4&lt;-   6-&gt;   8Cima   2Baixo   SSair   Eembaralha  \n";<p>
 cout &lt;&lt;" Reconhece sequencias de comandos: 268624 &lt;Enter&gt;\n";<p>
 cout &lt;&lt;" Aceita argumento de linha de comando: quebracab 4 (cria
quebracabeca 4 x 4)\n";<p>
 cout &lt;&lt;" Entre comando:";<p>
 cin &gt;&gt; opcao; //le opcao do usuario<p>
 cout &lt;&lt;"\n";<p>
 switch(opcao) //executa opcao do usuario<p>
 {<p>
  case 'E':<p>
  case 'e':<p>
				aquebracab.embaralha();<p>
				break;<p>
  case '8': aquebracab.movecima();<p>
				break;<p>
  case '2': aquebracab.movebaixo();<p>
				break;<p>
  case '4': aquebracab.moveesq();<p>
				break;<p>
  case '6': aquebracab.movedir();<p>
				break;<p>
  default:  ;<p>
 }  //fim do bloco de codigo do switch-case<p>
 if (aquebracab.tstsolucao()) opcao='s'; //sai do loop de menu<p>
} while ((opcao!='S') &amp;&amp; (opcao!='s')); //loop menu<p>
<p>
if (aquebracab.tstsolucao()) {aquebracab.mostra(); cout &lt;&lt; "
Parabens!\n";}<p>
else  cout &lt;&lt; " Quebra cabeca nao solucionado. Tente novamente!\n";<p>
return 0;<p>
}  //bloco de codigo principal<p>
</CODE><p>
<b><hr></b><p>
<b>Coment&aacute;rios: </b><p>
<b>	</b><CODE>delete []qc; </CODE>Este destrutor adota uma
t&eacute;cnica diferente para dele&ccedil;&atilde;o de vetores, cheque que
t&eacute;cnicas seu compilador suporta.<p>
<b></b><p>
<b>Exerc&iacute;cios</b><b>:	</b><p>
<b></b>1) Se voc&ecirc; implementou o jogo de quebra-cabe&ccedil;a
notar&aacute; que n&atilde;o existe apagamento da tela, somente "scroll". Isto
torna o jogo um pouco cansativo porque d&aacute; para ver o quebra
cabe&ccedil;a sendo empurrado para o alto da tela e a nova
representa&ccedil;&atilde;o sendo criada na parte de baixo do "display". A
raz&atilde;o de tal escolha &eacute; simples: a fun&ccedil;&atilde;o de
apagamento de tela do DOS n&atilde;o &eacute; port&aacute;vel para o UNIX e
vice versa. Descubra a fun&ccedil;&atilde;o de CLS (Clear Screen) do seu
ambiente de programa&ccedil;&atilde;o e use-a no programa. Numa segunda etapa
introduza cores no programa, voc&ecirc; pode usar a fun&ccedil;&atilde;o
m&oacute;dulo (n&uacute;mero da pe&ccedil;a ,n&uacute;mero de cores) para
determinar a cor de uma pe&ccedil;a.<p>
<p>
2) Implemente outros jogos simples. Pense em jogos compat&iacute;veis com a sua
experi&ecirc;ncia. Aqui v&atilde;o algumas sugest&otilde;es:<p>
<b></b><p>
<b></b>	Senha: Jogo bastante conhecido, o programa cria um c&oacute;digo de n
d&iacute;gitos e m s&iacute;mbolos. Atrav&eacute;s de chutes o jogador tenta
acertar o c&oacute;digo na seq&uuml;&ecirc;ncia. A cada chute o programa da
dicas dos acertos sendo elas de dois tipos: Acertou o s&iacute;mbolo X vezes ou
acertou o s&iacute;mbolo e a posi&ccedil;&atilde;o Y vezes. Voc&ecirc;
ter&aacute; que usar uma fun&ccedil;&atilde;o para obter n&uacute;meros
aleat&oacute;rios, provavelmente rand da "library"
<CODE>&lt;math.h&gt;.</CODE><b></b><p>
<b></b>	Jogo da velha.<p>
	 Se voc&ecirc; n&atilde;o conhece os jogos procure obter mais
informa&ccedil;&otilde;es antes de come&ccedil;ar a implementa-los.<p>
<b></b><p>
<b></b>5)Melhore a classe matriz para aceitar nas suas fun&ccedil;&otilde;es
argumentos do tipo (linha,coluna) e n&atilde;o s&oacute; &iacute;ndices
lineares.<p>
<b></b><p>
<b></b>4) Construa um programa simples que recebe argumentos da linha de
comando e os imprime atrav&eacute;s de <CODE>cout. </CODE>
Normalmente &eacute; isso que deve ser feito antes de usar um recurso da
linguagem pela primeira vez, experimenta-lo em programas simples.
<a name="_Toc342736971"><a name="_Toc345409410"><a name="_Toc345810915"><a name="_Toc345838242"><a name="_Toc345942377"><a name="_Toc345949537"><a name="_Toc346168654"><a name="_Toc348417097"><a name="_Toc348931353"><a name="_Toc353900792"><a name="_Toc353946322">
<h1>
<a name="RTFToC32">2.
HERAN&Ccedil;A</a></a></a></a></a></a></a></a></a></a></a>
</a></h1>
<a name="_Ref342218812"><a name="_Toc342736972"><a name="_Toc345409411"><a name="_Toc345810916"><a name="_Toc345838243"><a name="_Toc345942378"><a name="_Toc345949538"><a name="_Toc346168655"><a name="_Toc348417098"><a name="_Toc348931354"><a name="_Toc353900793"><a name="_Toc353946323">
<h2>
<a name="RTFToC33">2.1.
HIERARQUIAS DE TIPOS</a></a></a></a></a></a></a></a></a></a></a></a> 
</a></h2>
<p>
	Neste t&oacute;pico mostraremos como construir hierarquias de tipo por
generaliza&ccedil;&atilde;o / especializa&ccedil;&atilde;o.
<a name="_Toc342736973"><a name="_Toc345409412"><a name="_Toc345810917"><a name="_Toc345838244"><a name="_Toc345942379"><a name="_Toc345949539"><a name="_Toc346168656"><a name="_Toc348417099"><a name="_Toc348931355"><a name="_Toc353900794"><a name="_Toc353946324">
<h3>
<a name="RTFToC34">2.1.1.
UMA HIERARQUIA SIMPLES.</a></a></a></a></a></a></a></a></a></a></a> 
</a></h3>
<b></b><p>
<b>	</b>Construiremos uma hierarquia de tipos simples para demonstrar
heran&ccedil;a p&uacute;blica em C++.<p>
<p>
<b></b><p>
<b>Coment&aacute;rios: </b><p>
<CENTER><IMG SRC="casehera.gif" ></CENTER>


<b></b>	O diagrama acima representa a hierarquia de classes implementada e foi
obtido a partir da janela de edi&ccedil;&atilde;o de uma ferramenta case para
programa&ccedil;&atilde;o orientada a objetos.<p>
	A classe<CODE> ponto </CODE>que est&aacute; no topo da hierarquia
&eacute; chamada de classe base, enquanto que as classes
<CODE>ponto_reflete</CODE> e<CODE> ponto_move</CODE>
s&atilde;o chamadas classes filhas ou herdeiras.<b> </b>As classes da
hierarquia s&atilde;o simples, <CODE> ponto_move </CODE>apresenta a
fun&ccedil;&atilde;o membro <CODE>move</CODE>, j&aacute; vista
neste tutorial em 1.2.6, <CODE>ponto_reflete </CODE>apresenta a
fun&ccedil;&atilde;o membro <CODE> (reflete) </CODE>que inverte o
sinal das coordenadas.  <p>
	Dada a simplicidade das classes o leitor poderia se perguntar, porque
n&atilde;o juntar<p>
as tr&ecirc;s  em uma s&oacute; . A pergunta faz sentido, mas  e se
quis&eacute;ssemos criar uma classe ponto que n&atilde;o se movesse, apenas
refletisse e outra que s&oacute; se movesse? E se quis&eacute;ssemos projetar
nosso programa segundo uma hierarquia de especializa&ccedil;&atilde;o /
generaliza&ccedil;&atilde;o da classe ponto? O exemplo mostra como
faz&ecirc;-lo.<p>
<p>
<b>Heran&ccedil;a P&uacute;blica:</b><p>
<b> 	</b>Na heran&ccedil;a p&uacute;blica as classes filhas passam a ter as
mesmas fun&ccedil;&otilde;es membro<CODE> public </CODE>da classe
pai, as classes filhas podem acrescentar fun&ccedil;&otilde;es membro, dados
membro e at&eacute; redefinir fun&ccedil;&otilde;es membro herdadas (veremos
mais tarde). Os atributos da classe pai n&atilde;o s&atilde;o acess&iacute;veis
diretamente na classe filha a n&atilde;o ser que sejam qualificados como
<CODE>protected, </CODE> veja 2.1.2. Por isso &eacute; que se diz
que as classes filhas garantem pelo menos o comportamento "behaviour" da classe
pai, podendo acrescentar mais caracter&iacute;sticas.<p>

     Diagrama de acesso, visibilidade, de                                                     
dados membro e fun&ccedil;&otilde;es  membro de uma classe                                                  
pai  para uma classe filha ou herdeira  por                                                   
heran&ccedil;a p&uacute;blica:            
<CENTER><IMG SRC="pvpxpv.gif" ></CENTER>

                                                                  

<p>
<b>Construtores e heran&ccedil;a:</b><p>
<b>	</b>No construtor de uma classe filha o programador pode incluir a chamada
do construtor da classe pai.<p>
<b></b><p>
<b>Destrutores e heran&ccedil;a: </b><p>
<b>	</b>Quando um objeto da classe derivada &eacute; destru&iacute;do, o
destrutor da classe pai tamb&eacute;m &eacute; chamado dando a oportunidade de
liberar a mem&oacute;ria ocupada pelos atributos <CODE>private
</CODE>da classe pai.<p>
<CODE><p>
<b><hr></b><p>
<b></b>//header file<p>
class ponto<p>
{<p>
private:<p>
float x;   //sao ocultos por default<p>
float y;   //sao ocultos por default<p>
public:  //daqui em diante tudo e acessivel.<p>
ponto(float a,float b);<p>
void inicializa(float a,float b);<p>
float retorna_x(void);<p>
float retorna_y(void);<p>
void altera_x(float a);<p>
void altera_y(float b);<p>
void mostra(void);<p>
};<p>
<p>
class ponto_reflete:public ponto   //classe filha<p>
{<p>
private: //se voce quer adicionar atributos...<p>
public:<p>
ponto_reflete(float a, float b);<p>
void reflete(void); <p>
};<p>
<p>
class ponto_move:public ponto<p>
{<p>
public:<p>
ponto_move(float a,float b);<p>
void move(float dx,float dy);<p>
};<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//implementation file<p>
#include &lt;iostream.h&gt;<p>
#include "pontos.h"<p>
<p>
ponto::ponto(float a,float b)<p>
{<p>
 inicializa(a,b);<p>
}<p>
<p>
void ponto::inicializa(float a,float b)<p>
{<p>
 x=a;<p>
 y=b;<p>
}<p>
<p>
float ponto::retorna_x(void)<p>
{ return x; }<p>
<p>
float ponto::retorna_y(void)<p>
{ return y; }<p>
<p>
void ponto::altera_x(float a)<p>
{ x=a; }<p>
<p>
void ponto::altera_y(float b)<p>
{ y=b; }<p>
<p>
void ponto::mostra(void)<p>
{<p>
cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")"
&lt;&lt;endl;<p>
}<p>
<p>
ponto_reflete::ponto_reflete(float a,float b):ponto(a,b)<p>
{ }<p>
<p>
void ponto_reflete::reflete(void)<p>
{<p>
 altera_x(-retorna_x());<p>
 altera_y(-retorna_y());<p>
}<p>
<p>
ponto_move::ponto_move(float a,float b):ponto(a,b)<p>
{ }<p>
<p>
void ponto_move::move(float dx,float dy)<p>
{<p>
 altera_x(retorna_x()+dx);<p>
 altera_y(retorna_y()+dy);<p>
}<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>#include &lt;iostream.h&gt;<p>
#include "pontos.h"<p>
<p>
void main()<p>
{<p>
 ponto_reflete p1(3.14,2.17);<p>
 p1.reflete();<p>
 cout &lt;&lt; "P1";<p>
 p1.mostra();<p>
<p>
 ponto_move p2(1.0,1.0);<p>
 p2.move(.5,.5);<p>
 cout &lt;&lt; "P2";<p>
 p2.mostra();<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Resultado do programa:</b><p>
<b></b>P1(-3.14,-2.17)<p>
P2(1.5,1.5)<p>
<b></b><p>
<b>Heran&ccedil;a Private:</b><p>
<b>	</b>Ainda n&atilde;o foi inserido no tutorial nenhum exemplo com este tipo
de heran&ccedil;a, mas o leitor pode experimentar mais tarde especificar uma
classe herdeira por heranca private como: <CODE>class herdeira: private
nome_classe_base; </CODE> , e notar&aacute; que as fun&ccedil;&otilde;es
membro desta classe base s&oacute; s&atilde;o acess&iacute;veis dentro das
declara&ccedil;&otilde;es da classe filha, ou seja a classe filha n&atilde;o
atende por essas fun&ccedil;&otilde;es membro, mas pode us&aacute;-las em seu
c&oacute;digo.<p>
	Heran&ccedil;a<CODE> private </CODE>&eacute; um recurso que
voc&ecirc; precisa tomar cuidado quando usar. Normalmente, quando usamos
heran&ccedil;a dizemos que a classe filha garante no m&iacute;nimo o
comportamento da classe pai (em termos de fun&ccedil;&otilde;es membro) , a
heran&ccedil;a<CODE> private </CODE>pode invalidar esta premissa.
<p>
	Muitos programadores usam heran&ccedil;a<CODE> private
</CODE>quando ficaria mais elegante, acad&ecirc;mico, trabalhar com
agrega&ccedil;&atilde;o. Uma classe pilha pode ser constru&iacute;da a partir
de uma classe que implementa uma lista ligada por agrega&ccedil;&atilde;o ou
por heran&ccedil;a<CODE> private. </CODE>Na agrega&ccedil;&atilde;o
(a escolhida em <i>hierarquias de implementa&ccedil;&atilde;o</i>) a classe
pilha possui um dado membro que &eacute; uma lista ligada.<p>
<b></b>
<h3>
<a name="RTFToC35">2.1.2.
<a name="_Ref342314630"><a name="_Toc342736974"><a name="_Toc345409413"><a name="_Toc345810918"><a name="_Toc345838245"><a name="_Toc345942380"><a name="_Toc345949540"><a name="_Toc346168657"><a name="_Toc348417100"><a name="_Toc348931356"><a name="_Toc353900795"><a name="_Toc353946325">
PROTECTED</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>Igual ao exemplo um, mas agora tornando os atributos da classe pai
acess&iacute;veis para as classes filhas atrav&eacute;s do uso de<CODE>
protected.  Protected </CODE>deixa os atributos da classe pai
vis&iacute;veis, acess&iacute;veis "hierarquia abaixo".<p>
<b>	</b>Diagramas de acesso, visibilidade, de dados membro e
fun&ccedil;&otilde;es membro de uma classe pai para uma classe filha ou
herdeira:<b></b><p>
<b></b>

<pre>
           Para uma classe filha por heran&ccedil;a                         <IMG SRC="pvpxpv.gif">                        
p&uacute;blica:                                                                                      

</pre>
<b></b>

<pre>
           Visibilidade da classe herdeira                           <IMG SRC="pvpxpx.gif">                        
para o restante do programa:                                                                  

</pre>
<CODE><p>
<b><hr></b><p>
<b></b>//header file<p>
class ponto<p>
{<p>
protected:   <p>
//*****aqui  esta a diferenca ******<p>
float x;   <p>
//visiveis hierarquia abaixo<p>
float y;   <p>
//visiveis hierarquia abaixo<p>
public:  <p>
//daqui em diante tudo e acessivel.<p>
ponto(float a,float b);<p>
void inicializa(float a,float b);<p>
float retorna_x(void);<p>
float retorna_y(void);<p>
void altera_x(float a);<p>
void altera_y(float b);<p>
void mostra(void);<p>
};<p>
<p>
<p>
class ponto_reflete:public ponto<p>
{<p>
private: <p>
//se voce quer adicionar dados membro encapsulados...<p>
public:<p>
ponto_reflete(float a, float b);<p>
void reflete(void); <p>
};<p>
<p>
class ponto_move:public ponto<p>
{<p>
public:<p>
ponto_move(float a,float b);<p>
void move(float dx,float dy);<p>
};<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//implementation file<p>
#include &lt;iostream.h&gt;<p>
#include "pontos.h"<p>
<p>
ponto::ponto(float a,float b)<p>
{<p>
 inicializa(a,b);<p>
}<p>
<p>
void ponto::inicializa(float a,float b)<p>
{<p>
 x=a;<p>
 y=b;<p>
}<p>
<p>
float ponto::retorna_x(void)<p>
{ return x; }<p>
<p>
float ponto::retorna_y(void)<p>
{ return y; }<p>
<p>
void ponto::altera_x(float a)<p>
{ x=a; }<p>
<p>
void ponto::altera_y(float b)<p>
{ y=b; }<p>
<p>
void ponto::mostra(void)<p>
{<p>
cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")"
&lt;&lt;endl;<p>
}<p>
<p>
ponto_reflete::ponto_reflete(float a,float b):ponto(a,b)<p>
{ }<p>
<p>
void ponto_reflete::reflete(void)<p>
{<p>
 x=-x; <p>
//*** protected da esse tipo de acesso aos atributos da classe pai<p>
 y=-y;<p>
}<p>
<p>
ponto_move::ponto_move(float a,float b):ponto(a,b)<p>
{ }<p>
<p>
void ponto_move::move(float dx,float dy)<p>
{<p>
 x=x+dx; <p>
//acesso so na hierarquia, no resto do programa nao.<p>
 y=y+dy;<p>
}<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>#include &lt;iostream.h&gt;<p>
#include "pontos.h"<p>
<p>
void main()<p>
{<p>
 ponto_reflete p1(3.14,2.17);<p>
 p1.reflete();<p>
 cout &lt;&lt; "P1";<p>
 p1.mostra();<p>
<p>
 ponto_move p2(1.0,1.0);<p>
 p2.move(.5,.5);<p>
 cout &lt;&lt; "P2";<p>
 p2.mostra();<p>
<p>
}<p>
<b><hr></b><p>
</CODE><b>
<a name="_Ref342722424"><a name="_Toc342736975"><a name="_Toc345409414"><a name="_Toc345810919"><a name="_Toc345838246"><a name="_Toc345942381"><a name="_Toc345949541"><a name="_Toc346168658"><a name="_Toc348417101"><a name="_Toc348931357"><a name="_Toc353900796"><a name="_Toc353946326"></b>
<h3>
<a name="RTFToC36">2.1.3.
REDEFINI&Ccedil;&Atilde;O DE FUN&Ccedil;&Otilde;ES MEMBRO
HERDADAS</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
<b>	</b>. Igual ao exemplo anterior, mas agora redefinindo a
fun&ccedil;&atilde;o membro<CODE> mostra</CODE> para a classe filha
<CODE>ponto reflete</CODE>.<p>
<p>
<b>Coment&aacute;rios:</b> <p>
	Na verdade este exemplo deveria pertencer  ao t&oacute;pico de polimorfismo,
contudo, nos exemplos seguintes usaremos tamb&eacute;m
redefini&ccedil;&otilde;es de fun&ccedil;&otilde;es membro, portanto faz-se
necess&aacute;rio introduzi-lo agora. Teremos mais explica&ccedil;&otilde;es
sobre o assunto.<p>
	Uma classe filha pode fornecer uma outra implementa&ccedil;&atilde;o para uma
fun&ccedil;&atilde;o membro herdada, caracterizando uma
redefini&ccedil;&atilde;o "overriding" de fun&ccedil;&atilde;o membro.
Importante: a fun&ccedil;&atilde;o membro deve ter a mesma assinatura (nome,
argumentos e valor de retorno), sen&atilde;o n&atilde;o se trata de uma
redefini&ccedil;&atilde;o e sim sobrecarga "overloading".	<p>
	No nosso exemplo a classe<CODE> ponto_reflete</CODE> redefine a
fun&ccedil;&atilde;o membro<CODE> mostra </CODE>da classe pai,
enquanto que a classe herdeira<CODE> ponto_move </CODE>aceita a
defini&ccedil;&atilde;o da fun&ccedil;&atilde;o membro<CODE>
mostra</CODE> dada pela classe<CODE> ponto </CODE>que
&eacute; sua classe pai.<p>
<CODE><p>
<b><hr></b><p>
//header file<p>
class ponto<p>
{<p>
private:<p>
float x;  <p>
//sao ocultos por default<p>
float y;   <p>
//sao ocultos por default<p>
public:  <p>
//daqui em diante tudo e acessivel.<p>
ponto(float a,float b);<p>
void inicializa(float a,float b);<p>
float retorna_x(void);<p>
float retorna_y(void);<p>
void altera_x(float a);<p>
void altera_y(float b);<p>
void mostra(void);<p>
};<p>
<p>
class ponto_reflete:public ponto<p>
{<p>
private: <p>
//se voce quer adicionar dados membro<p>
public:<p>
ponto_reflete(float a, float b);<p>
void reflete(void);<p>
void mostra(void); <p>
//redefinicao<p>
};<p>
<p>
class ponto_move:public ponto<p>
{<p>
public:<p>
ponto_move(float a,float b);<p>
void move(float dx,float dy);<p>
//esta classe filha nao redefine mostra<p>
};<p>
<p>
<b><hr></b><p>
<p>
//implementation file<p>
#include &lt;iostream.h&gt;<p>
#include "pontos.h"<p>
<p>
ponto::ponto(float a,float b)<p>
{<p>
 inicializa(a,b);<p>
}<p>
<p>
void ponto::inicializa(float a,float b)<p>
{<p>
 x=a;<p>
 y=b;<p>
}<p>
<p>
float ponto::retorna_x(void)<p>
{ return x; }<p>
<p>
float ponto::retorna_y(void)<p>
{ return y; }<p>
<p>
void ponto::altera_x(float a)<p>
{ x=a; }<p>
<p>
void ponto::altera_y(float b)<p>
{ y=b; }<p>
<p>
void ponto::mostra(void)<p>
{<p>
cout &lt;&lt; "(" &lt;&lt; x &lt;&lt; "," &lt;&lt; y &lt;&lt; ")"
&lt;&lt;endl;<p>
}<p>
<p>
ponto_reflete::ponto_reflete(float a,float b):ponto(a,b)<p>
{ }<p>
<p>
void ponto_reflete::reflete(void)<p>
{<p>
 altera_x(-retorna_x());<p>
 altera_y(-retorna_y());<p>
}<p>
<p>
void ponto_reflete::mostra(void)<p>
{<p>
cout &lt;&lt; "X:" &lt;&lt; retorna_x() &lt;&lt; " Y:";<p>
cout &lt;&lt; retorna_y() &lt;&lt; endl; <p>
}<p>
//somente altera o formato de impressao<p>
<p>
ponto_move::ponto_move(float a,float b):ponto(a,b)<p>
{ }<p>
<p>
void ponto_move::move(float dx,float dy)<p>
{<p>
 altera_x(retorna_x()+dx);<p>
 altera_y(retorna_y()+dy);<p>
}<p>
<p>
<b><hr></b><p>
<p>
#include &lt;iostream.h&gt;<p>
#include "pontos.h"<p>
<p>
void main()<p>
{<p>
 ponto_reflete p1(3.14,2.17);<p>
 p1.reflete();<p>
 cout &lt;&lt; "P1";<p>
 p1.mostra();<p>
<p>
 ponto_move p2(1.0,1.0);<p>
 p2.move(.5,.5);<p>
 cout &lt;&lt; "P2";<p>
 p2.mostra();<p>
<p>
}<p>
<b><hr></b><p>
</CODE><p>
<p>
<b>Resultado do programa:</b><p>
<b></b>P1X:-3.14 Y:-2.17<p>
P2(1.5,1.5)<p>
<p>
<b>Exerc&iacute;cios:</b> <p>
1)Teste redefini&ccedil;&atilde;o de fun&ccedil;&atilde;o membro colocando
"cout's" em fun&ccedil;&otilde;es membro da hierarquia, tais como:
<CODE>cout &lt;&lt; "Redefinido!"; cout &lt;&lt; "Original!";
</CODE><p>
<b>
<a name="_Ref342699816"><a name="_Toc342736976"><a name="_Toc345409415"><a name="_Toc345810920"><a name="_Toc345838247"><a name="_Toc345942382"><a name="_Toc345949542"><a name="_Toc346168659"><a name="_Toc348417102"><a name="_Toc348931358"><a name="_Toc353900797"><a name="_Toc353946327"></b>
<h3>
<a name="RTFToC37">2.1.4.
UMA HIERARQUIA DE LISTAS LIGADAS</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>. Construiremos sem importar nenhum outro c&oacute;digo, uma hierarquia
de listas ligadas especializadas. Um dos objetivos &eacute; obter uma
implementa&ccedil;&atilde;o de lista que possa ser reutilizada para
cria&ccedil;&atilde;o de pilhas e filas.<p>
<p>
<CENTER><IMG SRC="lista.gif" ></CENTER>


<b>	</b>O desenho acima foi elaborado segundo  metodologia descrita no livro
"Object Oriented Modeling and Design" . A associa&ccedil;&atilde;o entre as
classes lista e n&oacute; &eacute; uma associa&ccedil;&atilde;o do tipo "has
many" enquanto que a associa&ccedil;&atilde;o entre a classe lista e as classes
<CODE>lista ultimo e lista ordenada </CODE>indica heran&ccedil;a,
&eacute; uma associa&ccedil;&atilde;o do tipo "is a". Algumas
simplifica&ccedil;&otilde;es foram feitas do diagrama original.<b></b><p>
<b>	</b>No t&oacute;pico sobre templates 0 modificaremos este exemplo para
suportar tipos parametrizados. No t&oacute;pico sobre hierarquias de
implementa&ccedil;&atilde;o 2.2 usamos a vers&atilde;o de lista descrita aqui
para criar uma classe que implementa uma fila.<p>
<CODE><p>
<b><hr></b><p>
#ifndef MLISTH_H<p>
#define MLISTH_H<p>
#include &lt;stdlib.h&gt;<p>
#include &lt;iostream.h&gt;<p>
//Criacao de uma hierarquia de listas ligadas.<p>
//O elemento da lista e' um inteiro<p>
enum Boolean{FALSE,TRUE};<p>
<p>
class no{ //este e' o no da lista ligada, so e' usado por ela<p>
private:<p>
 int info; //informacao<p>
 no* prox; //ponteiro para o proximo<p>
public:<p>
 no();<p>
 no(int i,no* p);<p>
 no* get_prox(void);<p>
 void set_prox(no* p);<p>
 int get_info(void);<p>
 void set_info(int i);<p>
 no* dobra(void);<p>
 ~no(void);<p>
} ;<p>
<p>
class lista{ //esta e' a lista ligada comum.<p>
protected: //"visivel hierarquia abaixo"<p>
	no* primeiro; //primeiro no da lista, aqui eu insiro e removo.<p>
public:<p>
lista(void);<p>
Boolean vazia(void)const;<p>
Boolean contem(int el)const;<p>
void insere_primeiro(int elem);<p>
int* remove_primeiro();<p>
void mostra()const;<p>
~lista(void);<p>
}; //fim classe lista<p>
<p>
class listaultimo:public lista { //essa e a lista util para<p>
//implementar pilhas e filas.<p>
protected: //protected e uma opcao outra e' get_ultimo() e set_...<p>
  no* ultimo;<p>
public:<p>
listaultimo(void);<p>
void insere_ultimo(int elem); //nova<p>
void insere_primeiro(int elem); //redefinicao<p>
int* remove_primeiro();//redefinicao<p>
~listaultimo(void);<p>
//as operacoes nao redefinidas sao validas.<p>
};<p>
<p>
class listaordenada:public lista {<p>
//essa e' a lista comum com aprimoramentos/especializacoes<p>
public:<p>
listaordenada(void);<p>
Boolean contem(int el)const;<p>
void insere_primeiro(int elem);<p>
//insere em ordem<p>
int* remove_elemento(int el);<p>
//remove elemento el se existir<p>
~listaordenada(void);<p>
};<p>
<p>
#endif<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>#include "mlisth.h"<p>
#include &lt;iostream.h&gt;<p>
#include &lt;stdlib.h&gt;<p>
no::no()<p>
{prox=NULL;cout &lt;&lt; "Hi";}<p>
no::no(int i,no* p)<p>
{info=i;prox=p;cout &lt;&lt; "Hi";}<p>
no* no::get_prox(void){return prox;}<p>
void no::set_prox(no* p) {prox=p;}<p>
int no::get_info(void) {return info;}<p>
void no::set_info(int i) {info=i;}<p>
no* no::dobra(void)<p>
{<p>
if (get_prox()==NULL) return new no(get_info(),NULL);<p>
else return new no(get_info(),this-&gt;get_prox()-&gt;dobra());<p>
//recursividade para duplicacao da lista<p>
}<p>
<p>
no::~no(void) {cout &lt;&lt; "bye";}<p>
<p>
lista::lista(void):primeiro(NULL) {}<p>
//bloco de codigo vazio<p>
<p>
Boolean lista::vazia(void)const<p>
{<p>
return Boolean(primeiro==NULL);<p>
}<p>
<p>
Boolean lista::contem(int el) const//mais rapido que iterador<p>
{<p>
 no* curr;<p>
 int Conti;<p>
 curr=primeiro;<p>
 Conti=TRUE;<p>
 while ((curr!=NULL) &amp;&amp; Conti )<p>
 {<p>
  if (curr-&gt;get_info()!=el)<p>
	 {if (curr-&gt;get_prox()==NULL) Conti=FALSE; else
curr=curr-&gt;get_prox();}<p>
  else<p>
	Conti=FALSE;<p>
 };  //while<p>
  return Boolean(curr-&gt;get_info()==el);<p>
};<p>
<p>
void lista::insere_primeiro(int elem)<p>
{<p>
no* insirame;<p>
 if (primeiro==NULL) //lista vazia<p>
	 primeiro=new no(elem,NULL);<p>
 else {<p>
		 insirame=new no(elem,primeiro);<p>
		 primeiro=insirame;<p>
		};<p>
};<p>
<p>
int* lista::remove_primeiro()<p>
 {<p>
 int* devolvame=new int; //return<p>
 no* temp;     //to delete<p>
 if (primeiro==NULL)  return NULL; //lista vazia<p>
 else {<p>
		 (*devolvame)=primeiro-&gt;get_info();<p>
		 temp=primeiro;<p>
		 primeiro=primeiro-&gt;get_prox();<p>
		 delete temp;<p>
		 return devolvame;<p>
		};<p>
 };<p>
<p>
void lista::mostra() const<p>
{<p>
no* curr;<p>
cout &lt;&lt; "=";<p>
curr=primeiro;<p>
while (curr!=NULL)<p>
 {<p>
  cout &lt;&lt;"("&lt;&lt;curr-&gt;get_info()&lt;&lt;")"&lt;&lt;"-";<p>
  curr=curr-&gt;get_prox();<p>
 };<p>
}<p>
<p>
lista::~lista(void)<p>
{<p>
 no* temp;<p>
  while (primeiro!=NULL)<p>
  {<p>
  temp=primeiro;<p>
  primeiro=primeiro-&gt;get_prox();<p>
  delete temp;<p>
  };<p>
}<p>
<p>
listaordenada::listaordenada(void):lista()<p>
{};<p>
<p>
Boolean listaordenada::contem(int el)const<p>
{<p>
no* curr;<p>
Boolean conti=TRUE;<p>
 curr=primeiro;<p>
 while ((curr!=NULL) &amp;&amp; conti)<p>
 {<p>
  if (curr-&gt;get_info()&lt;el)<p>
  curr=curr-&gt;get_prox();<p>
  else conti=FALSE;<p>
 };<p>
 if (curr==NULL) return FALSE;<p>
 else return Boolean(curr-&gt;get_info()==el);<p>
}<p>
<p>
void listaordenada::insere_primeiro(int elem)<p>
{<p>
no* curr=primeiro;<p>
no* prev=NULL;<p>
no* insirame;<p>
Boolean conti=TRUE;<p>
 while ((curr!=NULL) &amp;&amp; conti)<p>
 {<p>
  if (curr-&gt;get_info()&lt;elem)<p>
  {prev=curr; curr=curr-&gt;get_prox();}<p>
  else conti=FALSE;<p>
 };<p>
 insirame=new no(elem,curr);<p>
 if (prev==NULL) primeiro=insirame;<p>
  else prev-&gt;set_prox(insirame);<p>
}<p>
<p>
int* listaordenada::remove_elemento(int el)<p>
{<p>
int* devolvame=new int;<p>
no* curr=primeiro;<p>
no* prev=NULL;<p>
no* deleteme;<p>
Boolean conti=TRUE;<p>
 while ((curr!=NULL) &amp;&amp; conti) //acha lugar onde pode estar el<p>
 {<p>
  if (curr-&gt;get_info()&lt;el)<p>
  {prev=curr; curr=curr-&gt;get_prox();} //anda<p>
  else conti=FALSE;<p>
 };<p>
 if (curr==NULL) return NULL; //fim de lista ou vazia<p>
 else //pode ser o elemento ou ele nao existe<p>
  {<p>
	 if (curr-&gt;get_info()==el)<p>
	  {<p>
		deleteme=curr;<p>
		if (prev==NULL) //lista so com um elemento ou primeiro el<p>
		  primeiro=curr-&gt;get_prox();<p>
		else<p>
		 {<p>
		  prev-&gt;set_prox(curr-&gt;get_prox());<p>
		 }<p>
		(*devolvame)=deleteme-&gt;get_info(); //so para verificar<p>
		delete deleteme;<p>
		return devolvame;<p>
	  }<p>
	 else return NULL;<p>
  }<p>
}<p>
<p>
<p>
listaordenada::~listaordenada(void)<p>
{cout &lt;&lt; "Lista destruida.";};<p>
<p>
listaultimo::listaultimo(void):lista()<p>
{<p>
ultimo=NULL;<p>
}<p>
<p>
<p>
void listaultimo::insere_ultimo(int elem)<p>
{<p>
no* insirame;<p>
insirame=new no(elem,NULL);<p>
if (ultimo==NULL) ultimo=insirame; //lista vazia<p>
else {<p>
		ultimo-&gt;set_prox(insirame);<p>
		ultimo=insirame;<p>
		};<p>
if (primeiro==NULL) primeiro=ultimo; //lista vazia<p>
}<p>
<p>
<p>
void listaultimo::insere_primeiro(int elem) //redefinicao<p>
{<p>
no* insirame;<p>
 if (primeiro==NULL) //lista vazia<p>
	{<p>
	 primeiro=new no(elem,ultimo);<p>
	 ultimo=primeiro;<p>
	}//lista vazia<p>
 else {<p>
		 insirame=new no(elem,primeiro);<p>
		 primeiro=insirame;<p>
		};<p>
}<p>
<p>
int* listaultimo::remove_primeiro()//redefinicao<p>
{<p>
int* devolvame=new int; //return<p>
 no* temp;     //to delete<p>
 if (primeiro==NULL)  return NULL; //lista vazia<p>
 else {<p>
		 (*devolvame)=primeiro-&gt;get_info();<p>
		 temp=primeiro;<p>
		 primeiro=primeiro-&gt;get_prox();<p>
		 delete temp;<p>
		 if (primeiro==NULL) ultimo=NULL; //volta lista vazia<p>
		 return devolvame;<p>
		};<p>
}<p>
<p>
listaultimo::~listaultimo(void)<p>
{<p>
 no* temp;<p>
  while (primeiro!=NULL)<p>
  {<p>
  temp=primeiro;<p>
  primeiro=primeiro-&gt;get_prox();<p>
  delete temp;<p>
  };<p>
  delete ultimo;<p>
}<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>#include "mlisth.h"<p>
main()<p>
{<p>
listaordenada minha;<p>
char option; //use in menu as option variable<p>
int el; //elemento a inserir<p>
int* receptor;<p>
do {<p>
 cout &lt;&lt;"\n";   //menu options display<p>
 cout &lt;&lt;"P:Insere no primeiro.\n";<p>
 cout &lt;&lt;"R:Remove no primeiro.\n";<p>
 cout &lt;&lt;"D:Remove elemento.\n";<p>
 cout &lt;&lt;"E:Existe elemento?\n";<p>
 cout &lt;&lt;"V:Vazia?\n";<p>
 cout &lt;&lt;"M:Mostra lista.\n";<p>
 cout &lt;&lt;"Q:Quit teste lista.\n";<p>
 cout &lt;&lt;"Entre comando:";<p>
 cin &gt;&gt; option; //reads user option<p>
 switch(option) //executes user option<p>
 {<p>
  case 'D':<p>
  case 'd':<p>
				cout &lt;&lt; "Entre elemento:";<p>
				cin &gt;&gt;el;<p>
				receptor=minha.remove_elemento(el);<p>
				if (receptor==NULL) cout &lt;&lt; "NULL" &lt;&lt; endl;<p>
				else cout &lt;&lt; (*receptor) &lt;&lt; endl;<p>
				break;<p>
  case 'P':<p>
  case 'p':<p>
				cout &lt;&lt; "Entre elemento:";<p>
				cin &gt;&gt; el;<p>
				minha.insere_primeiro(el);<p>
				break;<p>
  case 'R':<p>
  case 'r':<p>
				if (!minha.vazia())<p>
				cout &lt;&lt; (*minha.remove_primeiro()) &lt;&lt;endl;<p>
				else cout &lt;&lt; "NULL, Lista vazia." &lt;&lt;endl;<p>
				break;<p>
  case 'M':<p>
  case 'm':<p>
				minha.mostra();<p>
				break;<p>
  case 'E':<p>
  case 'e':<p>
				cout &lt;&lt; "Entre elemento:";<p>
				cin &gt;&gt;el;<p>
				cout &lt;&lt; minha.contem(el);<p>
				break;<p>
  case 'V':<p>
  case 'v':<p>
				cout &lt;&lt; minha.vazia();<p>
				break;<p>
  default:  ;<p>
 }  //switch-case code block<p>
} while ((option!='Q') &amp;&amp; (option!='q'));  //menu loop code block<p>
<p>
return 0;<p>
}  //main code block<p>
<b><hr></b><p>
</CODE><b>Coment&aacute;rios: </b><p>
<b>	</b>Note que o programa principal s&oacute; testa a lista ordenada, em
outros programas exemplo baseados neste veremos testes para a<CODE>
lista_ultimo. </CODE><p>
<b></b><p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1)Experimente derivar (criar classes herdeiras) outras classes lista com
propriedades de seu interesse tais como obten&ccedil;&atilde;o de sublista.<p>
<p>
2)Introduza na classe lista a contagem do n&uacute;mero de elementos numa
lista.<p>
<p>
3)Crie uma fun&ccedil;&atilde;o membro chamado<CODE> void
remove_todos(void); </CODE>que simplesmente deixa a lista vazia.<p>
<p>
*4)Suponha que voc&ecirc; &eacute; um programador de uma empresa e teve que
implementar a hierarquia de listas para seu  grupo de desenvolvimento, segundo
uma especifica&ccedil;&atilde;o dada pelo seu chefe. <p>
	Voc&ecirc; introduziria as mudan&ccedil;as sugeridas nos exerc&iacute;cios
anteriores, mesmo sabendo que elas n&atilde;o estavam na
especifica&ccedil;&atilde;o? Que dificuldade um usu&aacute;rio de sua classe
lista teria para introduzi-las caso surgisse a necessidade e voc&ecirc;
n&atilde;o tivesse feito? <p>
	Discuta as seguintes maneiras de um programador de seu grupo conseguir o
efeito desejado de adicionar as sugest&otilde;es dos exerc&iacute;cios
anteriores a hierarquia: usar heran&ccedil;a (derivar uma classe com
<CODE>void remove_todos(void) </CODE>), alterar o c&oacute;digo
original, pedir para voc&ecirc; o programador do c&oacute;digo original mudar a
implementa&ccedil;&atilde;o. Lembre-se que pode existir mais de um programador
usando a vers&atilde;o original da hierarquia de listas.<p>
<b>
<a name="_Ref342315645"><a name="_Toc342736977"><a name="_Toc345409416"><a name="_Toc345810921"><a name="_Toc345838248"><a name="_Toc345942383"><a name="_Toc345949543"><a name="_Toc346168660"><a name="_Toc348417103"><a name="_Toc348931359"><a name="_Toc353900798"><a name="_Toc353946328"></b>
<h2>
<a name="RTFToC38">2.2.
HIERARQUIAS DE
IMPLEMENTA&Ccedil;&Atilde;O</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h2>
<b></b><p>
<b></b>	Nossas hierarquias de implementa&ccedil;&atilde;o em termos de
c&oacute;digo (heran&ccedil;a) n&atilde;o s&atilde;o hierarquias, usamos
delega&ccedil;&atilde;o para obter pilhas a partir listas. Agregamos uma lista
em nossas classes e usamos esta lista de acordo com a l&oacute;gica envolvida.
Tudo o que fizemos poderia ser feito usando heran&ccedil;a<CODE> private,
</CODE>o que justificaria o t&iacute;tulo "hierarquias de
implementa&ccedil;&atilde;o", embora tornasse o nosso texto menos
acad&ecirc;mico.<p>
<a name="_Toc342736978"><a name="_Toc345409417"><a name="_Toc345810922"><a name="_Toc345838249"><a name="_Toc345942384"><a name="_Toc345949544"><a name="_Toc346168661"><a name="_Toc348417104"><a name="_Toc348931360"><a name="_Toc353900799"><a name="_Toc353946329">
<h3>
<a name="RTFToC39">2.2.1.
FILA A PARTIR DE UMA LISTA</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>Reuso  de c&oacute;digo de uma lista ligada 2.1  para a
implementa&ccedil;&atilde;o de uma fila atrav&eacute;s de
agrega&ccedil;&atilde;o.  Para podermos declarar e usar um objeto lista na
nossa classe fila precisamos conhecer sua interface. Sabemos que nosso objeto
lista permite inserir em ambas extremidades, inicio e fim da lista, mas
s&oacute; permite remo&ccedil;&otilde;es em um extremo, o inicio. Como uma fila
permite inser&ccedil;&otilde;es somente num extremo e remo&ccedil;&otilde;es
nos extremo oposto, precisaremos usar nossa lista da seguinte forma:
inser&ccedil;&atilde;o no final da lista e remo&ccedil;&otilde;es no
come&ccedil;o.<b></b><p>
<b>	</b>Seguem abaixo exemplos de chamadas de fun&ccedil;&otilde;es membro da
classe lista implementada em 2.1 para trabalhar com n&uacute;meros inteiros.<p>
<b></b><p>
<b></b>Consideremos uma lista al, s&atilde;o v&aacute;lidas as seguintes
opera&ccedil;&otilde;es:<p>
<CODE><b></b><p>
<b></b>al.vazia(); //retorna se a lista (fila agora) esta vazia.<p>
al.contem(el); //retorna 1 se el pertence a lista e 0 se el nao pertence a
lista.<p>
al.insere_ultimo(el);     //insere no final da lista (entrada da fila).<p>
al.insere_primeiro(el); //nao usaremos na implementacao de fila, usariamos se
//implementassemos uma pilha.<p>
al.remove_primeiro(); //remove no comeco da lista (saida da fila).<p>
al.mostra(); //mostra lista (mostra fila em ordem contraria de insercao)<p>
</CODE><b></b><p>
<b></b>	Para maiores informa&ccedil;&otilde;es consulte t&oacute;pico anterior
onde definimos esta lista. Por este motivo n&atilde;o vamos incluir sua
defini&ccedil;&atilde;o a seguir.
<a name="_Ref342134189"><a name="_Toc342736979"><a name="_Toc345409418"><p>
<CODE><p>
<b><hr></b><p>
//header file para a classe fila<p>
#include "mlisth.h"<p>
class fila { //agregacao de uma lista de<p>
private:<p>
 listaultimo al;  //a lista<p>
public:<p>
 fila();<p>
 Boolean vazia();<p>
 Boolean contem(int el);<p>
 void insere(int el);<p>
 int* remove();<p>
 void mostra();<p>
};<p>
<p>
<p>
<b><hr></b><p>
<b></b><p>
//implementacao para a classe fila<p>
#include "mqueue.h"<p>
#include "mlisth.h"<p>
fila::fila(){};<p>
<p>
Boolean fila::vazia()<p>
	{return al.vazia();}<p>
<p>
Boolean fila::contem(int el)<p>
	{return al.contem(el);}<p>
<p>
void fila::insere(int el)<p>
	{al.insere_ultimo(el);}<p>
<p>
int* fila::remove()<p>
	{return al.remove_primeiro();}<p>
<p>
void fila::mostra()<p>
	{al.mostra();}<p>
<p>
<b><hr></b><p>
<b></b><p>
//programa principal, testes da classe fila<p>
#include "mqueue.h"<p>
main()<p>
{<p>
fila minha;<p>
char option; //usada em menu como variavel de opcao<p>
int el; //elemento a inserir<p>
do {<p>
 cout &lt;&lt;"\n";   //opcoes do menu<p>
 cout &lt;&lt;"I:Insere.\n";<p>
 cout &lt;&lt;"R:Remove.\n";<p>
 cout &lt;&lt;"M:Mostra fila.\n";<p>
 cout &lt;&lt;"Q:Quit fila test.\n";<p>
 cout &lt;&lt;"V:Vazia?\n";<p>
 cout &lt;&lt;"C:Contem?\n";<p>
 cout &lt;&lt;"Entre comando:";<p>
 cin &gt;&gt; option; //le opcao do usuario<p>
 switch(option) //executa opcao do usuario<p>
 {<p>
  case 'I':<p>
  case 'i':<p>
				cout &lt;&lt; "Entre elemento:";<p>
				cin &gt;&gt;el;<p>
				minha.insere(el);<p>
				break;<p>
  case 'R':<p>
  case 'r':<p>
				if (!minha.vazia())<p>
				cout &lt;&lt; (*minha.remove()) &lt;&lt;endl;<p>
				else cout &lt;&lt; "NULL, fila vazia." &lt;&lt;endl;<p>
				break;<p>
  case 'C':<p>
  case 'c':<p>
				cout &lt;&lt; "Entre elemento:";<p>
				cin &gt;&gt;el;<p>
				cout &lt;&lt; minha.contem(el);<p>
				break;<p>
  case 'M':<p>
  case 'm':<p>
				minha.mostra();<p>
				break;<p>
  case 'V':<p>
  case 'v':<p>
				cout &lt;&lt; "Resultado:" &lt;&lt; minha.vazia() &lt;&lt;endl;<p>
				break;<p>
  default:  ;<p>
 }  //switch-case bloco de codigo<p>
} while ((option!='Q') &amp;&amp; (option!='q'));  //loop do menu fim<p>
<p>
return 0;<p>
}  // bloco de codigo principal<p>
<b><hr></b><p>
</CODE><p>
<a name="_Toc345810923"><a name="_Toc345838250"><a name="_Toc345942385"><a name="_Toc345949545"><a name="_Toc346168662"><a name="_Toc348417105"><a name="_Ref348536485"><a name="_Toc348931361"><a name="_Toc353900800"><a name="_Toc353946330">
<h1>
<a name="RTFToC40">3.
POLIMORFISMO, FUN&Ccedil;&Otilde;ES
VIRTUAIS</a></a></a></a></a></a></a></a></a></a></a></a></a>
</a></h1>
<b></b><p>
<b>	</b>.Existem v&aacute;rios tipos de polimorfismo. No que se refere a
objetos, Modula-3 apresenta polimorfismos classificados como universais,
exemplos de  polimorfismos do tipo "ad-hoc" e objetos podem ser encontrados em
outras linguagens como C++.<p>
<b>
<a name="_Toc342736980"><a name="_Toc345409419"><a name="_Toc345810924"><a name="_Toc345838251"><a name="_Toc345942386"><a name="_Toc345949546"><a name="_Toc346168663"><a name="_Toc348417106"><a name="_Toc348931362"><a name="_Toc353900801"><a name="_Toc353946331"></b>
<h2>
<a name="RTFToC41">3.1.
O QUE SIGNIFICA POLIMORFISMO</a></a></a></a></a></a></a></a></a></a></a>
</a></h2>
<b></b><p>
<b></b>	Polimorfismo, do grego: muitas formas. Polimorfismo &eacute; a
capacidade de um operador executar a a&ccedil;&atilde;o apropriada dependendo
do tipo do operando. Aqui operando e operador est&atilde;o definidos num
sentido mais geral: operando pode significar argumentos atuais de um
procedimento e operador o procedimento, operando pode significar um objeto e
operador um m&eacute;todo, operando pode significar um tipo e operador um
objeto deste tipo.
<a name="_Toc342736981"><a name="_Toc345409420"><a name="_Toc345810925"><a name="_Toc345838252"><a name="_Toc345942387"><a name="_Toc345949547"><a name="_Toc346168664"><a name="_Toc348417107"><a name="_Toc348931363"><a name="_Toc353900802"><a name="_Toc353946332">
<h3>
<a name="RTFToC42">3.1.1.
SOBRECARGA DE</a></a></a></a></a></a></a></a> M&Eacute;TODOS</a></a></a>
</a></h3>
<p>
	Modula-3 n&atilde;o oferece este tipo de polimorfismo que pode ser considerado
com "ad-hoc". Este tipo de polimorfismo permitiria a exist&ecirc;ncia de
v&aacute;rios procedimentos e m&eacute;todos de mesmo nome, por&eacute;m com
assinaturas levemente diferentes, variando no n&uacute;mero e tipo de
argumentos. Ficaria a cargo do compilador escolher de acordo com as listas de
argumentos os procedimentos ou m&eacute;todos a serem executados.<p>
<a name="_Toc342736982"><a name="_Toc345409421"><a name="_Toc345810926"><a name="_Toc345838253"><a name="_Toc345942388"><a name="_Toc345949548"><a name="_Toc346168665"><a name="_Toc348417108"><a name="_Toc348931364"><a name="_Toc353900803"><a name="_Toc353946333">
<h3>
<a name="RTFToC43">3.1.2.
REDEFINI&Ccedil;&Atilde;O DE UMA FUN&Ccedil;&Atilde;O MEMBRO PARA UMA
CLASSE HERDEIRA</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
	.Este exemplo j&aacute; foi apresentado em 2.1.3. Tamb&eacute;m trata-se de um
polimorfismo, pode ser classificado como polimorfismo de inclus&atilde;o.
<a name="_Toc342736983"><a name="_Toc345409422"><a name="_Toc345810927"><a name="_Toc345838254"><a name="_Toc345942389"><a name="_Toc345949549"><a name="_Toc346168666"><a name="_Toc348417109"><a name="_Toc348931365"><a name="_Toc353900804"><a name="_Toc353946334">
<h3>
<a name="RTFToC44">3.1.3.
"COPY CONSTRUCTOR"</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b>	</b><p>
<b></b>	A fun&ccedil;&atilde;o membro<CODE> ponto(ponto&amp; a);
</CODE>&eacute; um copy constructor, al&eacute;m disso tem o mesmo nome
que  <CODE>ponto(float dx,float dy);. </CODE>Tal
duplica&ccedil;&atilde;o de nomes pode parecer estranha, por&eacute;m C++
permite que eles coexistam para uma classe porque n&atilde;o tem a mesma
assinatura (nome+argumentos). Isto se chama  sobrecarga de fun&ccedil;&atilde;o
membro, o compilador sabe distinguir entre esses dois construtores. Outras
fun&ccedil;&otilde;es membro, n&atilde;o s&oacute; construtores poder&atilde;o
ser redefinidas, ou sobrecarregadas para v&aacute;rios argumentos diferentes,
esse recurso &eacute; um  polimorfismo do tipo "ad-hoc".<p>
<p>
	O que &eacute; interessante para n&oacute;s &eacute; o fato de o argumento do
construtor<CODE> <b>ponto</b>(<b>ponto</b>&amp; a); </CODE> ser da
mesma classe para qual o  construtor foi implementado, esse &eacute; o chamado
"copy  constructor". Ele usa um objeto de seu tipo para se inicializar. Outros
m&eacute;todos semelhantes seriam: <CODE>circulo(circulo&amp; a);
mouse(mouse&amp; d);. </CODE>Implementar copy constructor pode ser muito
importante, lembre-se dos problemas com c&oacute;pias de objetos apresentados
em 1.5.3.5.<p>
<CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
struct ponto<p>
{<p>
float x;<p>
float y;<p>
<p>
ponto(float a,float b);<p>
//construtor tambem pode ser inline ou nao<p>
<p>
ponto(ponto&amp; a); //copy constructor<p>
void mostra(void);<p>
void move(float dx,float dy);<p>
<p>
};<p>
<p>
ponto::ponto(float a,float b)<p>
{<p>
 x=a;<p>
 y=b;<p>
}<p>
<p>
ponto::ponto(ponto&amp; a)<p>
{<p>
x=a.x;<p>
y=a.y;<p>
}<p>
<p>
void ponto::mostra(void)<p>
{cout &lt;&lt; "X:" &lt;&lt; x &lt;&lt; " , Y:" &lt;&lt; y &lt;&lt; endl;}<p>
<p>
void ponto::move(float dx,float dy)<p>
{<p>
 x+=dx;<p>
 y+=dy;<p>
}<p>
<p>
<p>
void main()<p>
{<p>
ponto ap(0.0,0.0);<p>
ap.mostra();<p>
ap.move(1.0,1.0);<p>
ap.mostra();<p>
ponto ap2(ap);<p>
ap2.mostra();<p>
}<p>
<b><hr></b><p>
</CODE><p>
<b>Coment&aacute;rios:</b> <p>
	Observe o c&oacute;digo: <CODE><p>
ponto::ponto(ponto&amp; a)<p>
{<p>
x=a.x;<p>
y=a.y;<p>
}<p>
</CODE><p>
	Essa fun&ccedil;&atilde;o membro, esse m&eacute;todo, pertence a outro objeto
que n&atilde;o o argumento a, ent&atilde;o para distinguir o
atributo<CODE> x </CODE>deste objeto, do atributo
<CODE>x</CODE> de a usamos <CODE>a.x</CODE> e
simplesmente<CODE> x </CODE>para o objeto local (dono da
fun&ccedil;&atilde;o membro).<p>
<p>
<b>Exerc&iacute;cios:</b><p>
1)O copy constructor usa passagem por refer&ecirc;ncia, construa uma
fun&ccedil;&atilde;o que troca duas vari&aacute;veis inteiras usando passagem
por refer&ecirc;ncia. Analise esse recurso sob a &oacute;tica do assunto
encapsulamento. Em que casos voc&ecirc; pode afirmar ser seguro usar esse
recurso?<p>
<p>
2) Defina um copy constructor para o tipo abstrato de dados
fra&ccedil;&atilde;o apresentado em: 1.4.
<h3>
<a name="RTFToC45">3.1.4.
<a name="_Toc342736984"><a name="_Toc345409423"><a name="_Toc345810928"><a name="_Toc345838255"><a name="_Toc345942390"><a name="_Toc345949550"><a name="_Toc346168667"><a name="_Toc348417110"><a name="_Toc348931366"><a name="_Toc353900805"><a name="_Toc353946335">
SOBRECARGA DE FUN&Ccedil;&Atilde;O EM
C++.</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>Este t&oacute;pico apresenta exemplos importantes para o estudo do
restante do tutorial.<b></b><p>
<b>	</b>Sobrecarga "Overloading" de fun&ccedil;&atilde;o &eacute; um tipo de
polimorfismo classific&aacute;vel como ad-hoc. C++ permite que
fun&ccedil;&otilde;es de mesmo nome tenham par&acirc;metros distintos. Este
exemplo mostra a sobrecarga da fun&ccedil;&atilde;o abs que calcula o valor
absoluto  de um n&uacute;mero: <CODE><p>
<b><hr></b><p>
<b></b>//header file funcover.h<p>
float abs(float a);<p>
int abs(int a);<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//implementation file<p>
#include "funcover.h"<p>
<p>
float abs(float a)<p>
{<p>
 if (a&gt;0.0) return a;<p>
 else return -a;<p>
}<p>
<p>
int abs(int a)<p>
{<p>
 if (a&gt;0) return a;<p>
 else return -a;<p>
}<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>#include &lt;iostream.h&gt;<p>
#include "funcover.h"<p>
<p>
void main()<p>
{<p>
int i1;<p>
float f1;<p>
cout &lt;&lt; abs(int(-10))&lt;&lt;endl;<p>
cout &lt;&lt; abs(float(-10.1))&lt;&lt;endl;<p>
f1=-9.1;<p>
i1=8.0;<p>
cout &lt;&lt; abs(f1) &lt;&lt; endl;<p>
cout &lt;&lt; abs(i1) &lt;&lt; endl;<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Resultado do programa:</b><p>
<b></b>10<p>
10.1<p>
9.1<p>
8<p>
<b></b><p>
<b>Coment&aacute;rios: </b><p>
<b></b><CODE>cout &lt;&lt; abs(float(-10.1))&lt;&lt;endl; </CODE><p>
	Perceba que quando chamamos a fun&ccedil;&atilde;o abs para um valor (-10.1) e
n&atilde;o uma vari&aacute;vel (possui um tipo), temos que fazer a
convers&atilde;o expl&iacute;cita para o compilador, porque este  n&atilde;o
sabe decidir qual fun&ccedil;&atilde;o chamar (para<CODE> float
</CODE>ou <CODE>int</CODE>), mesmo estando presente o ponto
indicando a casa decimal.<p>
Observe que -10.1 pode ser <CODE>double </CODE>ou
<CODE>float</CODE>. Enquanto que 10 pode ser
<CODE>long</CODE> ou <CODE>int. </CODE><p>
	No exemplo 4 veremos sobrecarga de operador, que &eacute; semelhante a
sobrecarga de fun&ccedil;&atilde;o. Observe que os operadores<CODE> * -
</CODE> e at&eacute; mesmo os operadores de
extra&ccedil;&atilde;o<CODE> &lt;&lt; &gt;&gt;</CODE> usados com
<CODE>cout </CODE> s&atilde;o exemplos de sobrecarga de operadores.
Eles j&aacute; est&atilde;o definidos com a mesma forma para um conjunto
restrito de tipos.<p>
<b></b><p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1) Melhore este exemplo para que se calcule tamb&eacute;m o valor
absoluto de n&uacute;meros em tipo <CODE>long. </CODE><p>
<p>
2)Crie um programa an&aacute;logo a este exemplo s&oacute; que agora com a
fun&ccedil;&atilde;o <CODE>max </CODE>que deve calcular o
m&aacute;ximo de dois n&uacute;meros.<p>
<p>
3)Crie um programa an&aacute;logo a este exemplo s&oacute; que agora com a
fun&ccedil;&atilde;o<CODE> mdc </CODE>que deve calcular o
m&aacute;ximo divisor comum de dois n&uacute;meros<CODE> int</CODE>
ou <CODE>long</CODE>.<p>
<p>
*4)Lembre-se de alguns programas que voc&ecirc; tenha escrito em que se pudesse
fazer uso de fun&ccedil;&otilde;es sobrecarregadas. Comente de que modo tal uso
facilitaria tanto a programa&ccedil;&atilde;o quanto a manuten&ccedil;&atilde;o
de software. De algum modo esse uso poderia atrapalhar o desenvolvimento do
programa? Se sim de que modo?<p>
<b></b><p>
<b></b>*5)Mude o c&oacute;digo de uma das fun&ccedil;&otilde;es abs para
calcular o m&oacute;dulo do n&uacute;mero elevando-o ao quadrado e extraindo a
raiz quadrada, eliminando assim o sinal. Voc&ecirc; provavelmente vai precisar
da library <CODE>&lt;math.h&gt;</CODE> . Note que o que importa
para a sobrecarga &eacute; o cabe&ccedil;alho, a assinatura da
fun&ccedil;&atilde;o e n&atilde;o o c&oacute;digo em si.<p>
<b></b><p>
<b>	</b>Este programa mostra algumas perip&eacute;cias que podemos fazer com
sobrecarga de fun&ccedil;&otilde;es. Veja exemplo anterior primeiro.
<CODE><p>
<b><hr></b><p>
<b></b>//header file funcover.h<p>
float max(float a,float b);<p>
float max(float a,float b,float c);<p>
int max(int a,int b);<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>#include "funcover.h"<p>
<p>
float max(float a,float b)<p>
{<p>
 if (a&gt;b) return a;<p>
 else return b;<p>
}<p>
<p>
float max(float a,float b,float c)<p>
{<p>
 if (a&gt;b) return max(a,c);<p>
 else return max(b,c);<p>
}<p>
<p>
int max(int a,int b)<p>
{<p>
 if (a&gt;b) return a;<p>
 else return b;<p>
}<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>#include &lt;iostream.h&gt;<p>
#include "funcover.h"<p>
<p>
void main()<p>
{<p>
cout &lt;&lt; max(float(1.2),float(3.4),float(2.1))&lt;&lt;endl;<p>
cout &lt;&lt; max(float(1.5),float(.65)) &lt;&lt; endl;<p>
cout &lt;&lt; max(int(12),int(120));<p>
}<p>
<b><hr></b><p>
<p>
</CODE><b></b><p>
<b>Resultado do programa:</b><p>
<b></b>3.4<p>
1.5<p>
120<p>
<b></b>
<h3>
<a name="RTFToC46">3.1.5.
<a name="_Toc342736985"><a name="_Toc345409424"><a name="_Toc345810929"><a name="_Toc345838256"><a name="_Toc345942391"><a name="_Toc345949551"><a name="_Toc346168668"><a name="_Toc348417111"><a name="_Toc348931367"><a name="_Toc353900806"><a name="_Toc353946336">
"DEFAULT ARGUMENTS", VALORES
SUGEST&Atilde;O</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>Valores sugest&atilde;o, argumentos padr&atilde;o ou "default
arguments", s&atilde;o nomes para um tipo de polimorfismo ad-hoc fornecido por
C++.<p>
<b>	</b>Para demonstrar o uso  de default values vamos relembrar o nosso tipo
abstrato de dados fra&ccedil;&atilde;o de 1.2.1.4. Um de seus  construtores
tinha a seguinte forma: <CODE> fracao() {num=0; den=1;} //construtor
vazio,default </CODE>enquanto que o construtor normal da
fra&ccedil;&atilde;o tinha a seguinte forma: <CODE> fracao(long t,long
m);. </CODE><p>
	"Default arguments" nos d&aacute; a oportunidade de fundir esses dois
construtores num s&oacute; resultando no seguinte: <CODE> fracao(long
t=0,long m=1); {num=t; den=m;} </CODE>onde 1 e 0 s&atilde;o valores
sugest&atilde;o para os argumentos.<p>
<b></b><p>
<b></b>A instancia&ccedil;&atilde;o<CODE> fracao a( )
</CODE>segundo aquele &uacute;nico construtor cria : <CODE>(0/1)
</CODE><p>
A instancia&ccedil;&atilde;o<CODE> fracao b(1) </CODE> segundo
aquele &uacute;nico construtor cria: <CODE>(1/1) </CODE><p>
A instancia&ccedil;&atilde;o<CODE> fracao c(1,2) </CODE>segundo
aquele &uacute;nico construtor cria: <CODE>(1/2) </CODE><p>
<b></b><p>
<b>Regras para a cria&ccedil;&atilde;o de "Default arguments":</b><p>
<b>	</b>N&atilde;o s&atilde;o permitidas declara&ccedil;&otilde;es do tipo
<CODE>fracao(long t=0,long m); </CODE>uma vez que voc&ecirc;
inseriu um argumento padr&atilde;o na lista de argumentos todos a direita deste
tamb&eacute;m dever&atilde;o ter seus valores sugest&atilde;o. Ent&atilde;o,
por esta regra a &uacute;nica alternativa restante para o tipo
fra&ccedil;&atilde;o seria <CODE>fracao(long t,long m=1); </CODE><p>
<b></b><p>
<b>Exerc&iacute;cios: </b><p>
<b></b>1)Fa&ccedil;a a modifica&ccedil;&atilde;o do tipo abstrato de dados
fracao retirando os dois construtores mencionados e substituindo por um
&uacute;nico. O copy constructor voc&ecirc; pode deixar como est&aacute;.<p>
<b></b>
<h3>
<a name="RTFToC47">3.1.6.
<a name="_Ref342704371"><a name="_Toc342736986"><a name="_Toc345409425"><a name="_Toc345810930"><a name="_Toc345838257"><a name="_Toc345942392"><a name="_Toc345949552"><a name="_Toc346168669"><a name="_Toc348417112"><a name="_Toc348931368"><a name="_Toc353900807"><a name="_Toc353946337">
SOBRECARGA DE OPERADOR</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
<b>	</b>O tipo abstrato de dados fra&ccedil;&atilde;o (vers&atilde;o completa)
de 1.2.4.4 possui v&aacute;rios operadores sobrecarregados. Algumas sobrecargas
deste exemplo envolvem o uso da palavra chave<CODE> friends</CODE>
que voc&ecirc; n&atilde;o aprendeu ainda, portanto atenha-se aos exemplos que
n&atilde;o cont&eacute;m essa palavra reservada.<p>
	Extens&atilde;o da classe vetor de 1.5.3.6 para incluir um iterador.  Este
exemplo j&aacute; &eacute; apresentado com templates.<p>
<b></b><p>
<b>T&oacute;picos abordados:</b><p>
<b>	</b>Sobrecarga de operador.<p>
<CODE><p>
<b><hr></b><p>
<b></b>//header file para classe vetor: vet.h<p>
#include &lt;iostream.h&gt;<p>
#include &lt;stdlib.h&gt; //exit(1)<p>
<p>
<p>
const int inicio=0; //inicio do vetor<p>
<p>
<p>
class vetor{<p>
private:<p>
float* v;  //pode ser qualquer tipo que atenda as operacoes &lt; &gt; =<p>
int tamanho;<p>
public:<p>
vetor (int tamanho) ;<p>
float&amp; operator[] (int i);<p>
float maximo();   //acha o valor maximo do vetor<p>
int primeiro(void);<p>
int ultimo(void);<p>
};<p>
<p>
vetor::vetor (int tam)<p>
{v=new float[tam]; tamanho=tam;}<p>
<p>
int vetor::primeiro (void)<p>
{return inicio;}<p>
<p>
int vetor::ultimo (void)<p>
{return tamanho-1;}<p>
<p>
float&amp; vetor::operator[](int i)<p>
{<p>
 if (i&lt;0 || i&gt;=tamanho)<p>
 {cout &lt;&lt; "Fora dos limites! Exit program"; exit(1);}<p>
 return v[i];<p>
}<p>
<p>
float vetor:: maximo(void)<p>
{int candidato=inicio;<p>
 for (int i=inicio;i&lt;tamanho;i++)<p>
 if (v[i]&gt;v[candidato]) candidato=i;<p>
 return v[candidato];}<b></b><p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Explica&ccedil;&atilde;o das opera&ccedil;&otilde;es, das
fun&ccedil;&atilde;o membros do iterador vetor:</b><p>
<b></b><p>
<b></b><CODE>iteradorvetor(vetor &amp; v); </CODE>:Construtor,
j&aacute; cria o iterador de vetor inicializando-o para apontar para o
come&ccedil;o do vetor.<p>
<b></b><p>
<b></b><CODE>virtual int comeca();</CODE>: Inicializa o iterador
para o come&ccedil;o do vetor.<b></b><p>
<b></b><p>
<b></b><CODE>virtual int operator!(); </CODE><b> : </b>Verifica se
a itera&ccedil;&atilde;o n&atilde;o chegou no fim do vetor: 1 indica que
n&atilde;o chegou, 0 indica que chegou no fim do vetor.<p>
<b></b><p>
<b></b><CODE>virtual int operator ++ ();</CODE>: Faz o iterador
mover adiante uma posi&ccedil;&atilde;o.<p>
<b>	</b><p>
<b></b><CODE>virtual float operator() ();</CODE><b> </b>:Retorna o
elemento daquela posi&ccedil;&atilde;o do vetor.<p>
<b></b><p>
<b></b><CODE>virtual void operator= (float entra);<b> </b></CODE>:
Atribui a posi&ccedil;&atilde;o atual do vetor.<p>
<b></b><p>
<b></b><CODE>int pos();</CODE><b> </b>: Retorna a
posi&ccedil;&atilde;o (&iacute;ndice) do vetor em que o iterador se encontra,
n&atilde;o &eacute; virtual porque n&atilde;o faz sentido para um iterador de
&aacute;rvore por exemplo.<b></b><p>
<b></b><CODE><p>
<b><hr></b><p>
<b></b>//it.h , arquivo com definicoes do iterador.<p>
<p>
class iteradorvetor<p>
{<p>
private:<p>
		vetor vetorref;<p>
		int posicao;<p>
public:<p>
	iteradorvetor(vetor &amp; v);<p>
	int comeca();<p>
	int operator!();<p>
	int operator ++ ();<p>
	float operator() ();<p>
	void operator= (float entra);<p>
	int pos(); //retorna posicao, n~ virtual pq n~ faz sentido p/ arvore por ex.<p>
	};<p>
<p>
int iteradorvetor::pos()<p>
{<p>
return posicao;<p>
}<p>
<p>
int iteradorvetor::operator!()<p>
{<p>
return posicao&lt;=vetorref.ultimo();<p>
}<p>
<p>
<p>
iteradorvetor::iteradorvetor(vetor &amp; vet):vetorref(vet)<p>
{<p>
comeca();<p>
}<p>
<p>
int iteradorvetor::comeca()<p>
{<p>
posicao=vetorref.primeiro();<p>
return operator!();<p>
}<p>
<p>
<p>
int iteradorvetor::operator ++()<p>
{<p>
posicao++;<p>
return operator!();<p>
}<p>
<p>
<p>
void iteradorvetor::operator=(float entra)<p>
{<p>
vetorref[posicao]=entra;<p>
}<p>
<p>
float iteradorvetor::operator() ()<p>
{<p>
float copia;<p>
copia=vetorref[posicao];<p>
return copia;<p>
}<b></b><p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Programa principal, testes:</b> <CODE><p>
<b><hr></b><p>
<b></b>#include &lt;iostream.h&gt;<p>
#include "vet.h"<p>
#include "it.h"<p>
main()<p>
{<p>
int repete=0;<p>
int ind;<p>
float item;<p>
vetor meu(5);<p>
iteradorvetor itmeu(meu);<p>
<p>
for (itmeu.comeca();!itmeu;++itmeu)<p>
{<p>
 cout &lt;&lt; "Entre com valor da posicao:" &lt;&lt; itmeu.pos() &lt;&lt;
"\n";<p>
 cin &gt;&gt; item;<p>
 itmeu=item;<p>
}<p>
<p>
for (itmeu.comeca();!itmeu;++itmeu) cout&lt;&lt; itmeu()&lt;&lt; " ";<p>
cout &lt;&lt; "\nEntre com o indice da posicao a atualizar:\n";<p>
cin &gt;&gt; ind;<p>
cout &lt;&lt; "Entre com o valor a incluir:";<p>
cin  &gt;&gt; item;<p>
meu[ind]=item;<p>
<p>
for (int k=meu.primeiro();k&lt;=meu.ultimo();k++) cout&lt;&lt; meu[k]&lt;&lt; "
";<p>
cout &lt;&lt;endl &lt;&lt; "Maximo:" &lt;&lt; meu.maximo();<p>
<p>
<p>
return 0;<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Coment&aacute;rios: </b><p>
<b>	</b>O significado do operador &eacute; voc&ecirc; que define, mas &eacute;
recomend&aacute;vel dar ao operador um significado pr&oacute;ximo ao j&aacute;
definido na linguagem. Por exemplo: o operador + seria &oacute;timo para
representar a concatena&ccedil;&atilde;o de  dois objetos do tipo string. A
sintaxe de cada operador &eacute; fixa: n&uacute;mero de operandos,
preced&ecirc;ncia... O leitor pode aprender melhor tais regras gravando ou
relendo os exemplos de sobrecarga de cada operador e modificando-os quando
necess&aacute;rio.<p>
<b></b><p>
<b>Exerc&iacute;cios: </b><p>
<b></b>1)Implemente sobrecarga do operador de adi&ccedil;&atilde;o para o
exemplo TAD fra&ccedil;&atilde;o apresentado em 1.2.1.4<p>
<p>
2)Crie um TAD string e sobrecarregue o operador + com o significado de
concatena&ccedil;&atilde;o.<p>
<p>
3)Leia os trechos onde h&aacute; sobrecarga de operador, mas sem uso de friends
em 1.2.1.<p>
<a name="_Toc342736987"><a name="_Toc345409426"><a name="_Toc345810931"><a name="_Toc345838258"><a name="_Toc345942393"><a name="_Toc345949553"><a name="_Toc346168670"><a name="_Toc348417113"><a name="_Toc348931369"><a name="_Toc353900808"><a name="_Toc353946338">
<h2>
<a name="RTFToC48">3.2.
CLASSES ABSTRATAS E CONCRETAS</a></a></a></a></a></a></a></a></a></a></a>
</a></h2>
<a name="_Toc342736988"><a name="_Toc345409427"><a name="_Toc345810932"><a name="_Toc345838259"><a name="_Toc345942394"><a name="_Toc345949554"><a name="_Toc346168671"><a name="_Toc348417114"><a name="_Toc348931370"><a name="_Toc353900809"><a name="_Toc353946339">
<h3>
<a name="RTFToC49">3.2.1.
CLASSE ABSTRATA ITERADOR</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>Neste t&oacute;pico voc&ecirc; ver&aacute; que podem existir classes
que apenas definem protocolos ou interfaces para o uso e n&atilde;o podem ser
instanciadas, as classes filhas que herdam sua interface &eacute; que
s&atilde;o instanci&aacute;veis. <p>
	Neste exemplo vamos repetir o programa de 3.1.6, s&oacute; que iremos incluir
uma classe base abstrata para o iterador.<p>
	O iterador de vetor &eacute; definido por heran&ccedil;a<CODE> public
</CODE>da classe base abstrata de iteradores. Esta classe define o
protocolo, a interface de iteradores para listas e outras estruturas.<p>
	Perceba que algumas fun&ccedil;&otilde;es membro da classe base s&atilde;o
desprovidas de implementa&ccedil;&atilde;o, por&eacute;m nada impede que
voc&ecirc; coloque como c&oacute;digo dessas fun&ccedil;&otilde;es membro uma
mensagem de erro do tipo <CODE> "Erro, classe base n&atilde;o deve ser
instanciada!" </CODE>, como foi feito em alguns casos.<p>
<CODE><p>
<b><hr></b><p>
//exvetit6 , arquivo com definicoes do iterador.<p>
class iterador{  //classe base abstrata<p>
public:<p>
 int comeca(void)<p>
 {cout &lt;&lt; "Erro, classe abstrata!";}<p>
 float operator()()<p>
 {cout &lt;&lt; "Erro, classe abstrata!"; return 0;}<p>
 int operator!(void) {return 0;}<p>
 int operator ++() {return 0;}<p>
 void operator=(float entra) {;}<p>
 };<p>
<p>
class iteradorvetor:public iterador<p>
{<p>
private:<p>
		vetor vetorref;<p>
		int posicao;<p>
		//classe filha acrescentando dados membro<p>
public:<p>
	iteradorvetor(vetor &amp; v);<p>
	int comeca();<p>
	int operator!();<p>
	int operator ++ ();<p>
	float operator() ();<p>
	void operator= (float entra);<p>
	int pos();<p>
	//retorna posicao, n~ virtual pq n~ faz sentido p/ arvore por ex.<p>
	//esta e' uma funcao membro acrescentada pela classe filha<p>
	};<p>
<p>
int iteradorvetor::pos()<p>
{<p>
return posicao;<p>
}<p>
<p>
int iteradorvetor::operator!()<p>
{<p>
return posicao&lt;=vetorref.ultimo();<p>
}<p>
<p>
<p>
iteradorvetor::iteradorvetor(vetor &amp; vet):vetorref(vet)<p>
{<p>
comeca();<p>
}<p>
<p>
int iteradorvetor::comeca()<p>
{<p>
posicao=vetorref.primeiro();<p>
return operator!();<p>
}<p>
<p>
<p>
int iteradorvetor::operator ++()<p>
{<p>
posicao++;<p>
return operator!();<p>
}<p>
<p>
<p>
void iteradorvetor::operator=(float entra)<p>
{<p>
vetorref[posicao]=entra;<p>
}<p>
<p>
float iteradorvetor::operator() ()<p>
{<p>
float copia;<p>
copia=vetorref[posicao];<p>
return copia;<p>
}<p>
<b><hr></b><p>
</CODE><p>
Os demais arquivos s&atilde;o identicos aos do exemplo sobre vetores de 3.1.6.
<CODE><p>
<b><hr></b><p>
//header file para classe vetor<p>
#include &lt;iostream.h&gt;<p>
#include &lt;stdlib.h&gt; //exit(1)<p>
<p>
<p>
const int inicio=0; //inicio do vetor<p>
<p>
<p>
class vetor{<p>
private:<p>
float* v;  //pode ser qualquer tipo que atenda as operacoes &lt; &gt; =<p>
int tamanho;<p>
public:<p>
vetor (int tamanho) ;<p>
float&amp; operator[] (int i);<p>
float maximo();   //acha o valor maximo do vetor<p>
int primeiro(void);<p>
int ultimo(void);<p>
};<p>
<p>
vetor::vetor (int tam)<p>
{v=new float[tam]; tamanho=tam;}<p>
<p>
int vetor::primeiro (void)<p>
{return inicio;}<p>
<p>
int vetor::ultimo (void)<p>
{return tamanho-1;}<p>
<p>
float&amp; vetor::operator[](int i)<p>
{<p>
 if (i&lt;0 || i&gt;=tamanho)<p>
 {cout &lt;&lt; "Fora dos limites! Exit program"; exit(1);}<p>
 return v[i];<p>
}<p>
<p>
float vetor:: maximo(void)<p>
{int candidato=inicio;<p>
 for (int i=inicio;i&lt;tamanho;i++)<p>
 if (v[i]&gt;v[candidato]) candidato=i;<p>
 return v[candidato];}<p>
<p>
<b><hr></b><p>
<p>
#include &lt;iostream.h&gt;<p>
#include "exvet6.h"<p>
#include "exvetit6.h"<p>
main()<p>
{<p>
int repete=0;<p>
int ind;<p>
float item;<p>
vetor meu(5);<p>
iteradorvetor itmeu(meu);<p>
<p>
for (itmeu.comeca();!itmeu;++itmeu)<p>
{<p>
 cout &lt;&lt; "Entre com valor da posicao:" &lt;&lt; itmeu.pos() &lt;&lt;
"\n";<p>
 cin &gt;&gt; item;<p>
 itmeu=item;<p>
}<p>
<p>
for (itmeu.comeca();!itmeu;++itmeu) cout&lt;&lt; itmeu()&lt;&lt; " ";<p>
cout &lt;&lt; "\nEntre com o indice da posicao a atualizar:\n";<p>
cin &gt;&gt; ind;<p>
cout &lt;&lt; "Entre com o valor a incluir:";<p>
cin  &gt;&gt; item;<p>
meu[ind]=item;<p>
<p>
for (int k=meu.primeiro();k&lt;=meu.ultimo();k++) cout&lt;&lt; meu[k]&lt;&lt; "
";<p>
cout &lt;&lt;endl &lt;&lt; "Maximo:" &lt;&lt; meu.maximo();<p>
<p>
<p>
return 0;<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b> Resultado do programa:</b><p>
<b></b>Entre com valor da posicao:0<p>
2<p>
Entre com valor da posicao:1<p>
35<p>
Entre com valor da posicao:2<p>
82<p>
Entre com valor da posicao:3<p>
2<p>
Entre com valor da posicao:4<p>
3<p>
2 35 82 2 3<p>
Entre com o indice da posicao a atualizar:<p>
0<p>
Entre com o valor a incluir:1<p>
1 35 82 2 3<p>
Maximo:82<b></b><p>
<b></b>
<a name="_Toc342736989"><a name="_Toc345409428"><a name="_Toc345810933"><a name="_Toc345838260"><a name="_Toc345942395"><a name="_Toc345949555"><a name="_Toc346168672"><a name="_Toc348417115"><a name="_Toc348931371"><a name="_Toc353900810"><a name="_Toc353946340">
<h3>
<a name="RTFToC50">3.2.2.
ACOPLAMENTO DE MENSAGENS</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
	J&aacute; dissemos que um objeto de uma classe filha garante no m&iacute;nimo
o comportamento "behaviour" de seu pai. Por este motivo podemos atribuir um
objeto da classe filha a uma vari&aacute;vel da classe pai, mas n&atilde;o o
contr&aacute;rio. <p>
	Acoplamento din&acirc;mico mostrar&aacute; que &eacute; poss&iacute;vel fazer
com que o compilador execute a implementa&ccedil;&atilde;o desejada de uma
fun&ccedil;&atilde;o membro redefinida para classes herdeiras, mesmo no caso de
chamada de fun&ccedil;&atilde;o membro para uma vari&aacute;vel de um supertipo
(classe pai) contendo um objeto de um subtipo (classe filha). Isto nos
permitir&aacute; construir listas hetorog&ecirc;neas 3.2.4.<b>
<a name="_Toc342736990"><a name="_Toc345838261"><a name="_Toc345942396"><a name="_Toc345949556"><a name="_Toc346168673"><a name="_Toc348417116"><a name="_Toc348931372"><a name="_Toc353900811"><a name="_Toc353946341"></b>
<h4>
<a name="RTFToC51">3.2.2.1.
CASO EST&Aacute;TICO</a></a></a></a></a></a></a></a></a>
</a></h4>
<CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
class pai {<p>
public:<p>
void print(void)<p>
{cout &lt;&lt; "Sou da classe pai"&lt;&lt;endl;}<p>
};<p>
<p>
class filho:public pai<p>
{<p>
private:<p>
public:<p>
void print(void)<p>
{cout &lt;&lt; "Sou da classe filha" &lt;&lt; endl;}<p>
};<p>
<p>
void main()<p>
{<p>
filho ef1;<p>
//estatica filho numero 1<p>
pai ep1;<p>
//estatica pai numero 1<p>
ef1.print();<p>
//variavel estatica contendo filho<p>
ep1.print();<p>
//variavel estatica  contendo pai<p>
ep1=ef1;<p>
//variavel estatica do tipo pai contendo filho convertido no pai<p>
ep1.print();<p>
}<p>
<b><hr></b><p>
</CODE><p>
<b>Diagrama das classes:</b><p>
<b></b><p>
<b></b><p>
	A classe filha garante no m&iacute;nimo o mesmo comportamento, "behaviour" que
a classe pai, podendo acrescentar ou redefinir parte do que foi herdado. Por
este motivo, uma vari&aacute;vel da classe pai pode receber um objeto da classe
filha, o comportamento da classe pai fica garantido e o restante (o que a
classe filha acrescentou) &eacute; perdido. J&aacute; uma vari&aacute;vel da
classe filha n&atilde;o pode receber um objeto da classe pai, porque as
fun&ccedil;&otilde;es membro acrescentadas passam a n&atilde;o fazer sentido.<p>
<p>
<b>Resultado do programa:</b><p>
<b></b>Sou da classe filha<p>
Sou da classe pai<p>
Sou da classe pai<p>
<p>
<b>Explica&ccedil;&atilde;o do programa, passo a passo:</b><p>
<b></b><CODE>filho ef1; </CODE><p>
<p>
Declara&ccedil;&atilde;o de uma vari&aacute;vel da classe filha.<p>
<CODE><p>
pai ep1;<p>
</CODE><p>
Declara&ccedil;&atilde;o de uma vari&aacute;vel da classe pai, menor ou igual
quantidade de membros que a filha.<p>
<CODE><p>
ef1.print();<p>
</CODE><p>
Mostra a fun&ccedil;&atilde;o da classe filha, a qual pertence<CODE>
ef1</CODE> e seu conte&uacute;do.<p>
<CODE><p>
ep1.print();<p>
</CODE><p>
Mostra a fun&ccedil;&atilde;o da classe de<CODE> ep1</CODE> que
&eacute; a classe pai.<p>
<CODE><p>
ep1=ef1;<p>
</CODE><p>
Atribui o conte&uacute;do de<CODE> ef1 </CODE>a<CODE>
ep1</CODE>, ou seja atribui um filho a um pai. O filho tem os dados
membros e fun&ccedil;&otilde;es membros acrescentados,  descartados e se torna
do tipo pai. Essa convers&atilde;o &eacute; irrevers&iacute;vel no caso.<p>
<CODE><p>
ep1.print();<p>
</CODE><p>
Mostra a fun&ccedil;&atilde;o da classe de ep1 que &eacute; a classe pai, a
mesma de seu conte&uacute;do.<p>
<a name="_Toc342736991"><a name="_Toc345838262"><a name="_Toc345942397"><a name="_Toc345949557"><a name="_Toc346168674"><a name="_Toc348417117"><a name="_Toc348931373"><a name="_Toc353900812"><a name="_Toc353946342">
<h4>
<a name="RTFToC52">3.2.2.2.
DIN&Acirc;MICO SEM VIRTUAL</a></a></a></a></a></a></a></a></a>	
</a></h4>
<CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
class pai {<p>
public:<p>
void print(void)<p>
{cout &lt;&lt; "Sou da classe pai"&lt;&lt;endl;}<p>
};<p>
<p>
class filho:public pai<p>
{<p>
private:<p>
public:<p>
void print(void)<p>
{cout &lt;&lt; "Sou da classe filha" &lt;&lt; endl;}<p>
};<p>
<p>
void main()<p>
{<p>
filho ef1;<p>
//estatica filho numero 1<p>
pai ep1;<p>
//estatica pai numero 1<p>
pai* pp1;<p>
//ponteiro pai numero 1<p>
ef1.print();<p>
//variavel estatica contendo filho<p>
ep1.print();<p>
//variavel estatica  contendo pai<p>
pp1=&amp;ep1;<p>
pp1-&gt;print();<p>
//ponteiro de pai,apontando para pai<p>
<p>
pp1=&amp;ef1;<p>
pp1-&gt;print();<p>
//ponteiro de pai apontando para filho<p>
<p>
ep1=ef1;<p>
//variavel estatica do tipo pai contendo filho convertido no pai<p>
ep1.print();<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Resultado do programa:</b><p>
<b></b>Sou da classe filha<p>
Sou da classe pai<p>
Sou da classe pai<p>
Sou da classe pai<p>
Sou da classe pai<p>
<p>
<b>Coment&aacute;rios:</b><p>
<b>	</b>Note que a fun&ccedil;&atilde;o membro executada &eacute; escolhida de
acordo que a vari&aacute;vel e n&atilde;o de acordo com o conte&uacute;do
desta, da mesma forma que no exemplo anterior.<p>
<a name="_Toc342736992"><a name="_Toc345838263"><a name="_Toc345942398"><a name="_Toc345949558"><a name="_Toc346168675"><a name="_Toc348417118"><a name="_Toc348931374"><a name="_Toc353900813"><a name="_Toc353946343">
<h4>
<a name="RTFToC53">3.2.2.3.
DIN&Acirc;MICO COM VIRTUAL</a></a></a></a></a></a></a></a></a>
</a></h4>
<CODE><p>
<b><hr></b><p>
<b></b>#include &lt;iostream.h&gt;<p>
<p>
class pai {<p>
public:<p>
virtual void print(void)<p>
{cout &lt;&lt; "Sou da classe pai"&lt;&lt;endl;}<p>
};<p>
<p>
class filho:public pai<p>
{<p>
private:<p>
public:<p>
virtual void print(void)<p>
{cout &lt;&lt; "Sou da classe filha" &lt;&lt; endl;}<p>
};<p>
<p>
void main()<p>
{<p>
filho ef1;<p>
//estatica filho numero 1<p>
pai ep1;<p>
//estatica pai numero 1<p>
pai* pp1;<p>
//ponteiro pai numero 1<p>
ef1.print();<p>
//variavel estatica contendo filho<p>
ep1.print();<p>
//variavel estatica  contendo pai<p>
pp1=&amp;ep1;<p>
pp1-&gt;print();<p>
//ponteiro de pai,apontando para pai<p>
<p>
pp1=&amp;ef1;<p>
pp1-&gt;print();<p>
//ponteiro de pai apontando para filho<p>
<p>
ep1=ef1;<p>
//variavel estatica do tipo pai contendo filho convertido no pai<p>
ep1.print();<p>
}<b></b><p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Resultado do programa:</b><p>
<b></b>Sou da classe filha<p>
Sou da classe pai<p>
Sou da classe pai<p>
Sou da classe filha<p>
Sou da classe pai<p>
<p>
<b>Coment&aacute;rios:</b><p>
<b>	</b>Perceba que<CODE> virtual </CODE>faz com que a
fun&ccedil;&atilde;o membro a executar seja escolhida de acordo com o
conte&uacute;do da vari&aacute;vel ou ponteiro e n&atilde;o de acordo com o
tipo da vari&aacute;vel ou ponteiro (reposit&oacute;rios). <CODE>Virtual
</CODE>n&atilde;o tem efeito no uso est&aacute;tico de objetos, ou seja a
fun&ccedil;&atilde;o membro ser&aacute; escolhida de arcordo com o tipo da
vari&aacute;vel (reposit&oacute;rio).<p>
<b></b><p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1)Implemente em suas classes fun&ccedil;&otilde;es membro que imprimem
uma frase identificando o tipo da classe, por exemplo: "Eu sou a classe conta
corrente, especializa&ccedil;&atilde;o de conta bancaria."<p>
<a name="_Toc342736993"><a name="_Toc345409429"><a name="_Ref345758318"><a name="_Toc345810934"><a name="_Toc345838264"><a name="_Toc345942399"><a name="_Toc345949559"><a name="_Toc346168676"><a name="_Toc348417119"><a name="_Toc348931375"><a name="_Toc353900814"><a name="_Toc353946344">
<h3>
<a name="RTFToC54">3.2.3.
CONTAS BANC&Aacute;RIAS</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
	Neste programa exemplo vamos definir uma classe abstrata chamada conta. Esta
classe define a interface de contas banc&aacute;rias, que se constitui das
opera&ccedil;&otilde;es: <CODE>deposita, saca, get_saldo,  get_jurosn
</CODE> (juros quando saldo est&aacute; negativo), <CODE>get_jurosp
</CODE> (juros quando o saldo est&aacute; positivo) e
<CODE>computa</CODE> (calcula juros). Todos as
fun&ccedil;&otilde;es membro s&atilde;o  "virtuais" exceto destrutor .<p>
<b></b><p>
<b></b>	Preste aten&ccedil;&atilde;o nas especifica&ccedil;&otilde;es a seguir
elas s&atilde;o detalhadas e important&iacute;ssimas para o entendimento do
programa:<p>
Da classe base abstrata descrita acima, criamos duas classes concretas com as
seguintes propriedades:<p>
	1-Conta corrente:<p>
		-Neste tipo de conta as computa&ccedil;&otilde;es dos juros s&atilde;o feitas
pelo banco diariamente.<p>
		-Permite taxa de juros diferente para saldos negativos e positivos.<p>
		-Possui um atributo menor que zero chamado <b>limite</b>. Saques que levem o
saldo abaixo deste valor s&atilde;o recusados. Esta defini&ccedil;&atilde;o
acima n&atilde;o implica que o saldo tenha que  estar sempre acima de
<b>limite</b>. Ele s&oacute; vai  para valores menores que  se os juros da
d&iacute;vida o fizerem e n&atilde;o o cliente.<p>
		 -O valor de<b> limite</b> &eacute; definido na cria&ccedil;&atilde;o da
conta, instancia&ccedil;&atilde;o.<p>
		-Fica claro que este tipo de conta permite saldos negativos.	 <p>
	.	-A taxa de juros para  saldo positivo &eacute; zero ou seja, n&atilde;o
h&aacute; rendimento.<p>
<p>
	2-Poupan&ccedil;a:<p>
		-Possui uma data de anivers&aacute;rio, s&oacute; neste dia &eacute; que se
computa juros ou seja mensalmente.<p>
		-Os juros acrescentados s&atilde;o referentes ao saldo ap&oacute;s a
&uacute;ltima computa&ccedil;&atilde;o, isto significa que dep&oacute;sitos
intermedi&aacute;rios n&atilde;o rendem juros.<p>
		-Se houver algum saque que n&atilde;o seja no dia da computa&ccedil;&atilde;o
os juros referentes a aquele m&ecirc;s s&atilde;o cancelados.<p>
		-S&oacute; &eacute; permitido saldo maior ou igual a zero.<p>
<b></b><p>
<b>	</b>Outra classe foi criada no programa: a classe data que armazena datas
quaisquer. Por quest&otilde;es de simplicidade a classe data que &eacute;
simplesmente uma classe auxiliar foi implementada com o m&iacute;nimo
necess&aacute;rio para o funcionamento e demonstra&ccedil;&atilde;o do
programa. A melhoria desta classe &eacute; sugerida como exerc&iacute;cio.<p>
<p>
T&oacute;picos abordados: Fun&ccedil;&otilde;es membro virtual e pure virtual.
Objetos constantes.<p>
<CODE><b>	</b><p>
<b><hr></b><p>
<b></b>//header file for conta.h<p>
//todas as funcoes recebem uma data porque o extrato presisa disso.<p>
const float jp=.05; /*juros padrao*/<p>
const float  vazio=0.0;<p>
const float  jnulo=0.0;<p>
const float lmin=-400.0;<p>
<p>
enum Boolean{FALSE,TRUE};<p>
typedef float dinh;<p>
<p>
float abs(float a); //funcao valor absoluto<p>
<p>
class data{ //definir outras operacoes elaborar mais<p>
private:<p>
	int dia;<p>
	int mes;<p>
	int ano;<p>
public:<p>
	data() {dia=1;mes=1;ano=95;} //default constructor, importante para
agregacao<p>
	data(int d,int m,int a) {dia=d;mes=m;ano=a;}<p>
	int get_dia(void) {return dia;}<p>
	int get_mes(void) {return mes;}<p>
	int get_ano(void) {return ano;}<p>
	};<p>
<p>
const data ddef(1,1,90);  //objeto constante;<p>
<p>
<p>
class conta{ //pure virtual functions in abstract base class<p>
protected:<p>
dinh saldo;  //esse e' o dinheiro na conta.<p>
float jurosp; //juros p/ saldo positivo<p>
float jurosn; //juros p/ saldo negativo<p>
<p>
public:<p>
//pure virtual functions in abstract base class<p>
conta (dinh quantia=vazio,float taxap=jp,float taxan=jp,data dd=ddef);<p>
virtual Boolean computa(data dd)=0; //computa juros da conta<p>
virtual dinh get_saldo(data dd)const=0; //retorna conteudo da conta<p>
virtual float get_jurosn(data dd)const=0; //criar as respectivas funcoes set:
set_juros<p>
virtual float get_jurosp(data dd)const=0;<p>
virtual Boolean deposita(dinh quantia,data dd)=0;<p>
virtual dinh saca(dinh quantia,data dd)=0;<p>
~conta(){};<p>
};<p>
<p>
<p>
class contacorrente:public conta{<p>
private:<p>
dinh lim; //saques que levam saldo para baixo deste limite sao bloqueados.<p>
public:<p>
 contacorrente(dinh quantia=vazio,float taxan=jp,dinh min=lmin,data dd=ddef);
//so computa qdo neg.<p>
 Boolean computa(data dd); //para esse tipo de conta e' diario. (poupanca
mensal)<p>
 dinh get_saldo(data dd)const; //retorna conteudo da conta<p>
 float get_jurosn(data dd)const; //criar as respectivas funcoes set:
set_juros<p>
 float get_jurosp(data dd)const;<p>
 Boolean deposita(dinh quantia,data dd);<p>
 dinh saca(dinh quantia,data dd);<p>
 ~contacorrente(){}; //pode deletar deque com operacoes sobre conta (extrato)<p>
 };<p>
<p>
<p>
class poupanca:public conta{<p>
private:<p>
 data aniversario; //dia do mes que a poupanca faz aniversario.<p>
 Boolean computar; //1:computar sobre ultimo, 0:rendimento perdido, saque<p>
 dinh ultimo; //os juros sao sobre o valor depois da ultima computacao.<p>
 //o que depositou nao importa, se sacou perdeu rendimento<p>
public:<p>
 poupanca(dinh quantia=vazio,float taxap=jp,data dd=ddef); //mensalmente<p>
 Boolean computa(data dd); // Boolean: Rendimento nao foi perdido?<p>
 dinh get_saldo(data dd)const; //retorna conteudo da conta<p>
 float get_jurosn(data dd)const; //criar as respectivas funcoes set:
set_juros<p>
 float get_jurosp(data dd)const;<p>
 Boolean deposita(dinh quantia,data dd);<p>
 dinh saca(dinh quantia,data dd);<p>
 ~poupanca(){}; //pode deletar deque com operacoes sobre conta (extrato)<p>
};<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//file conta.cpp<p>
#include "conta2.h"<p>
float abs(float a)<p>
{<p>
if  (a&lt;0.0) a=-a;<p>
return a;<p>
}<p>
<p>
conta::conta(dinh quantia,float taxap,float taxan,data dd)<p>
{<p>
saldo=abs(quantia);<p>
jurosp=abs(taxap);<p>
jurosn=abs(taxan);<p>
}<p>
<p>
poupanca::poupanca(dinh quantia,float taxap,data dd):<p>
conta(quantia,taxap,jnulo,dd)<p>
{aniversario=dd; computar=TRUE; ultimo=abs(quantia);};<p>
<p>
Boolean poupanca::computa(data dd)<p>
{<p>
if (aniversario.get_dia()==dd.get_dia())<p>
  if (computar)  {saldo=ultimo*jurosp+saldo;return TRUE;}<p>
  else { computar=TRUE; ultimo=abs(saldo); }<p>
<p>
return FALSE;<p>
}<p>
<p>
dinh poupanca::get_saldo(data dd)const<p>
{return saldo;}<p>
<p>
<p>
float poupanca::get_jurosp(data dd)const<p>
{ return jurosp; }<p>
<p>
float poupanca::get_jurosn(data dd)const<p>
{ return jurosn; }<p>
<p>
Boolean poupanca::deposita(dinh quantia,data dd)<p>
{ saldo+=abs(quantia);<p>
  return TRUE;}<p>
<p>
dinh poupanca::saca(dinh quantia,data dd)<p>
{<p>
 if ((saldo-abs(quantia))&gt;vazio)<p>
	{saldo-=abs(quantia); computar=FALSE; return quantia;}<p>
 else return vazio;<p>
}<p>
<p>
contacorrente::contacorrente(dinh quantia,float taxan,dinh min,data dd):<p>
conta(quantia,jnulo,taxan,dd)<p>
{if (min&lt;vazio) lim=min; else lim=-min;}<p>
<p>
Boolean contacorrente::computa(data dd) //so computo juros negativos.<p>
{<p>
if (saldo&lt;vazio) saldo=saldo*jurosn+saldo;<p>
else saldo=saldo*jurosp+saldo;<p>
return TRUE;<p>
}<p>
<p>
dinh contacorrente::get_saldo(data dd) const<p>
{return saldo;}<p>
<p>
float contacorrente::get_jurosn(data dd) const<p>
{return jurosn;}<p>
<p>
float contacorrente::get_jurosp(data dd) const<p>
{return jurosp;}<p>
<p>
Boolean contacorrente::deposita(dinh quantia,data dd)<p>
{<p>
saldo+=quantia;<p>
return TRUE;<p>
}<p>
<p>
dinh contacorrente::saca(dinh quantia,data dd)<p>
{<p>
quantia=abs(quantia);<p>
if ((saldo-quantia)&gt;lim)<p>
{ saldo-=quantia; return quantia;}<p>
else return vazio;<p>
}<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//main file.<p>
#include &lt;iostream.h&gt;<p>
#include "conta2.h"<p>
<p>
main()<p>
{<p>
data hoje(6,10,95);<p>
contacorrente minhacc(1340.34,0.1,-500.0,hoje);<p>
poupanca minhap(1500.00,0.1,hoje);<p>
<p>
cout &lt;&lt; "Saldo:" &lt;&lt;minhacc.get_saldo(hoje)&lt;&lt;endl;<p>
minhacc.deposita(10.00,hoje);<p>
cout &lt;&lt; "Saldo apos depositar
10.00:"&lt;&lt;minhacc.get_saldo(hoje)&lt;&lt;endl;<p>
minhacc.computa(hoje);<p>
cout &lt;&lt; "Saldo apos computar:"
&lt;&lt;minhacc.get_saldo(hoje)&lt;&lt;endl;<p>
minhacc.saca(1500.00,hoje);<p>
cout &lt;&lt; "Saldo apos sacar:" &lt;&lt;
minhacc.get_saldo(hoje)&lt;&lt;endl;<p>
minhacc.computa(hoje);<p>
cout &lt;&lt; "Saldo apos computar:" &lt;&lt; minhacc.get_saldo(hoje)
&lt;&lt;endl;<p>
cout &lt;&lt; "Taxa de juros:" &lt;&lt; minhacc.get_jurosn(hoje)&lt;&lt;endl;<p>
cout &lt;&lt; endl;<p>
cout &lt;&lt; "Agora a poupanca:";<p>
cout &lt;&lt; "Saldo apos criacao:" &lt;&lt; minhap.get_saldo(hoje) &lt;&lt;
endl;<p>
cout &lt;&lt; "Juros de saldo positivo:" &lt;&lt;
minhap.get_jurosp(hoje)&lt;&lt; endl;<p>
cout &lt;&lt; "Computando:" &lt;&lt; endl;<p>
minhap.computa(hoje) ;<p>
cout &lt;&lt; "Saldo apos computa:" &lt;&lt; minhap.get_saldo(hoje) &lt;&lt;
endl;<p>
cout &lt;&lt; "Retirando 500.00:" &lt;&lt;endl;<p>
minhap.saca(500.00,hoje) ;<p>
cout &lt;&lt; "Saldo apos retirada:" &lt;&lt; minhap.get_saldo(hoje) &lt;&lt;
endl;<p>
cout &lt;&lt; "Computando:"&lt;&lt;endl;<p>
minhap.computa(hoje);<p>
cout &lt;&lt; "Saldo apos computa:" &lt;&lt; minhap.get_saldo(hoje) &lt;&lt;
endl;<p>
cout &lt;&lt; "Depositando100 e Computando:"&lt;&lt;endl;<p>
minhap.deposita(100.00,hoje);<p>
minhap.computa(hoje);<p>
cout &lt;&lt; "Saldo apos computa:" &lt;&lt; minhap.get_saldo(hoje) &lt;&lt;
endl;<p>
cout &lt;&lt; "Retirando mais do que pode:2000.00" &lt;&lt; endl;<p>
minhap.saca(2000.00,hoje);<p>
cout &lt;&lt; "Saldo apos saca 2000.00:" &lt;&lt; minhap.get_saldo(hoje)
&lt;&lt; endl;<p>
return 0;<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Resultado de teste do programa:</b><p>
<b></b>Saldo:1340.34<p>
Saldo apos depositar 10.00:1350.34<p>
Saldo apos computar:1350.34<p>
Saldo apos sacar:-149.66<p>
Saldo apos computar:-164.626<p>
Taxa de juros:0.1<p>
<p>
Agora a poupanca:Saldo apos criacao:1500<p>
Juros de saldo positivo:0.1<p>
Computando:<p>
Saldo apos computa:1650<p>
Retirando 500.00:<p>
Saldo apos retirada:1150<p>
Computando:<p>
Saldo apos computa:1150<p>
Depositando100 e Computando:<p>
Saldo apos computa:1365<p>
Retirando mais do que pode:2000.00<p>
Saldo apos saca 2000.00:1365<p>
<p>
<b>Coment&aacute;rios: </b><p>
<b>	</b>Observe que objetos da classe base n&atilde;o podem ser criados,
voc&ecirc; n&atilde;o pode ter um objeto instanciado, mas ela pode ser usada.
Declarar um ponteiro: <CODE>conta* </CODE>, n&atilde;o significa
criar um objeto. Esse ponteiro pode referenciar qualquer objeto da hierarquia
(conta corrente , poupan&ccedil;a) , veremos seu uso mais tarde.<p>
<b></b><p>
<b>Curiosidade:</b><p>
<b>	</b>Veja a import&acirc;ncia da cria&ccedil;&atilde;o de componentes de
software seguros, de f&aacute;cil modifica&ccedil;&atilde;o e
reutiliz&aacute;veis:<p>
	Muitos programas que tinham que fazer uma representa&ccedil;&atilde;o de datas
est&atilde;o sendo revistos devido a mudan&ccedil;a do s&eacute;culo e outros
provavelmente falhar&atilde;o devido a esta mudan&ccedil;a. Seja pela
restri&ccedil;&atilde;o da faixa de valores de anos com m&aacute;ximo em 2000
ou mesmo por outros motivos que n&atilde;o levassem este fator em conta, como a
subtra&ccedil;&atilde;o entre dois anos distintos exemplo 2001 e 1999
armazenados na forma 01 e 99.<b></b><p>
<b></b>	O exerc&iacute;cio  5 pede que voc&ecirc; melhore a classe data
apresentada neste exemplo. Com um pouquinho de pesquisa voc&ecirc; pode criar
meios de checar anos bissextos (%4), meses com n&uacute;meros de dias
diferentes e "viradas" de s&eacute;culo.<p>
<b></b><p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1)Voc&ecirc; seria capaz de usando princ&iacute;pios de
agrega&ccedil;&atilde;o implementar uma estrutura de armazenamento (lista,
vetor) na classe conta e us&aacute;-la para salvar as opera&ccedil;&otilde;es
de modo que esta estrutura representasse o extrato? De que modo esta
id&eacute;ia pode ser adaptada para criar estruturas que fazem um
hist&oacute;rico das fun&ccedil;&otilde;es membro chamadas para classes
quaisquer? Voc&ecirc; pode usar este tipo de informa&ccedil;&atilde;o da classe
de armazenagem para debugar seus programas? <p>
<b></b><p>
<b></b>*2)Porque n&atilde;o houve preocupa&ccedil;&atilde;o de esconder
fun&ccedil;&otilde;es membro como<CODE> computa</CODE>?
Algu&eacute;m poderia computar juros infinitamente em sua pr&oacute;pria
conta..... Para responder pense no seguinte: Uma pessoa &eacute; cliente de uma
conta ou de um banco? Um banco mant&eacute;m uma conta ou uma pessoa
mant&eacute;m uma conta? Monte um diagrama de objetos contendo um banco,
v&aacute;rias contas , v&aacute;rias pessoas e as respectivas
associa&ccedil;&otilde;es.<p>
<b></b><p>
<b></b>3)Modifique este programa, implemente outros tipos de contas que
voc&ecirc; conhece.<p>
<b></b><p>
<b></b>4)Ap&oacute;s ler o t&oacute;pico de tratamento de
exce&ccedil;&otilde;es, adicione "exception handling" para argumentos
inv&aacute;lidos tipo <CODE>minhaconta.deposita(-10.3) </CODE> !<p>
<b></b><p>
<b></b>5)Modifique a classe data, crie restri&ccedil;&otilde;es para datas
inv&aacute;lidas e outras fun&ccedil;&otilde;es membro que julgar importantes
como<CODE>: print_data().</CODE> Veja coment&aacute;rio neste
exemplo.<p>

<h3>
<a name="RTFToC55">3.2.4.
<a name="_Toc342736994"><a name="_Toc345409430"><a name="_Ref345753421"><a name="_Toc345810935"><a name="_Toc345838265"><a name="_Toc345942400"><a name="_Toc345949560"><a name="_Toc346168677"><a name="_Toc348417120"><a name="_Toc348931376"><a name="_Toc353900815"><a name="_Toc353946345">
LISTA HETEROG&Ecirc;NEA DE CONTAS
BANC&Aacute;RIAS.</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>Lista heterog&ecirc;nea de contas banc&aacute;rias de exemplo anterior,
obten&ccedil;&atilde;o do saldo total das contas corrente e poupan&ccedil;as da
lista (no caso vetor).<p>
<p>
<b>T&oacute;picos abordados: </b><p>
<b>	"</b>Dynamic binding", n&atilde;o aborda type casting, vai ser abordado num
programa mais completo: a simula&ccedil;&atilde;o dirigida a eventos de 4.6.2
.<p>
<CODE><p>
<b><hr></b><p>
<b></b>//programa principal<p>
#include &lt;iostream.h&gt;<p>
#include "conta2.h" ///<p>
const int tamanho=3;<p>
main()<p>
{<p>
dinh soma=0.0;<p>
contacorrente cc1(500.00,0.1,-400); //SALDO,JUROS,LIMITE NEG<p>
contacorrente cc2(500.00,0.15,-400);<p>
poupanca p1(500.00,0.1);  //SALDO, JUROS<p>
<p>
conta* lheterogenea[tamanho]={&amp;cc1,&amp;cc2,&amp;p1};  //lista
heterogenea<p>
for (int i=0;i&lt;tamanho;i++) soma+=lheterogenea[i]-&gt;get_saldo(ddef);<p>
cout &lt;&lt; "Total armazenado nas contas:" &lt;&lt; soma &lt;&lt;endl;<p>
return 0;<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Exerc&iacute;cios: </b><p>
<b></b>1)Melhore o exemplo de lista heterog&ecirc;nea dado  usando uma lista
com "templates" de 4.3.Voc&ecirc; deve definir a lista para trabalhar com
ponteiros de contas.<p>
<b></b><p>
<b></b>2) Considere as seguintes declara&ccedil;&otilde;es em C++:<p>
<CODE><b></b><p>
<b></b>class T<p>
{<p>
public:<p>
virtual void f(void) {cout &lt;&lt; "Estou em T";}<p>
};<p>
<p>
class S:public T<p>
{<p>
public:<p>
virtual void f(void) {cout &lt;&lt; "Estou em S";}<p>
};<p>
<p>
T x;<p>
//variavel est&aacute;tica<p>
S y;<p>
//variavel estatica, s de subclasse<p>
T* p;<p>
//apontador para tipo base t.<b></b><p>
<b></b></CODE><b></b><p>
<b></b>e as seguintes invoca&ccedil;&otilde;es de opera&ccedil;&otilde;es:<p>
<CODE><p>
p=&amp;x ;<p>
p-&gt;f(); //primeira<p>
p=&amp;y;<p>
p-&gt;f(); //segunda<p>
x.f(); //terceira<p>
y.f(); //quarta<p>
x=y;<p>
x.f() //quinta</CODE><b></b><p>
<b></b>Responda qual &eacute; o resultado na tela de cada uma destas chamadas.
<a name="_Toc342736995"><a name="_Toc345409431"><a name="_Toc345810936"><a name="_Toc345838266"><a name="_Toc345942401"><a name="_Toc345949561"><a name="_Toc346168678"><a name="_Toc348417121"><a name="_Toc348931377"><a name="_Toc353900816"><a name="_Toc353946346">
<h1>
<a name="RTFToC56">4.
T&Oacute;PICOS AVAN&Ccedil;ADOS</a></a></a></a></a></a></a></a></a></a></a>
</a></h1>
<p>
<b>	</b>T&oacute;picos avan&ccedil;ados apresenta recursos extremamente
&uacute;teis para programa&ccedil;&atilde;o orientada a objetos, por isso
conv&eacute;m ler este t&oacute;pico somente quando voc&ecirc; tiver uma boa
base de programa&ccedil;&atilde;o C++. Adquira pr&aacute;tica. <b></b><p>
<b>	</b>A ordem em que os exemplos s&atilde;o apresentados &eacute; semelhante
a ordem de t&oacute;picos inicial. Como t&oacute;pico avan&ccedil;ado de
Encapsulamento temos<CODE> friends</CODE>, como t&oacute;pico
avan&ccedil;ado de heran&ccedil;a temos heran&ccedil;a m&uacute;ltipla, como
t&oacute;pico avan&ccedil;ado de polimorfismo, temos polimorfismo
param&eacute;trico. Os demais t&oacute;picos n&atilde;o est&atilde;o
diretamente relacionados com os anteriores.<p>
<b>
<a name="_Ref342220816"><a name="_Toc342736996"><a name="_Toc345409432"><a name="_Toc345810937"><a name="_Toc345838267"><a name="_Toc345942402"><a name="_Toc345949562"><a name="_Toc346168679"><a name="_Toc348417122"><a name="_Toc348931378"><a name="_Toc353900817"><a name="_Toc353946347"></b>
<h2>
<a name="RTFToC57">4.1.
FRIENDS</a></a></a></a></a></a></a></a></a></a></a></a>	
</a></h2>
<b></b><p>
<b>	</b><CODE>Friends </CODE>permite que uma classe toda ou uma
fun&ccedil;&atilde;o membro acesse atributos encapsulados de outra classe. Por
este motivo, <CODE>friends</CODE> representa uma quebra do
encapsulamento e  deve portanto ser usado com muita cautela. N&atilde;o raro
programadores descobrem que o uso de certos princ&iacute;pios de
orienta&ccedil;&atilde;o a objetos evita programar usando
demasiadamente<CODE> friends</CODE>. Se voc&ecirc; vai aplicar este
recurso, analise bem as outras possibilidades, cheque outras abordagens
antes.<b></b><p>
<b>	</b>Novamente nos deparamos com um qualificador ou "specifier", mas este
tem uma diferen&ccedil;a, n&atilde;o basta dizer que uma classe ou
fun&ccedil;&atilde;o membro &eacute; amiga, <CODE>"friend", </CODE>
&eacute; preciso dizer de que classe ela &eacute; amiga<p>
	<CODE>Friends</CODE> &eacute; muito usado em conjunto com
operadores. Operadores s&atilde;o frequentemente usados para implementar
opera&ccedil;&otilde;es entre tipos enquanto que fun&ccedil;&otilde;es membro
comuns s&atilde;o mais usadas para passagem de mensagens alterando o estado de
um &uacute;nico objeto, segundo alguns par&acirc;metros, normalmente tipos
simples.<p>
<a name="_Toc342736997"><a name="_Toc345409433"><a name="_Toc345810938"><a name="_Toc345838268"><a name="_Toc345942403"><a name="_Toc345949563"><a name="_Toc346168680"><a name="_Toc348417123"><a name="_Toc348931379"><a name="_Toc353900818"><a name="_Toc353946348">
<h3>
<a name="RTFToC58">4.1.1.
UMA CLASSE PERMITINDO ACESSO A OUTRA</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
	Suponha que voc&ecirc; est&aacute; trabalhando em conjunto com um colega no
desenvolvimento de um software. Voc&ecirc; faz a interface gr&aacute;fica
enquanto que seu colega est&aacute; implementado as classes estritamente
usu&aacute;rias da interface gr&aacute;fica. <p>
	Como seu colega n&atilde;o sabe usar sua interface gr&aacute;fica ainda, ele
define algumas classes dele como <CODE>friends</CODE> de suas
classes de caixas de di&aacute;logos e janelas. Assim voc&ecirc; ganha acesso
as defini&ccedil;&otilde;es <CODE>private </CODE>e<CODE>
public</CODE> dele nas suas classes. Ele s&oacute; precisa perguntar a
voc&ecirc; quais os nomes das suas classes. <p>
	Como voc&ecirc; desconhece a implementa&ccedil;&atilde;o das classes de seu
colega, ele define pensando em voc&ecirc; e tamb&eacute;m por raz&otilde;es de
portabilidade, fun&ccedil;&otilde;es membro que retornam os dados membros mais
&uacute;teis aos usu&aacute;rios das classes. Por&eacute;m  estas
fun&ccedil;&otilde;es n&atilde;o retornam todos os dados membros porque alguns
objetos que ele est&aacute; definindo s&atilde;o estruturas de
aloca&ccedil;&atilde;o din&acirc;mica como &aacute;rvores e &eacute; muito
dif&iacute;cil prever que tipo de acesso ser&aacute; feito nas estruturas.<p>
	Este &eacute; o tema do exemplo seguinte, s&oacute; que n&atilde;o iremos
definir nenhuma interface gr&aacute;fica, vamos apenas usar<CODE>
cout</CODE> simulando uma sa&iacute;da de tela mais complicada, como por
exemplo numa caixa de dialogo. Nosso objeto n&atilde;o define estruturas de
aloca&ccedil;&atilde;o din&acirc;mica nenhuma, afinal o exemplo tem que ser
simples e objetivo.<p>
<CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
class relogio<p>
{<p>
friend class caixa_de_mensagem;<p>
//permitiu acesso as definicoes private e public<p>
private:<p>
 int hora;<p>
 int minuto;<p>
 int segundo;<p>
 //atributos private, encapsulados<p>
public:<p>
 relogio(int h,int m,int s)<p>
 {hora=h; minuto=m; segundo=s;}<p>
} ;<p>
<p>
class caixa_de_mensagem{<p>
public:<p>
void imprime(relogio a)<p>
{<p>
cout &lt;&lt; a.hora &lt;&lt; ":" &lt;&lt; a.minuto &lt;&lt; ":" &lt;&lt;
a.segundo &lt;&lt; endl;<p>
}<p>
} ;<p>
<p>
void main()<p>
{<p>
relogio meurolex(11,30,10);<p>
caixa_de_mensagem ativa;<p>
ativa.imprime(meurolex);<p>
}<p>
<b><hr></b><p>
</CODE><p>
<b>Resultado do programa:</b><p>
<b></b>11:30:10<p>
<p>
<b>Curiosidade: </b><p>
<b>	</b>Existem "libraries" em C++ que permitem programar em ambientes
gr&aacute;ficos como o Windows sem saber muitos detalhes. Estas "libraries"
definem objetos como caixas de dialogo, gerenciadores de eventos, etc. O uso
agora &eacute; diferente do descrito no exemplo: O programador s&oacute; vai
utilizar os recursos gr&aacute;ficos padr&atilde;o definidos pela "libraries".
Os objetos definidos para uso na interface gr&aacute;fica s&atilde;o agregados
ao seu programa e podem ser chamados de dentro das implementa&ccedil;&otilde;es
das fun&ccedil;&otilde;es membro das suas classes.<p>
<b></b><p>
<b>Exerc&iacute;cios:</b><p>
<b></b>*1)Defina um iterador para a  classe lista, assim como foi definido para
a classe vetor em 3.1.6. Voc&ecirc; provalvelmente ter&aacute; que usar
no&ccedil;&otilde;es de classes friends. Como evitar corromper o estado da
lista entre acessos a posi&ccedil;&otilde;es e incrementos do iterador
alternados? Uma sugest&atilde;o &eacute; proibir as fun&ccedil;&otilde;es
membro insere in&iacute;cio, insere &uacute;ltimo, enquanto se faz uso do
iterador. Este &eacute; um exerc&iacute;cio avan&ccedil;ado. Outra
sugest&atilde;o &eacute; derivar uma classe a partir da base da hierarquia, e
para esta classe definir o iterador.<p>
<b></b><p>
<b></b>2)Um bom exemplo de uso de friends &eacute; o seguinte: suponha uma
classe que representa uma reta em tr&ecirc;s dimens&otilde;es, e outra que
representa um plano. Use friends para criar em uma dessas classes, ou em ambas,
um a fun&ccedil;&atilde;o membro que determina o ponto de
interse&ccedil;&atilde;o entre uma reta e um plano. Se voc&ecirc; gosta de
computa&ccedil;&atilde;o gr&aacute;fica, ent&atilde;o existe uma s&eacute;rie
de tipos abstratos de dados que voc&ecirc; pode definir para construir seus
programas em C++.<p>
	Algu&eacute;m pode argumentar que a interse&ccedil;&atilde;o descrita acima
poderia ser obtida sem o uso de friends, isto porque os dados membros das
classes usados para calcular a interse&ccedil;&atilde;o poderiam ser lidos,
obtidos atrav&eacute;s de fun&ccedil;&otilde;es membro do tipo <CODE>:
get_x();</CODE>. Isto &eacute; verdade, mas em termos de
efici&ecirc;ncia, talvez n&atilde;o de encapsulamento friends &eacute; melhor.
Explique porque.<p>
<b></b><p>
<b></b>3) Voc&ecirc; se lembra do exemplo das contas banc&aacute;rias? Melhore
este programa implementado a fun&ccedil;&atilde;o de transfer&ecirc;ncia de
quantias entre contas, voc&ecirc; acha melhor defini-la como
<CODE>friend</CODE>? Porque? Quantas contas ela afeta?<p>
<p>
4)Defina a classe banco como <CODE>friend </CODE>de todas as
classes conta banc&aacute;ria. Muito bem, deixe como
<CODE>private</CODE> todos os m&eacute;todos que o dono da conta
sozinho n&atilde;o pode chamar, tais como<CODE> computa</CODE>. O
banco deve conter refer&ecirc;ncias para todas suas contas, as contas devem ter
um n&uacute;mero identificador de conta. As opera&ccedil;&otilde;es sobre
contas devem ser feitas agora via banco, isto n&atilde;o impede que as contas
atendam a opera&ccedil;&otilde;es usuais como deposita, mas elas tem quer ser
private agora.. Veja 3.2.3.<p>
<a name="_Ref342710920"><a name="_Toc342736998"><a name="_Toc345409434"><a name="_Toc345810939"><a name="_Toc345838269"><a name="_Toc345942404"><a name="_Toc345949564"><a name="_Toc346168681"><a name="_Toc348417124"><a name="_Toc348931380"><a name="_Toc353900819"><a name="_Toc353946349">
<h3>
<a name="RTFToC59">4.1.2.
OPERADORES E FRIENDS</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>Vamos tomar o exemplo do tipo abstrato de dados fra&ccedil;&atilde;o de
1.4.1 e acrescentar  sobrecarga de operador e fun&ccedil;&otilde;es friends.
Fica faltando somente tratamento de exce&ccedil;&otilde;es que &eacute;
sugerido como exerc&iacute;cio no cap&iacute;tulo respectivo.<p>
<b></b><p>
<b>T&oacute;picos abordados:</b><p>
<b>	</b>Sobrecarga de operador, "copy constructor" ,fun&ccedil;&otilde;es
friends. &Eacute; uma implementa&ccedil;&atilde;o bastante completa e
port&aacute;vel de um TAD, use como refer&ecirc;ncia para sintaxe de sobrecarga
de operadores.<b></b><p>
<b></b><CODE><p>
<b><hr></b><p>
<b></b>//Este programa implementa o tipo fracao.<p>
#ifndef OF_H<p>
//diretivas do compilador<p>
#define OF_H<p>
<p>
long mdc(long n,long d)<p>
 //maximo divisor comum<p>
//metodo de Euclides<p>
{<p>
 if (n&lt;0) n=-n;<p>
 if (d&lt;0) d=-d;<p>
 while (d!=0) {<p>
	long r=n % d;<p>
//   %=MOD<p>
	n=d;<p>
	d=r;<p>
	}<p>
	return n;<p>
};<p>
<p>
<p>
class fracao {<p>
	private:<p>
		long num;<p>
		long den;<p>
	public:<p>
		void simplifica(void);<p>
		//simplificacao<p>
		fracao(fracao &amp;t);<p>
		//copy constructor<p>
		fracao() {num=0; den=1;}<p>
		//construtor vazio.<p>
		fracao(const long t,const long m);<p>
		fracao(const long t) {num=t;den=1;}<p>
		~fracao() {};<p>
		//Nao precisa fazer nada<p>
		long get_num(void) {return num;}<p>
		long get_den(void) {return den;}<p>
<p>
//operacoes matematicas basicas<p>
		friend fracao operator+ (const fracao&amp; f,const fracao&amp; j);<p>
		friend fracao operator- (const fracao&amp; f,const fracao&amp; j);<p>
		friend fracao operator* (const fracao&amp; f,const fracao&amp; j);<p>
		friend fracao operator/ (const fracao&amp; f,const fracao&amp; j);<p>
<p>
//operadores de comparacao<p>
		friend int operator== (const fracao&amp; s,const fracao&amp; t);<p>
		friend int operator!= (const fracao&amp; s,const fracao&amp; t);<p>
		friend int operator&gt;= (const fracao&amp; s,const fracao&amp; t);<p>
		friend int operator&lt;= (const fracao&amp; s,const fracao&amp; t);<p>
		friend int operator&gt; (const fracao&amp; s,const fracao&amp; t);<p>
		friend int operator&lt; (const fracao&amp; s,const fracao&amp; t);<p>
<p>
//operadores de atribuicao<p>
	  fracao&amp; operator= (const fracao&amp; t);<p>
	  fracao&amp; operator+= (const fracao&amp; t);<p>
	  fracao&amp; operator-= (const fracao&amp; t);<p>
	  fracao&amp; operator*= (const fracao&amp; t);<p>
	  fracao&amp; operator/= (const fracao&amp; t);<p>
<p>
//operadores de input output<p>
	  friend istream&amp; operator&gt;&gt; (istream&amp; ci,fracao&amp; f);<p>
	  friend ostream&amp; operator&lt;&lt; (ostream&amp; co,const fracao&amp;
f);<p>
<p>
//operadores de conversao de tipos<p>
	  operator double() const;<p>
	  operator float() const;<p>
	  operator long() const;<p>
	  operator int() const;<p>
};<p>
#endif<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//codigo para a classe fracao<p>
#include &lt;iostream.h&gt;<p>
#include &lt;math.h&gt;<p>
#include &lt;iomanip.h&gt;<p>
#include &lt;stdio.h&gt;<p>
#include "of.h"<p>
<p>
fracao::fracao(fracao &amp;t)<p>
//copy constructor<p>
{<p>
num=t.num;<p>
den=t.den;<p>
}<p>
<p>
void fracao::simplifica(void)<p>
{<p>
long commd;<p>
commd=mdc(num,den); //divisor comum<p>
num=num/commd;<p>
den=den/commd;<p>
if (den&lt;0) { den=-den; num=-num;};<p>
//move o sinal p/ cima<p>
}<p>
<p>
fracao&amp; fracao::operator+= (const fracao&amp; t)<p>
 {<p>
  num=num*t.den+den*t.num;<p>
  den=den*t.den;<p>
  simplifica();<p>
  return *this;<p>
 }<p>
<p>
fracao::fracao(const long t,const long m)<p>
{<p>
 num=t;<p>
 den=m;<p>
 simplifica();<p>
 //this-&gt;simplifica<p>
}<p>
<p>
fracao operator/ (const fracao&amp; f,const fracao&amp; j)<p>
{<p>
 fracao g(f.num*j.den,f.den*j.num);<p>
 g.simplifica();<p>
 //esse metodo nao pertence a g, mas ela chama<p>
 //g.simplifica(); isto e' permitido aqui mesmo com simplifica<p>
 //como private.<p>
 return g;<p>
}<p>
<p>
<p>
fracao operator+ (const fracao&amp; f,const fracao&amp; j)<p>
{<p>
 fracao g((f.num*j.den)+(f.den*j.num),j.den*f.den);<p>
 //retorna variavel<p>
 g.simplifica();<p>
 return g;<p>
}<p>
<p>
<p>
fracao operator- (const fracao&amp; f,const fracao&amp; j)<p>
{<p>
 fracao g((f.num*j.den)-(f.den*j.num),j.den*f.den);<p>
 //retorna variavel<p>
 g.simplifica();<p>
 return g;<p>
}<p>
<p>
fracao operator* (const fracao&amp; f,const fracao&amp; j)<p>
{<p>
 fracao g(f.num*j.num,f.den*j.den);<p>
 //(f.num*j.num)/(f.den*j.den)<p>
 g.simplifica();<p>
 return g;<p>
}<p>
<p>
ostream&amp; operator&lt;&lt; (ostream&amp; co,const fracao&amp; f)<p>
{<p>
 co &lt;&lt; "(" &lt;&lt; f.num &lt;&lt; "/" &lt;&lt; f.den &lt;&lt; ")";<p>
 return co;<p>
}<p>
<p>
istream&amp; operator&gt;&gt; (istream&amp; ci, fracao&amp; f)<p>
{<p>
 long gcdiv;<p>
 //melhorar, ler mais sobre cin.<p>
 ci &gt;&gt; f.num &gt;&gt; f.den;<p>
 gcdiv=mdc(f.num,f.den);<p>
 f.num=f.num/gcdiv;<p>
 f.den=f.den/gcdiv;<p>
 return ci;<p>
}<p>
<p>
int operator== (const fracao&amp; s,const fracao&amp; t)<p>
{<p>
 return ((s.num*t.den)==(s.den*t.num));<p>
 //veja operacoes matematicas com fracao<p>
}<p>
<p>
int operator!= (const fracao&amp; s,const fracao&amp; t)<p>
{<p>
 return ((s.num*t.den)!=(s.den*t.num));<p>
}<p>
<p>
int operator&lt;= (const fracao&amp; s,const fracao&amp; t)<p>
{<p>
 return ((s.num*t.den)&lt;=(s.den*t.num));<p>
}<p>
<p>
int operator&lt; (const fracao&amp; s,const fracao&amp; t)<p>
{<p>
return ((s.num*t.den)&lt;(s.den*t.num));<p>
}<p>
<p>
int operator&gt; (const fracao&amp; s,const fracao&amp; t)<p>
{<p>
return ((s.num*t.den)&gt;(s.den*t.num));<p>
}<p>
<p>
int operator&gt;= (const fracao&amp; s,const fracao&amp; t)<p>
{<p>
 return ((s.num*t.den)&gt;=(s.den*t.num));<p>
}<p>
<p>
 fracao&amp; fracao::operator= (const fracao&amp; t)<p>
 //equivale a copy constructor<p>
 {<p>
  num=t.num;<p>
  den=t.den;<p>
  return *this;<p>
 }<p>
<p>
 fracao&amp; fracao::operator-= (const fracao&amp; t)<p>
  {<p>
  num=num*t.den-den*t.num;<p>
  den=den*t.den;<p>
  simplifica();<p>
  return *this;<p>
  //ponteiro para o proprio objeto (o apontado por this)<p>
 }<p>
<p>
 fracao&amp; fracao::operator*= (const fracao&amp; t)<p>
 {<p>
  num=num*t.num;<p>
  den=den*t.den;<p>
  simplifica();<p>
  return *this;<p>
 }<p>
<p>
 fracao&amp; fracao::operator/= (const fracao&amp; t)<p>
 {<p>
  num=num*t.den;<p>
  den=den*t.num;<p>
  simplifica();<p>
  return *this;<p>
 }<p>
<p>
fracao::operator double() const<p>
{<p>
double dbl;<p>
dbl=(double(num)/double(den));<p>
return dbl;<p>
}<p>
<p>
fracao::operator float() const<p>
{<p>
float flt;<p>
flt=(float(num)/float(den));<p>
return flt;<p>
}<p>
<p>
fracao::operator long() const<p>
{<p>
long lng;<p>
lng=num/den;<p>
return lng;<p>
}<p>
//converte fracao para long <p>
<p>
fracao::operator int() const<p>
{<p>
int ntgr;<p>
ntgr=int(num/den);<p>
return ntgr;<p>
}<b></b><p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//programa principal, testes e demonstracao<p>
#include &lt;iostream.h&gt;<p>
#include "of.h"<p>
//definicao da fracao<p>
#include &lt;stdio.h&gt;<p>
main()<p>
{<p>
char g;<p>
cout &lt;&lt; " Entre com fracao a: ";<p>
fracao a,b;<p>
cin &gt;&gt; a;<p>
cout&lt;&lt; "a"&lt;&lt; a &lt;&lt; "\n";<p>
cout &lt;&lt; " Entre fracao b:";<p>
cin &gt;&gt; b;<p>
cout &lt;&lt; "b" &lt;&lt; b &lt;&lt; "\n";<p>
fracao c;<p>
c=a+b;<p>
cout &lt;&lt; "c=a+b " &lt;&lt; c &lt;&lt; "\n";<p>
fracao d(c);<p>
cout &lt;&lt; "fracao d(c)"&lt;&lt; d &lt;&lt; endl;<p>
//e' o que chamamos de copy constructor<p>
cout &lt;&lt; "a*b " &lt;&lt; (a*b)&lt;&lt; "\n";<p>
cout &lt;&lt; "a-b " &lt;&lt; (a-b)&lt;&lt; "\n";<p>
cout &lt;&lt; "a/b " &lt;&lt; (a/b)&lt;&lt; "\n";<p>
cout &lt;&lt; "a&gt;b " &lt;&lt; (a&gt;b)&lt;&lt; "\n";<p>
cout &lt;&lt; "a&lt;b " &lt;&lt; (a&lt;b)&lt;&lt; "\n";<p>
cout &lt;&lt; "a&lt;=b " &lt;&lt; (a&lt;=b)&lt;&lt; "\n";<p>
cout &lt;&lt; "a&gt;=b " &lt;&lt; (a&gt;=b)&lt;&lt; "\n";<p>
cout &lt;&lt; "a==b " &lt;&lt; (a==b)&lt;&lt; "\n";<p>
cout &lt;&lt; "a!=b " &lt;&lt; (a!=b)&lt;&lt; "\n";<p>
c=a;<p>
a*=b;<p>
cout &lt;&lt; "a*=b " &lt;&lt; a&lt;&lt; "\n";<p>
a=c;<p>
a/=b;<p>
cout &lt;&lt; "a/=b " &lt;&lt; a&lt;&lt; "\n";<p>
a=c;<p>
a+=b;<p>
cout &lt;&lt; "a+=b " &lt;&lt; a &lt;&lt; "\n";<p>
a=c;<p>
a-=b;<p>
cout &lt;&lt; "a-=b " &lt;&lt; a&lt;&lt; "\n";<p>
a=c;<p>
cout &lt;&lt; "long(a) " &lt;&lt; long(a) &lt;&lt; "\n";<p>
cout &lt;&lt; "double(a) " &lt;&lt; double(a) &lt;&lt; "\n";<p>
cout &lt;&lt; "int(a) " &lt;&lt; int(a) &lt;&lt; "\n";<p>
cout &lt;&lt; "float(a) " &lt;&lt; float(a) &lt;&lt; "\n";<p>
cin &gt;&gt; g;<p>
return 0;<p>
}<b></b><p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Resultado do programa:</b><p>
<b></b>Entre fracao a:9<p>
8<p>
a(9/8)<p>
 Entre fracao b:9<p>
4<p>
b(9/4)<p>
c=a+b (27/8)<p>
fraction d(c)(27/8)<p>
a*b (81/32)<p>
a-b (-9/8)<p>
a/b (1/2)<p>
a&gt;b 0<p>
a&lt;b 1<p>
a&lt;=b 1<p>
a&gt;=b 0<p>
a==b 0<p>
a!=b 1<p>
a*=b (81/32)<p>
a/=b (1/2)<p>
a+=b (27/8)<p>
a-=b (-9/8)<p>
long(a) 1<p>
double(a) 1.125<p>
int(a) 1<p>
float(a) 1.125<p>
<b></b><p>
<b>Resultado do programa:</b><p>
<b> </b>Entre fracao a:1<p>
2<p>
a(1/2)<p>
Entre fracao b:5<p>
3<p>
b(5/3)<p>
c=a+b (13/6)<p>
fraction d(c)(13/6)<p>
a*b (5/6)<p>
a-b (-7/6)<p>
a/b (3/10)<p>
a&gt;b 0<p>
a&lt;b 1<p>
a&lt;=b 1<p>
a&gt;=b 0<p>
a==b 0<p>
a!=b 1<p>
a*=b (5/6)<p>
a/=b (3/10)<p>
a+=b (13/6)<p>
a-=b (-7/6)<p>
long(a) 0<p>
double(a) 0.5<p>
int(a) 0<p>
float(a) 0.5<p>
<b></b><p>
<b>Exerc&iacute;cios:</b><p>
1)Defina um tipo abstrato de dados matriz (do campo da matem&aacute;tica) com
sobrecarga de operadores que permita acessar via &iacute;ndice linear ou
linha/coluna qualquer elemento da matriz. Defina outras fun&ccedil;&otilde;es
membro que achar importantes. Por heran&ccedil;a, construa a classe matriz
quadrada, defina a fun&ccedil;&atilde;o membro transposta para esta matriz. <p>
	Dependendo doas fun&ccedil;&otilde;es membro que voc&ecirc; implementar
haver&aacute; bastante trabalho referente a tratamento de
exce&ccedil;&otilde;es, por exemplo: matrizes singulares n&atilde;o s&atilde;o
invers&iacute;veis, existem restri&ccedil;&otilde;es para a
multiplica&ccedil;&atilde;o e at&eacute; mesmo para a soma e
subtra&ccedil;&atilde;o visto que as dimens&otilde;es nas duas &uacute;ltimas
opera&ccedil;&otilde;es tem que ser iguais.<p>
<b></b>
<h2>
<a name="RTFToC60">4.2.
<a name="_Ref342721811"><a name="_Toc342736999"><a name="_Toc345409435"><a name="_Toc345810940"><a name="_Toc345838270"><a name="_Toc345942405"><a name="_Toc345949565"><a name="_Toc346168682"><a name="_Toc348417125"><a name="_Toc348931381"><a name="_Toc353900820"><a name="_Toc353946350">
HERAN&Ccedil;A M&Uacute;LTIPLA</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h2>
<b></b>

 "Heran&ccedil;a:m&uacute;ltipla"Se nos exemplos                                                            
anteriores t&iacute;nhamos uma hierarquia que se                                                     
comportava da seguinte maneira:                                                               
<CENTER>
<IMG SRC="lista.gif">
</CENTER>
<b>
	</b><p>
<b></b>Agora teremos algo como:

<pre>
<CENTER>
<IMG SRC="radiorel.gif">
</CENTER>
                 
<p>                                                                             
<CENTER>
<IMG SRC="estagi~1.gif">
</CENTER>

</pre>


<pre>
ou ent&atilde;o:                                                                                     
<CENTER>
<IMG SRC="veiculo.gif">
</CENTER>

</pre>

Tendo o seguinte significado: A classe herdeira tem comportamento, "behaviour",
semelhante ao das duas classes pais.		<b></b><p>
<b></b>
<h3>
<a name="RTFToC61">4.2.1.
<a name="_Toc342737000"><a name="_Toc345409436"><a name="_Toc345810941"><a name="_Toc345838271"><a name="_Toc345942406"><a name="_Toc345949566"><a name="_Toc346168683"><a name="_Toc348417126"><a name="_Toc348931382"><a name="_Toc353900821"><a name="_Toc353946351">
UM EXEMPLO SIMPLES.</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
Este exemplo seria sobre como implementar uma hierarquia semelhante a
hierarquia 1, mas n&atilde;o est&aacute; pronto ainda . Precisamos de
sugest&otilde;es sobre exemplos mais claros que um r&aacute;dio rel&oacute;gio
ou um Estagi&aacute;rio Remunerado. O exemplo seguinte supre a falta deste, mas
o apredizado &eacute; mas abrupto.<p>
<b></b>
<h3>
<a name="RTFToC62">4.2.2.
<a name="_Toc342737001"><a name="_Toc345409437"><a name="_Toc345810942"><a name="_Toc345838272"><a name="_Toc345942407"><a name="_Toc345949567"><a name="_Toc346168684"><a name="_Toc348417127"><a name="_Toc348931383"><a name="_Toc353900822"><a name="_Toc353946352">
VIRTUAL PUBLIC E RESOLU&Ccedil;&Atilde;O DE
CONFLITOS.</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
	Referente ao diagrama hierarquia de ve&iacute;culos apresentado neste
t&oacute;pico.<b></b><p>
<b></b>O que este caso tem de novo com rela&ccedil;&atilde;o ao anterior
&eacute;  que ve&iacute;culo utilit&aacute;rio pode herdar as
caracter&iacute;sticas de ve&iacute;culo por dois ramos da "hierarquia" de
heran&ccedil;a, como prevenir os poss&iacute;veis conflitos decorrentes deste
fato? Simples, os pais de ve&iacute;culo utilit&aacute;rio devem receber
ve&iacute;culo (a classe comum) atrav&eacute;s do qualificador
<CODE>virtual public</CODE>.<b></b><p>
<b></b>Este exemplo tamb&eacute;m apresenta a estrat&eacute;gia para
resolu&ccedil;&atilde;o de conflitos de nomes em heran&ccedil;a
m&uacute;ltipla, lembre-se que agora as classes pai podem ter nomes,
identificadores em comum. Nesse caso usamos o operador de
resolu&ccedil;&atilde;o de escopo <CODE>::</CODE> , veja os
coment&aacute;rios.<p>
<b></b><p>
<b>T&oacute;picos abordados: </b><p>
<b>	</b>Resolu&ccedil;&atilde;o de conflitos quando existe mais de um caminho
de heran&ccedil;a para uma classe pai (ve&iacute;culo),  chamada do construtor
para essa classe pai nas classes filhas. Resolu&ccedil;&atilde;o de conflitos
entre identificadores comuns.<p>
<CODE><p>
<b><hr></b><p>
<b></b>//header file<p>
class veiculo {<p>
private:<p>
	char* nome; //qualificacao do veiculo<p>
	int peso; //massa do veiculo<p>
	int hp; //potencia em hp.<p>
public:<p>
	veiculo(char* n,int p,int h);<p>
	void altera_hp(int en);<p>
	int retorna_hp(void);<p>
	void altera_peso(int en);<p>
	int retorna_peso(void);<p>
};<p>
<p>
class v_passeio:virtual public veiculo {<p>
private:<p>
	int vol_int; //volume interno.<p>
public:<p>
	v_passeio(char* n,int p,int hp,int vi);<p>
	void altera_vi(int en);<p>
	int retorna_vi(void);<p>
	float peso_pot(void); //relacao peso potencia.<p>
};<p>
<p>
class v_carga:virtual public veiculo {<p>
private:<p>
	int carga; //carga do veiculo.<p>
public:<p>
	v_carga(char* n,int p,int hp,int c);<p>
	void altera_carga(int en);<p>
	int retorna_carga(void);<p>
	float peso_pot(void); //relacao peso potencia, veiculo carregado<p>
};<p>
<p>
class v_utilitario:public v_passeio,public v_carga {<p>
private:<p>
//qualquer outro atributo unico de v_utilitario.<p>
public:<p>
	v_utilitario(char* n,int p,int hp,int vi,int c);<p>
	float peso_pot(void);<p>
};<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//implementation file<p>
#include "multiple.h"<p>
<p>
veiculo::veiculo(char* n,int p,int h)<p>
{ nome=n; peso=p; hp=h; }<p>
<p>
void veiculo::altera_peso(int en)<p>
{ peso=en;}<p>
<p>
int veiculo::retorna_peso(void)<p>
{ return peso; }<p>
<p>
void veiculo::altera_hp(int en)<p>
{ hp=en; }<p>
<p>
int veiculo::retorna_hp(void)<p>
{ return hp;}<p>
<p>
v_passeio::v_passeio(char* n,int p,int hp,int vi):veiculo(n,p,hp)<p>
{ vol_int=vi; }<p>
<p>
void v_passeio::altera_vi(int en)<p>
{ vol_int=en; }<p>
<p>
int v_passeio::retorna_vi(void)<p>
{ return vol_int; }<p>
<p>
float v_passeio::peso_pot(void)<p>
{ return float(retorna_peso())/float(retorna_hp()); }<p>
<p>
v_carga::v_carga(char* n,int p,int hp,int c):veiculo(n,p,hp)<p>
{ carga=c; }<p>
<p>
void v_carga::altera_carga(int en)<p>
{ carga=en; }<p>
<p>
int v_carga::retorna_carga(void)<p>
{ return carga; }<p>
<p>
float v_carga::peso_pot(void)<p>
{ return float(retorna_peso()+carga)/float(retorna_hp()); }<p>
<p>
v_utilitario::v_utilitario(char* m,int p,int hp,int vi,int
c):v_carga(m,p,hp,c),v_passeio(m,p,hp,vi),veiculo(m,p,hp)<p>
{<p>
//o construtor veiculo(m,p,hp) declarado aqui e que vale,<p>
//os construtores veiculo(m,p,hp) hierarquia acima sao descartados<p>
}<p>
<p>
float v_utilitario::peso_pot(void)<p>
{ return v_carga::peso_pot(); }<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//main file<p>
#include "multiple.h"<p>
#include &lt;iostream.h&gt;<p>
void main()<p>
{<p>
v_passeio v1("Toyota Corolla",300,130,3);<p>
cout &lt;&lt; v1.peso_pot()&lt;&lt;endl;<p>
v_utilitario v2("Pick-up A",400,180,2,400);<p>
cout &lt;&lt; v2.peso_pot()&lt;&lt;endl;<p>
cout &lt;&lt; v2.retorna_peso();<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Coment&aacute;rios: </b><CODE><b></b><p>
<b></b>float v_utilitario::peso_pot(void)<p>
{ return v_carga::peso_pot(); }<p>
</CODE><b></b><p>
<b></b>	A fun&ccedil;&atilde;o membro <CODE>peso_pot</CODE>
est&aacute; presente em todas as classes da "hierarquia".  Na
classe<CODE> veiculo utilitario</CODE> ela n&atilde;o precisa ser
reimplementada, basta escolher se em termos de peso pot&ecirc;ncia,
<CODE> veiculo utilitario</CODE> deve se comportar como
<CODE>veiculo de carga</CODE> ou como<CODE> veiculo de
passeio</CODE>.<p>
A escolha do comportamento foi a de <CODE>veiculo de carga</CODE>,
agora o que temos a fazer &eacute; chamar a fun&ccedil;&atilde;o membro
<CODE>peso_pot </CODE>de<CODE> veiculo de carga</CODE>
que j&aacute; est&aacute; implementada,  o que fazer para distinguir entre a
fun&ccedil;&atilde;o membro de mesmo nome da classe base<CODE> veiculo de
passeio</CODE>? Usa-se o operador de resolu&ccedil;&atilde;o de escopo,
mas agora acompanhado do nome da classe base que se deseja acessar:
<CODE>v_carga::peso_pot();</CODE>. A mesma estrat&eacute;gia
&eacute; adotada para dados membros em conflito: <CODE>
nome_classe_pai::dado_membro_em_conflito; </CODE>, neste caso os
atributos em comum est&atilde;o na classe <CODE>veiculo</CODE>,
topo da "hierarquia".<p>
<p>
<b>Resultado do programa:</b><p>
<b></b>2.30769<p>
4.44444<p>
400<p>
<p>
<b>Exerc&iacute;cios: </b><p>
<b></b>1) Modifique este exemplo para que em ve&iacute;culos  com capacidade de
carga<CODE> (v_carga e v_utilitario) </CODE> peso pot&ecirc;ncia
imprima a pot&ecirc;ncia do ve&iacute;culo carregado e tamb&eacute;m a
pot&ecirc;ncia do ve&iacute;culo descarregado, bem como a categoria (classe) do
ve&iacute;culo.<p>
<b>
<a name="_Ref342301505"><a name="_Toc342737002"><a name="_Toc345409438"><a name="_Toc345810943"><a name="_Toc345838273"><a name="_Toc345942408"><a name="_Toc345949568"><a name="_Toc346168685"><a name="_Toc348417128"><a name="_Toc348931384"><a name="_Toc353900823"><a name="_Toc353946353"></b>
<h2>
<a name="RTFToC63">4.3.
POLIMORFISMO PARAM&Eacute;TRICO
(TEMPLATE</a></a></a></a></a></a></a></a></a></a></a></a>)
</a></h2>
<p>
Polimorfismo param&eacute;trico &eacute; um recurso bastante &uacute;til para
evitar redund&acirc;ncia de c&oacute;digo, portanto se trata de um meio de
reuso deste. &Eacute; importante para criar fam&iacute;lias de classes ou
fun&ccedil;&otilde;es relacionadas.<p>
	Este recurso permite por exemplo definir uma classe matriz (do campo da
matem&aacute;tica) uma &uacute;nica vez num "header file" e utilizar esta
classe matriz para matrizes de tipo<CODE> float</CODE>,
tipo<CODE> int</CODE> ou <CODE>long</CODE> ,etc.
&Eacute; muito importante e exist&ecirc;ncia de um comportamento uniforme entre
os tipos que ser&atilde;o instanciados, por exemplo se na sua classe matriz
voc&ecirc; usa o operador %, todos os tipos a serem instanciados
(susbtitu&iacute;dos como tipo usado na matriz) devem atender da maneira
desejada a esse operador.<p>
	Em linguagens orientadas a objetos que n&atilde;o definem sobrecarga de
operador (M&oacute;dula-3) surge um problema: suponha que voc&ecirc; definiu o
tipo fra&ccedil;&atilde;o e quer usar em sua matriz de tipos parametrizados
tanto o tipo fra&ccedil;&atilde;o quanto o tipo inteiro. Como uniformizar o
comportamento desses tipos no que se refere a opera&ccedil;&atilde;o
de<CODE> soma </CODE>usada na classe matriz? Uma
solu&ccedil;&atilde;o &eacute; redefinir o tipo inteiro oferecido pela
linguagem de modo que ele atenda a fun&ccedil;&atilde;o membro de mesmo nome
usada no tipo fra&ccedil;&atilde;o, exemplo a fun&ccedil;&atilde;o<CODE>
soma(novo_inteiro a);. </CODE><p>
<b></b>
<h3>
<a name="RTFToC64">4.3.1.
<a name="_Ref342701822"><a name="_Toc342737003"><a name="_Toc345409439"><a name="_Toc345810944"><a name="_Toc345838274"><a name="_Toc345942409"><a name="_Toc345949569"><a name="_Toc346168686"><a name="_Toc348417129"><a name="_Toc348931385"><a name="_Toc353900824"><a name="_Toc353946354">
TAD VETOR</a></a></a></a></a></a></a></a></a></a></a></a> 
</a></h3>
<b></b><p>
<b></b>	Modifica&ccedil;&atilde;o do programa vetor de 1.5.3.6 para suportar
polimorfismo param&eacute;trico<CODE> (template). </CODE><p>
	Uma condi&ccedil;&atilde;o para que o polimorfismo param&eacute;trico funcione
bem &eacute;: Os tipos que s&atilde;o substitu&iacute;dos no<CODE>
template</CODE> devem se comportar de maneira uniforme para exemplificar
isso vamos substituir no template da classe vetor o tipo fra&ccedil;&atilde;o
com sobrecarga de operadores de 4.1.2 e o tipo
<CODE>float</CODE>.<p>
	Foi proposta a implementa&ccedil;&atilde;o do tipo abstrato de dados string,
uma boa indica&ccedil;&atilde;o da qualidade de sua implementa&ccedil;&atilde;o
&eacute; uma substitui&ccedil;&atilde;o no template deste exemplo sem acarretar
modifica&ccedil;&otilde;es, isto s&oacute; vale se nessa
implementa&ccedil;&atilde;o j&aacute; foi feita sobrecarga de operadores
(compara&ccedil;&atilde;o entre strings).<p>
	Dica de implementa&ccedil;&atilde;o: Se voc&ecirc; deseja fazer um programa
que use "templates" seguir os passos indicados abaixo normalmente lhe
poupar&aacute; tempo:<p>
<p>
-Defina os tipos que voc&ecirc; quer parametrizar um termos de chamadas de
fun&ccedil;&otilde;es membro e operadores de nomes e sintaxe iguais
(uniformidade). Os tipos dos argumentos v&atilde;o variar.<p>
-Construa seu programa para operar em um s&oacute; destes tipos.<p>
-Termine incluindo as defini&ccedil;&otilde;es dos templates no programa e
testando para os demais tipos.<p>
-Corrija as eventuais falhas de substitui&ccedil;&atilde;o.<p>
<CODE>	<p>
<b><hr></b><p>
//tempvet.h definicao da classe vetor com template.<p>
#include &lt;stdlib.h&gt;<p>
//header file para classe vetor<p>
const int inicio=0;<p>
<p>
template&lt;class T&gt; class vetor{ //T e' o tipo do elemento do vetor<p>
private:<p>
T* v;  //pode ser qualquer tipo que atenda as operacoes &lt; &gt; =<p>
int tamanho;<p>
public:<p>
vetor (int tamanho) ;<p>
T&amp; operator[] (int i);<p>
T maximo();<p>
int primeiro(void);<p>
int ultimo(void);<p>
};<p>
<p>
template&lt;class T&gt; vetor&lt;T&gt;::vetor (int tam)<p>
{v=new T[tam]; tamanho=tam;}<p>
<p>
template&lt;class T&gt; int vetor&lt;T&gt;::primeiro (void)<p>
{return inicio;}<p>
<p>
template&lt;class T&gt; int vetor&lt;T&gt;::ultimo (void)<p>
{ return tamanho-1; }<p>
<p>
template&lt;class T&gt; T&amp; vetor&lt;T&gt;::operator[](int i)<p>
{<p>
 if (i&lt;0 || i&gt;=tamanho) {cout &lt;&lt; "Fora dos limites!"; exit(1);}<p>
 //use exception handling to make it check bounds for you.<p>
  return v[i];<p>
 }<p>
<p>
template&lt;class T&gt; T vetor&lt;T&gt;:: maximo(void)<p>
{int candidato=inicio;<p>
 for (int i=inicio;i&lt;tamanho;i++)<p>
 if (v[i]&gt;v[candidato]) candidato=i;<p>
 return v[candidato];}<p>
<p>
<b><hr></b><p>
<p>
#include &lt;iostream.h&gt;<p>
#include "exvet3.h"<p>
<p>
main()<p>
{<p>
vetor&lt;float&gt; meu(5);<p>
<p>
for (int i=meu.primeiro();i&lt;=meu.ultimo();i++)<p>
{<p>
<p>
 cout &lt;&lt; "Entre com valor da posicao:" &lt;&lt; i &lt;&lt; "\n";<p>
 cin &gt;&gt; meu[i];<p>
}<p>
for (int j=meu.primeiro();j&lt;=meu.ultimo();j++) cout&lt;&lt; meu[j]&lt;&lt; "
";<p>
cout &lt;&lt; endl &lt;&lt; "Maximo:" &lt;&lt; meu.maximo();<p>
return 0;<p>
}<p>
<p>
<b><hr></b><p>
<p>
//main file, programa principal<p>
#include &lt;iostream.h&gt;<p>
#include "exvet3.h"<p>
#include "fractio2.h"<p>
#include "fractio2.cpp"<p>
main()<p>
{<p>
vetor&lt;fraction&gt; meu(5);<p>
<p>
for (int i=meu.primeiro();i&lt;=meu.ultimo();i++)<p>
{<p>
<p>
 cout &lt;&lt; "Entre com valor da posicao:" &lt;&lt; i &lt;&lt; "\n";<p>
 cin &gt;&gt; meu[i];<p>
}<p>
for (int j=meu.primeiro();j&lt;=meu.ultimo();j++) cout&lt;&lt; meu[j]&lt;&lt; "
";<p>
cout &lt;&lt; endl &lt;&lt; "Maximo:" &lt;&lt; meu.maximo();<p>
return 0;<p>
}<p>
<b><hr></b><p>
</CODE><p>
<p>
<b>Coment&aacute;rios</b>:<p>
	Se voc&ecirc; substitu&iacute;sse no template do vetor o tipo
fra&ccedil;&atilde;o que vamos definido em 4.1.2, o resultado seria  igual ao
apresentado no sub-t&oacute;pico resultado do programa em coment&aacute;rios.
Isto &eacute; s&oacute; a t&iacute;tulo de curiosidade. Voc&ecirc; n&atilde;o
precisa tentar implementar um tipo fra&ccedil;&atilde;o para uso neste
<CODE>template </CODE>ainda.<p>
<b></b><p>
<b>Resultado de teste do programa em coment&aacute;rios:</b><p>
<b></b>Entre com valor da posicao:0<p>
1<p>
2<p>
Entre com valor da posicao:1<p>
5<p>
4<p>
Entre com valor da posicao:2<p>
6<p>
1<p>
Entre com valor da posicao:3<p>
2<p>
8<p>
Entre com valor da posicao:4<p>
4<p>
2<p>
(1/2) (5/4) (6/1) (1/4) (2/1)<p>
Maximo: (6/1)<p>
<p>
<p>
<b>Resultado do programa com o tipo float parametrizado</b>:<p>
Entre com valor da posicao:0<p>
1.2<p>
Entre com valor da posicao:1<p>
2.1<p>
Entre com valor da posicao:2<p>
5.3<p>
Entre com valor da posicao:3<p>
1.5<p>
Entre com valor da posicao:4<p>
1.9<p>
1.2 2.1 5.3 1.5 1.9<p>
Maximo:5.3<p>
<p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1)Crie uma fun&ccedil;&atilde;o membro troca que recebe como argumentos
dois &iacute;ndices do vetor e faz a troca deles.
<h3>
<a name="RTFToC65">4.3.2.
<a name="_Toc342737004"><a name="_Toc345409440"><a name="_Toc345810945"><a name="_Toc345838275"><a name="_Toc345942410"><a name="_Toc345949570"><a name="_Toc346168687"><a name="_Toc348417130"><a name="_Toc348931386"><a name="_Toc353900825"><a name="_Toc353946355">
TEMPLATE DE FUN&Ccedil;&Atilde;O</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b></b>	Template de fun&ccedil;&atilde;o , introduziremos tipos parametrizados
na fun&ccedil;&atilde;o mdc que calcula o m&aacute;ximo divisor comum tanto
para long quanto para int e outros tipos que definam o operador
%:<CODE><p>
<b><hr></b><p>
//exemplo facil de templates de funcao<p>
#include &lt;iostream.h&gt;<p>
<p>
template&lt;class T&gt; T mdc(T n,T d)  //maximo divisor comum<p>
//metodo de Euclides<p>
{<p>
 if (n&lt;0) n=-n;<p>
 if (d&lt;0) d=-d;<p>
 while (d!=0) {<p>
	T r=n % d; //template T    %=MOD<p>
	n=d;<p>
	d=r;<p>
	}<p>
	return n;<p>
}<p>
<p>
<p>
void main(void)<p>
{<p>
int a=5;<p>
long b=6;<p>
long c=7;<p>
int d=14;<p>
cout &lt;&lt; "mdc(5,6)=" &lt;&lt; mdc(a,6) &lt;&lt; "\n";  //int int<p>
cout &lt;&lt; "mdc(2,3)=" &lt;&lt; mdc(2,3) &lt;&lt; "\n"; //int int || long
long<p>
cout &lt;&lt; "mdc(6,7)=" &lt;&lt; mdc(b,c) &lt;&lt; "\n";//long long<p>
cout &lt;&lt; "mdc(7,14)=" &lt;&lt; mdc(c,d) &lt;&lt; "\n"; //long int
//erro!!!!<p>
}<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//Versao que nao produz erro.<p>
//exemplo facil de templates de funcao<p>
#include &lt;iostream.h&gt;<p>
<p>
template&lt;class T&gt; T mdc(T n,T d)  //maximo divisor comum<p>
//metodo de Euclides<p>
{<p>
 if (n&lt;0) n=-n;<p>
 if (d&lt;0) d=-d;<p>
 while (d!=0) {<p>
	T r=n % d; //template T    %=MOD<p>
	n=d;<p>
	d=r;<p>
	}<p>
	return n;<p>
}<p>
<p>
long mdc(long m,long n); //definicao exata, long prevalece sobre int em termos
de conversao<p>
//nao acrescente int mdc(int a,int b); voce tera ambiguidades e o compilador
nao fara a //conversao<p>
<p>
void main(void)<p>
{<p>
int a=5;<p>
long b=6;<p>
long c=7;<p>
int d=14;<p>
cout &lt;&lt; "mdc(5,6)=" &lt;&lt; mdc(a,6) &lt;&lt; "\n";  //int int<p>
cout &lt;&lt; "mdc(2,3)=" &lt;&lt; mdc(2,3) &lt;&lt; "\n"; //int int || long
long<p>
cout &lt;&lt; "mdc(6,7)=" &lt;&lt; mdc(b,c) &lt;&lt; "\n";//long long<p>
cout &lt;&lt; "mdc(7,14)=" &lt;&lt; mdc(c,d) &lt;&lt; "\n"; //long int  OK,
conversao.<p>
}<p>
<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Coment&aacute;rios: </b><p>
<b>	</b>Na primeira vers&atilde;o do programa tudo funciona bem, com
exce&ccedil;&atilde;o da &uacute;ltima linha, ela produz um erro que &eacute;
corrigido na segunda vers&atilde;o do programa. Vamos explicar esse
erro:<b></b><p>
<b></b>	Quando o compilador resolve, decide, uma chamada de
fun&ccedil;&atilde;o ele primeiro tentar achar uma defini&ccedil;&atilde;o
exata dela (tipos j&aacute; definidos) exemplo <CODE>long mdc (int a,long
b);. </CODE><b></b><p>
<b></b>	Se n&atilde;o houver nenhuma vers&atilde;o exata o compilador tenta
achar uma vers&atilde;o com tipos param&eacute;tricos que aceite os tipos da
chamada da fun&ccedil;&atilde;o, no caso uma defini&ccedil;&atilde;o de
template que aceitaria seria: <CODE>template&lt;class T1,class T2&gt; T2
max(T2 n,T1 d) </CODE>, que &eacute; um tanto perigosa em termos de
opera&ccedil;&otilde;es entre tipos, por isso tamb&eacute;m n&atilde;o foi
fornecida.<b></b><p>
<b></b>	Se esta tentativa tamb&eacute;m falhar o compilador tenta fazer a
convers&atilde;o impl&iacute;cita do argumento de modo a satisfazer uma
defini&ccedil;&atilde;o exata, essa convers&atilde;o n&atilde;o pode resultar
numa ambiguidade. Na segunda vers&atilde;o fornecemos uma vers&atilde;o exata:
<CODE>long mdc (long a, long b);. </CODE> somente, n&atilde;o
deixando margens para ambiguidades.<p>
<b></b><p>
<b>Exerc&iacute;cios:</b><p>
1) Use um programa antigo feito em outra linguagem, ou mesmo em C. Tente
identificar as poss&iacute;veis substitui&ccedil;&otilde;es por tipos
param&eacute;tricos que poderiam ser feitas com sucesso e seguran&ccedil;a. Em
que casos outras solu&ccedil;&otilde;es seriam melhores e mais seguras? Que
solu&ccedil;&otilde;es?<p>
<p>
2)Perceba que nada impede que voc&ecirc; chame a fun&ccedil;&atilde;o
<CODE>mdc</CODE> para dois argumentos
<CODE>float</CODE>, o compilador executa de fato a chamada e vai
acusar erro  na opera&ccedil;&atilde;o <CODE>%</CODE> que
n&atilde;o &eacute; definida para este tipo. Por isso &eacute; que se diz que
os tipos parametrizados devem se comportar de maneira uniforme, com
opera&ccedil;&otilde;es semelhantes. <p>
	Defina uma fun&ccedil;&atilde;o de ordena&ccedil;&atilde;o de vetor, com tipos
param&eacute;tricos e que se baseie na exist&ecirc;ncia em alguns dos
operadores<CODE> &lt; , &gt; , &lt;= , &gt;= , ==</CODE> nos tipos
usados.<p>
	Observe que se quis&eacute;ssemos usar nosso tipo fracao nesta
fun&ccedil;&atilde;o ter&iacute;amos que definir o(s) operador(es)
relacional(is) usado(s), . Para fazer esta defini&ccedil;&atilde;o voc&ecirc;
ter&aacute; ler 4.1.2.<p>
<p>
3)Escreva uma fun&ccedil;&atilde;o troca com tipos parametrizados. Voc&ecirc;
deve usar passagem por refer&ecirc;ncia para trocar os dois argumentos do mesmo
tipo parametrizado que s&atilde;o passados: <CODE>void troca (T a,T b);
</CODE><p>
<p>
4)Mesmo quando voc&ecirc; n&atilde;o tem um motivo imediato para utilizar tipos
parametrizados em uma aplica&ccedil;&atilde;o faz sentido faz&ecirc;-lo? Se sim
em que casos?<p>
<b></b>
<h3>
<a name="RTFToC66">4.3.3.
  
<a name="_Toc342737005"><a name="_Toc345409441"><a name="_Toc345810946"><a name="_Toc345838276"><a name="_Toc345942411"><a name="_Toc345949571"><a name="_Toc346168688"><a name="_Toc348417131"><a name="_Toc348931387"><a name="_Toc353900826"><a name="_Toc353946356">HERAN&Ccedil;A
E TEMPLATES.</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
	Modifica&ccedil;&atilde;o do programa de listas ligadas de 2.1.4 para suportar
templates. Esta vers&atilde;o &eacute; usada em muitos outros exemplos do
tutorial.<p>
<CODE><p>
<b><hr></b><p>
#ifndef MLISTH_H<p>
#define MLISTH_H<p>
#include &lt;stdlib.h&gt;<p>
#include &lt;iostream.h&gt;<p>
//Criacao de uma hierarquia de listas ligadas.<p>
//O elemento da lista e' um inteiro<p>
enum Boolean{FALSE,TRUE};<p>
<p>
template &lt;class T&gt;class no{ //este e' o no da lista ligada, so e' usado
por ela<p>
private:<p>
 T info; //informacao<p>
 no* prox; //ponteiro para o proximo<p>
public:<p>
 no();<p>
 no(T i,no* p);<p>
 no* get_prox(void);<p>
 void set_prox(no* p);<p>
 T get_info(void);<p>
 void set_info(T a);<p>
 no* dobra(void);<p>
 ~no(void);<p>
} ;<p>
<p>
template &lt;class T&gt;class lista{ //esta e' a lista ligada comum.<p>
protected: //"visivel hierarquia abaixo"<p>
	no&lt;T&gt;* primeiro; //primeiro no da lista, aqui eu insiro e removo.<p>
public:<p>
lista(void);<p>
lista(const lista&lt;T&gt;&amp; lc); //copy constructor.<p>
Boolean vazia(void)const;<p>
Boolean contem(T el)const;<p>
void insere_primeiro(T elem);<p>
T* remove_primeiro();<p>
void mostra()const;<p>
~lista(void);<p>
}; //fim classe lista<p>
<p>
template &lt;class T&gt;class listaultimo:public lista&lt;T&gt; { //essa e a
lista util para<p>
//implementar pilhas e filas.<p>
protected: //protected e uma opcao outra e' get_ultimo() e set_...<p>
  no&lt;T&gt;* ultimo;<p>
public:<p>
listaultimo(void);<p>
listaultimo(const listaultimo&lt;T&gt;&amp; lc); //redefinicao<p>
void insere_ultimo(T elem); //nova<p>
void insere_primeiro(T elem); //redefinicao<p>
T* remove_primeiro();//redefinicao<p>
~listaultimo(void);<p>
//as operacoes nao redefinidas sao validas.<p>
};<p>
<p>
template &lt;class T&gt;class listaordenada:public lista&lt;T&gt; {<p>
//essa e' a lista comum com aprimoramentos.<p>
public:<p>
listaordenada(void);<p>
//nao definimos copy constructor<p>
Boolean contem(T el)const;<p>
void insere_primeiro(T elem); //insere em ordem<p>
T* remove_elemento(T el);<p>
~listaordenada(void);<p>
};<p>
<p>
template&lt;class T&gt;no&lt;T&gt;::no()<p>
{prox=NULL;cout &lt;&lt; "Hi";}<p>
<p>
template&lt;class T&gt;no&lt;T&gt;::no(T i,no* p)<p>
{info=i;prox=p;cout &lt;&lt; "Hi";}<p>
<p>
template&lt;class T&gt; no&lt;T&gt;* no&lt;T&gt;::get_prox(void)<p>
{return prox;}<p>
<p>
template&lt;class T&gt; void no&lt;T&gt;::set_prox(no* p)<p>
{prox=p;}<p>
<p>
template&lt;class T&gt; T no&lt;T&gt;::get_info(void) {return info;}<p>
<p>
template&lt;class T&gt; void no&lt;T&gt;::set_info(T i)<p>
{info=i;}<p>
<p>
template&lt;class T&gt; no&lt;T&gt;* no&lt;T&gt;::dobra(void)<p>
{<p>
if (get_prox()==NULL) return new no&lt;T&gt;(get_info(),NULL);<p>
else return new no&lt;T&gt;(get_info(),this-&gt;get_prox()-&gt;dobra());<p>
//recursividade para duplicacao da lista<p>
}<p>
<p>
template&lt;class T&gt; no&lt;T&gt;::~no(void)<p>
{cout &lt;&lt; "bye";}  //bye e so para debugar, retire depois de compilado.<p>
<p>
template&lt;class T&gt; lista&lt;T&gt;::lista(void):primeiro(NULL)<p>
{}  //bloco de codigo vazio<p>
<p>
template&lt;class T&gt; lista&lt;T&gt;::lista(const lista&lt;T&gt;&amp; lc)<p>
{ primeiro=lc.primeiro-&gt;dobra(); }<p>
<p>
template&lt;class T&gt; Boolean lista&lt;T&gt;::vazia(void)const<p>
{ return Boolean(primeiro==NULL); }<p>
<p>
template&lt;class T&gt; Boolean lista&lt;T&gt;::contem(T el) const//mais rapido
que iterador<p>
{<p>
 no&lt;T&gt;* curr;<p>
 curr=primeiro;<p>
 while ((curr!=NULL) &amp;&amp; (curr-&gt;get_info()!=el))<p>
 {<p>
  curr=curr-&gt;get_prox();<p>
 };<p>
  return Boolean(curr-&gt;get_info()==el);<p>
}<p>
<p>
template&lt;class T&gt; void lista&lt;T&gt;::insere_primeiro(T elem)<p>
{<p>
no&lt;T&gt;* insirame;<p>
 if (primeiro==NULL) //lista vazia<p>
	 primeiro=new no&lt;T&gt;(elem,NULL);<p>
 else {<p>
		 insirame=new no&lt;T&gt;(elem,primeiro);<p>
		 primeiro=insirame;<p>
		};<p>
};<p>
<p>
template&lt;class T&gt; T* lista&lt;T&gt;::remove_primeiro(void)<p>
 {<p>
 T* devolvame; //return<p>
 no&lt;T&gt;* temp;     //to delete<p>
 if (primeiro==NULL)  return NULL; //lista vazia<p>
 else {<p>
		 (*devolvame)=primeiro-&gt;get_info();<p>
		 temp=primeiro;<p>
		 primeiro=primeiro-&gt;get_prox();<p>
		 delete temp;<p>
		 return devolvame;<p>
		};<p>
 };<p>
<p>
template&lt;class T&gt;void lista&lt;T&gt;::mostra() const<p>
{<p>
no&lt;T&gt;* curr;<p>
cout &lt;&lt; "=";<p>
curr=primeiro;<p>
while (curr!=NULL)<p>
 {<p>
  cout &lt;&lt;"("&lt;&lt;curr-&gt;get_info()&lt;&lt;")"&lt;&lt;"-";<p>
  curr=curr-&gt;get_prox();<p>
 };<p>
}<p>
<p>
template&lt;class T&gt;lista&lt;T&gt;::~lista(void)<p>
{<p>
 no&lt;T&gt;* temp;<p>
  while (primeiro!=NULL)<p>
  {<p>
  temp=primeiro;<p>
  primeiro=primeiro-&gt;get_prox();<p>
  delete temp;<p>
  };<p>
}<p>
<p>
template&lt;class
T&gt;listaordenada&lt;T&gt;::listaordenada(void):lista&lt;T&gt;()<p>
{};<p>
<p>
template&lt;class T&gt; Boolean listaordenada&lt;T&gt;::contem(T el)const<p>
{<p>
no&lt;T&gt;* curr;<p>
Boolean conti=TRUE;<p>
 curr=primeiro;<p>
 while ((curr!=NULL) &amp;&amp; conti)<p>
 {<p>
  if (curr-&gt;get_info()&lt;el)<p>
  curr=curr-&gt;get_prox();<p>
  else conti=FALSE;<p>
 };<p>
 if (curr==NULL) return FALSE;<p>
 else return Boolean(curr-&gt;get_info()==el);<p>
}<p>
<p>
template&lt;class T&gt;void listaordenada&lt;T&gt;::insere_primeiro(T elem)<p>
{<p>
no&lt;T&gt;* curr=primeiro;<p>
no&lt;T&gt;* prev=NULL;<p>
no&lt;T&gt;* insirame;<p>
Boolean conti=TRUE;<p>
 while ((curr!=NULL) &amp;&amp; conti)<p>
 {<p>
  if (curr-&gt;get_info()&lt;elem)<p>
  {prev=curr; curr=curr-&gt;get_prox();}<p>
  else conti=FALSE;<p>
 };<p>
 insirame=new no&lt;T&gt;(elem,curr);<p>
 if (prev==NULL) primeiro=insirame;<p>
  else prev-&gt;set_prox(insirame);<p>
}<p>
<p>
template&lt;class T&gt; T* listaordenada&lt;T&gt;::remove_elemento(T el)<p>
{<p>
T* devolvame;<p>
no&lt;T&gt;* curr=primeiro;<p>
no&lt;T&gt;* prev=NULL;<p>
no&lt;T&gt;* deleteme;<p>
Boolean conti=TRUE;<p>
 while ((curr!=NULL) &amp;&amp; conti) //acha lugar onde pode estar el<p>
 {<p>
  if (curr-&gt;get_info()&lt;el)<p>
  {prev=curr; curr=curr-&gt;get_prox();} //anda<p>
  else conti=FALSE;<p>
 };<p>
 if (curr==NULL) return FALSE; //fim de lista ou vazia<p>
 else //pode ser o elemento ou ele nao existe<p>
  {<p>
	 if (curr-&gt;get_info()==el)<p>
	  {<p>
		deleteme=curr;<p>
		if (prev==NULL) //lista so com um elemento ou primeiro el<p>
		  primeiro=curr-&gt;get_prox();<p>
		else<p>
		 {<p>
		  prev-&gt;set_prox(curr-&gt;get_prox());<p>
		 }<p>
		cout &lt;&lt; deleteme-&gt;get_info()&lt;&lt;endl; //so para verificar<p>
		(*devolvame)=delete-&gt;get_info();<p>
		delete deleteme;<p>
		return devolvame;<p>
	  }<p>
	 else return NULL;<p>
  }<p>
}<p>
<p>
template&lt;class T&gt;listaordenada&lt;T&gt;::~listaordenada(void)<p>
{cout &lt;&lt; "Lista destruida.";};<p>
<p>
template&lt;class
T&gt;listaultimo&lt;T&gt;::listaultimo(void):lista&lt;T&gt;()<p>
{<p>
ultimo=NULL;<p>
}<p>
<p>
template&lt;class T&gt;listaultimo&lt;T&gt;::listaultimo(const
listaultimo&lt;T&gt;&amp; lc)<p>
{<p>
no&lt;T&gt;* curr;<p>
 primeiro=ultimo=NULL; //inicializa lista<p>
 if (!lc.vazia())<p>
  {<p>
	curr=lc.primeiro;<p>
	while (curr!=NULL)<p>
	{<p>
	 insere_ultimo(curr-&gt;get_info());<p>
	 curr=curr-&gt;get_prox();<p>
	}<p>
  }<p>
}<p>
<p>
template&lt;class T&gt;void listaultimo&lt;T&gt;::insere_ultimo(T elem)<p>
{<p>
no&lt;T&gt;* insirame;<p>
insirame=new no&lt;T&gt;(elem,NULL);<p>
if (ultimo==NULL) ultimo=insirame; //lista vazia<p>
else {<p>
		ultimo-&gt;set_prox(insirame);<p>
		ultimo=insirame;<p>
		};<p>
if (primeiro==NULL) primeiro=ultimo; //lista vazia<p>
}<p>
<p>
template&lt;class T&gt; void listaultimo&lt;T&gt;::insere_primeiro(T elem)
//redefinicao<p>
{<p>
no&lt;T&gt;* insirame;<p>
 if (primeiro==NULL) //lista vazia<p>
	{<p>
	 primeiro=new no&lt;T&gt;(elem,ultimo);<p>
	 ultimo=primeiro;<p>
	}//lista vazia<p>
 else {<p>
		 insirame=new no&lt;T&gt;(elem,primeiro);<p>
		 primeiro=insirame;<p>
		};<p>
}<p>
<p>
template&lt;class T&gt; T*
listaultimo&lt;T&gt;::remove_primeiro()//redefinicao<p>
{<p>
T* devolvame; //return<p>
 no&lt;T&gt;* temp;     //to delete<p>
 if (primeiro==NULL)  return 0; //lista vazia<p>
 else {<p>
		 (*devolvame)=primeiro-&gt;get_info();<p>
		 temp=primeiro;<p>
		 primeiro=primeiro-&gt;get_prox();<p>
		 delete temp;<p>
		 if (primeiro==NULL) ultimo=NULL; //volta lista vazia<p>
		 return devolvame;<p>
		};<p>
}<p>
<p>
template&lt;class T&gt;listaultimo&lt;T&gt;::~listaultimo(void)<p>
{<p>
 no&lt;T&gt;* temp;<p>
  while (primeiro!=NULL)<p>
  {<p>
  temp=primeiro;<p>
  primeiro=primeiro-&gt;get_prox();<p>
  delete temp;<p>
  };<p>
  delete ultimo;<p>
}<p>
<p>
#endif<p>
<p>
<b><hr></b><p>
<p>
#include "mlistht.h"<p>
main()<p>
{<p>
listaultimo&lt;int&gt; minha;<p>
listaultimo&lt;int&gt;* copia;<p>
char option; //use in menu as option variable<p>
char cpyopt; //copy option para copia<p>
int el; //elemento a inserir<p>
do {<p>
 cout &lt;&lt;"\n";   //menu options display<p>
 cout &lt;&lt;"P:Insere no primeiro.\n";<p>
 cout &lt;&lt;"R:Remove no primeiro.\n";<p>
 cout &lt;&lt;"U:Insere no ultimo.\n";<p>
 cout &lt;&lt;"E:Existe elemento?\n";<p>
 cout &lt;&lt;"V:Vazia?\n";<p>
 cout &lt;&lt;"M:Mostra lista.\n";<p>
 cout &lt;&lt;"C:Copia lista e mostra.\n";<p>
 cout &lt;&lt;"Q:Quit teste lista.\n";<p>
 cout &lt;&lt;"Entre comando:";<p>
 cin &gt;&gt; option; //reads user option<p>
 switch(option) //executes user option<p>
 {<p>
  case 'P':<p>
  case 'p':<p>
				cout &lt;&lt; "Entre elemento:";<p>
				cin &gt;&gt;el;<p>
				minha.insere_primeiro(el);<p>
				break;<p>
  case 'R':<p>
  case 'r':<p>
				if (!minha.vazia())<p>
				cout &lt;&lt; (*minha.remove_primeiro())&lt;&lt;endl;<p>
				else cout &lt;&lt; "NULL, Lista vazia." &lt;&lt;endl;<p>
				break;<p>
  case 'U':<p>
  case 'u':<p>
				cout &lt;&lt; "Entre elemento:";<p>
				cin &gt;&gt; el;<p>
				minha.insere_ultimo(el);<p>
				break;<p>
  case 'M':<p>
  case 'm': minha.mostra();<p>
				break;<p>
  case 'E':<p>
  case 'e':<p>
				cout &lt;&lt; "Entre elemento:";<p>
				cin &gt;&gt;el;<p>
				cout &lt;&lt; minha.contem(el);<p>
				break;<p>
  case 'V':<p>
  case 'v':<p>
				cout &lt;&lt; minha.vazia();<p>
				break;<p>
  case 'C':<p>
  case 'c':<p>
				copia=new listaultimo&lt;int&gt;(minha);<p>
				copia-&gt;mostra();<p>
				cout &lt;&lt; "Agora trabalhando na lista copia." &lt;&lt; endl;<p>
				do {<p>
				 cout &lt;&lt;"\n";   //menu options display<p>
				 cout &lt;&lt;"P:Insere no primeiro.\n";<p>
				 cout &lt;&lt;"R:Remove no primeiro.\n";<p>
				 cout &lt;&lt;"U:Insere no ultimo.\n";<p>
				 cout &lt;&lt;"E:Existe elemento?\n";<p>
				 cout &lt;&lt;"V:Vazia?\n";<p>
				 cout &lt;&lt;"M:Mostra lista.\n";<p>
				 cout &lt;&lt;"Q:Quit teste lista copia?Volta lista anterior?.\n";<p>
				 cout &lt;&lt;"Entre comando:";<p>
				 cin &gt;&gt; cpyopt; //reads user option<p>
				 switch(cpyopt) //executes user option<p>
				 {<p>
				  case 'P':<p>
				  case 'p':<p>
							cout &lt;&lt; "Entre elemento:";<p>
							cin &gt;&gt;el;<p>
							copia-&gt;insere_primeiro(el);<p>
					break;<p>
				  case 'R':<p>
				  case 'r':<p>
							if (!copia-&gt;vazia())<p>
							cout &lt;&lt; (*copia-&gt;remove_primeiro())&lt;&lt;endl;<p>
							else cout &lt;&lt; "NULL, Lista vazia." &lt;&lt;endl;<p>
					break;<p>
				  case 'U':<p>
				  case 'u':<p>
							cout &lt;&lt; "Entre elemento:";<p>
							cin &gt;&gt;el;<p>
							copia-&gt;insere_ultimo(el);<p>
					break;<p>
				  case 'M':<p>
				  case 'm':<p>
						copia-&gt;mostra();<p>
					break;<p>
				  case 'E':<p>
				  case 'e':<p>
							cout &lt;&lt; "Entre elemento:";<p>
							cin &gt;&gt;el;<p>
							cout &lt;&lt; copia-&gt;contem(el);<p>
					break;<p>
				case 'V':<p>
				case 'v':<p>
							cout &lt;&lt; copia-&gt;vazia();<p>
					break;<p>
				case 'Q':<p>
				case 'q':<p>
							delete copia;<p>
					break;<p>
			  default:  ;<p>
			  }  //switch-case code block<p>
				} while ((cpyopt!='Q') &amp;&amp; (cpyopt!='q'));<p>
				break;<p>
  default:  ;<p>
 }  //switch-case code block<p>
} while ((option!='Q') &amp;&amp; (option!='q'));  //menu loop code block<p>
<p>
return 0;<p>
}  //main code block<p>
</CODE><p>
<b><hr></b><p>
<p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1)Compare esta lista com <CODE> "templates" </CODE> com
outras listas implementadas sem tipos param&eacute;tricos. Que vantagens
voc&ecirc; pode apontar a n&iacute;vel de independ&ecirc;ncia entre as partes
de um programa? Porque &eacute; importante maximizar esta independ&ecirc;ncia
entre as partes de um programa? Outro exerc&iacute;cio: Modifique o programa
<CODE>lista&lt;T&gt;</CODE> para trabalhar com
ponteiros<CODE> &lt;T*&gt;</CODE><b> </b>evitando a copia de
objetos grandes visando assim  maior efici&ecirc;ncia.<p>
<b></b>
<h3>
<a name="RTFToC67">4.3.4.
<a name="_Toc342737006"><a name="_Toc345409442"><a name="_Toc345810947"><a name="_Toc345838277"><a name="_Toc345942412"><a name="_Toc345949572"><a name="_Toc346168689"><a name="_Toc348417132"><a name="_Toc348931388"><a name="_Toc353900827"><a name="_Toc353946357">
TEMPLATES E AGREGA&Ccedil;&Atilde;O</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
<b>	</b>Usando o template definido no exemplo dois criaremos uma classe pilha e
a testaremos de modo an&aacute;logo ao que foi feito em 2.2 s&oacute; que agora
com templates e com uma pilha e n&atilde;o fila.<p>
<CODE>mlisth.h</CODE> n&atilde;o ser&aacute; copiada, &eacute;
id&ecirc;ntica a do exemplo anterior de "templates".<p>
<CODE><p>
<b><hr></b><p>
<p>
#include "mlistht.h"<p>
template&lt;class T&gt;class pilha { //agregacao de uma lista<p>
private:<p>
 lista&lt;T&gt; al;  //a lista<p>
public:<p>
 pilha();<p>
 Boolean vazia();<p>
 Boolean contem(T el);<p>
 void insere(T el);<p>
 T* remove();<p>
 void mostra();<p>
};<p>
<p>
template&lt;class T&gt; pilha&lt;T&gt;::pilha(){};<p>
template&lt;class T&gt; Boolean pilha&lt;T&gt;::vazia()<p>
	{return al.vazia();}<p>
template&lt;class T&gt; Boolean pilha&lt;T&gt;::contem(T el)<p>
	{return al.contem(el);}<p>
template&lt;class T&gt; void pilha&lt;T&gt;::insere(T el)<p>
	{al.insere_primeiro(el);}<p>
template&lt;class T&gt; T* pilha&lt;T&gt;::remove()<p>
	{return al.remove_primeiro();}<p>
template&lt;class T&gt; void pilha&lt;T&gt;::mostra()<p>
	{al.mostra();}<p>
<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>#include "mpilhat.h"<p>
main()<p>
{<p>
pilha&lt;int&gt; minha;<p>
char option; //use in menu as option variable<p>
int el; //elemento a inserir<p>
do {<p>
 cout &lt;&lt;"\n";   //menu options display<p>
 cout &lt;&lt;"I:Insere.\n";<p>
 cout &lt;&lt;"R:Remove.\n";<p>
 cout &lt;&lt;"M:Mostra pilha.\n";<p>
 cout &lt;&lt;"Q:Quit pilha test.\n";<p>
 cout &lt;&lt;"V:Vazia?\n";<p>
 cout &lt;&lt;"C:Contem?\n";<p>
 cout &lt;&lt;"Entre comando:";<p>
 cin &gt;&gt; option; //reads user option<p>
 switch(option) //executes user option<p>
 {<p>
  case 'I':<p>
  case 'i':<p>
				cout &lt;&lt; "Entre elemento:";<p>
				cin &gt;&gt;el;<p>
				minha.insere(el);<p>
				break;<p>
  case 'R':<p>
  case 'r':<p>
				if (!minha.vazia())<p>
				cout &lt;&lt; (*(minha.remove()))&lt;&lt;endl;<p>
				else cout &lt;&lt; "NULL, pilha vazia." &lt;&lt;endl;<p>
				break;<p>
  case 'C':<p>
  case 'c':<p>
				cout &lt;&lt; "Entre elemento:";<p>
				cin &gt;&gt;el;<p>
				cout &lt;&lt; minha.contem(el);<p>
				break;<p>
  case 'M':<p>
  case 'm':<p>
				minha.mostra();<p>
				break;<p>
  case 'V':<p>
  case 'v':<p>
				cout &lt;&lt; "Resultado:" &lt;&lt; minha.vazia() &lt;&lt;endl;<p>
				break;<p>
  default:  ;<p>
 }  //switch-case code block<p>
} while ((option!='Q') &amp;&amp; (option!='q'));  //menu loop code block<p>
<p>
return 0;<p>
}  //main code block<p>
<b><hr></b><p>
</CODE><p>
<b></b><p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1)Defina outras classes apresentadas em termos de templates, por exemplo
a classe conta . Suponha que voc&ecirc; tem que fazer um programa que usa a
classe conta, mas n&atilde;o sabe ao certo se vai usar o tipo<CODE>
float</CODE> para representar o dinheiro ou vai usar algum outro tipo
<CODE> (double) </CODE>. Use templates e defina este tipo somente
quanto as opera&ccedil;&otilde;es.<b>
<a name="_Toc342737007"><a name="_Toc345409443"><a name="_Toc345810948"><a name="_Toc345838278"><a name="_Toc345942413"><a name="_Toc345949573"><a name="_Toc346168690"><a name="_Toc348417133"><a name="_Toc348931389"><a name="_Toc353900828"><a name="_Toc353946358"></b>
<h2>
<a name="RTFToC68">4.4.
METACLASSES</a></a></a></a></a></a></a></a></a></a></a> 
</a></h2>
<p>
	Metaclasses armazenam informa&ccedil;&otilde;es sobre classes definidas pelo
usu&aacute;rio e s&atilde;o comuns em algumas linguagens de
programa&ccedil;&atilde;o orientadas a objetos. Essa informa&ccedil;&atilde;o
armazenada &eacute; a chamada metainforma&ccedil;&atilde;o.<p>
<b>	</b>C++ n&atilde;o possui metaclasses, por&eacute;m existem meios de
armazenar alguma metainforma&ccedil;&atilde;o, um deles &eacute; o uso de
vari&aacute;veis do tipo static que guardam informa&ccedil;&otilde;es sobre os
v&aacute;rios objetos de uma mesma classe.<p>
	A utilidade da metainforma&ccedil;&atilde;o &eacute; vasta. Por exemplo um
arquivo que armazena uma imagem cont&eacute;m geralmente um cabe&ccedil;alho
sobre a imagem (n&uacute;mero de "pixels", largura, altura, etc). Numa classe
lista, pode ser considerado como meta-informa&ccedil;&atilde;o: o n&uacute;mero
de elementos, o estado: ordenado ou n&atilde;o, etc. Em bancos de dados
&eacute; muito comum se armazenar meta-informa&ccedil;&atilde;o nos arquivos.<p>
<b>
<a name="_Toc342737008"><a name="_Toc345409444"><a name="_Toc345810949"><a name="_Toc345838279"><a name="_Toc345942414"><a name="_Toc345949574"><a name="_Toc346168691"><a name="_Toc348417134"><a name="_Toc348931390"><a name="_Toc353900829"><a name="_Toc353946359"></b>
<h3>
<a name="RTFToC69">4.4.1.
UM TIPO SIMPLES COMO STATIC</a></a></a></a></a></a></a></a></a></a></a>	
</a></h3>
	<p>
	Quando se declara um atributo <CODE>static</CODE> em uma classe,
todos os objetos instanciados tem uma refer&ecirc;ncia para ele (o mesmo
atributo), ou seja ele pode ser modificado ou lido  por fun&ccedil;&otilde;es
membro de todos os objetos desta classe. No exemplo a seguir declaramos um
atributo <CODE>static</CODE> inteiro que &eacute; incrementado
quando o objeto &eacute; criado (construtor) e decrementado quando o objeto
&eacute; destru&iacute;do. Esse atributo static pode ser de qualquer tipo, pode
ser at&eacute; um objeto.<p>
	Vari&aacute;veis static servem para fazer estat&iacute;sticas sobre uma
classe, tamb&eacute;m s&atilde;o  adequadas para tornar
informa&ccedil;&otilde;es de um objeto dispon&iacute;veis para outros da mesma
classe, elas continuam existindo (conservam seu valor) mesmo que n&atilde;o
haja nenhum objeto instanciado e n&atilde;o destru&iacute;do (vivo).<p>
	O programa abaixo mostra como faz&ecirc;-lo, <CODE>alive
</CODE>representa o n&uacute;mero de objetos da classe robot criados.
Veja que a declara&ccedil;&atilde;o de alive segue a palavra static.<p>
<p>
<CENTER>
<IMG SRC="robostat.gif">
</CENTER>
Diagrama do atributo static alive, compartilhado por v&aacute;rios
rob&ocirc;s:<p>
<p>
<CODE><p>
<b><hr></b><p>
#include &lt;iostream.h&gt;<p>
<p>
class robo {<p>
private:<p>
	float x,y;<p>
	static int vivos;  //guarda numero de robos vivos.<p>
public:<p>
	robo(float x,float y) {vivos++;} //cria robo<p>
	void move(float dx,float dy) {x+=dx;y+=dy;}<p>
	static int get_vivos(void) {return vivos;} //quantos vivos<p>
	~robo(void) {vivos--;} //mata robo<p>
	};<p>
<p>
int robo::vivos=0; //inicializacao da variavel static.<p>
<p>
main()<p>
{<p>
cout &lt;&lt; robo::get_vivos() &lt;&lt; endl;<p>
robo *r1=new robo(1.3,1.4); //cria robo 1<p>
robo *r2;<p>
cout &lt;&lt; r1-&gt;get_vivos() &lt;&lt; "\n" ; //1 vivo<p>
r2=new robo(0.0,0.0);  //cri robo 2<p>
cout &lt;&lt; r1-&gt;get_vivos() &lt;&lt; "\n" ; //2 vivos<p>
delete r1; //kill robo 1<p>
cout &lt;&lt; robo::get_vivos() &lt;&lt; "\n" ; //1 vivo<p>
r2-&gt;move(12.4,23.2); //movendo robo certa distancia.<p>
delete r2; //mata robo 2.<p>
//nenhum robo vivo<p>
cout &lt;&lt; robo::get_vivos() &lt;&lt; endl;<p>
return 0;<p>
}<p>
<b><hr></b><p>
</CODE><p>
<b>Resultado do programa:</b><p>
<b></b>0<p>
1<p>
2<p>
1<p>
0<p>
<p>
<b>Coment&aacute;rios:</b> <p>
	Observe o trecho de c&oacute;digo: <CODE> int robot::alive=0;
</CODE> perceba que voc&ecirc; deve inicializar o atributo antes da
cria&ccedil;&atilde;o de qualquer objeto. Esse tipo de acesso n&atilde;o
&eacute; permitido em<CODE> main(),</CODE> mantendo assim o
encapsulamento. Quando os objetos s&atilde;o criados eles incrementam
<CODE>alive</CODE> atrav&eacute;s de seus construtores, e
decrementam quando s&atilde;o destru&iacute;dos.<p>
	Existe uma fun&ccedil;&atilde;o membro declarada como static: <CODE>
static int get_vivos(void) {return vivos;} </CODE>  esta
fun&ccedil;&atilde;o membro tem um tipo de acesso diferente dos outros , o
seguinte trecho de c&oacute;digo usado em nosso programa &eacute; permitido:
<CODE> cout &lt;&lt; robo::get_vivos() &lt;&lt; endl;.
</CODE>Perceba que <CODE>get_vivos</CODE> &eacute; chamado
sem o operador . ou<CODE> -&gt;</CODE>, isto &eacute; permitido
porque <CODE>get_vivos</CODE> &eacute; um fun&ccedil;&atilde;o
membro<CODE> static</CODE>, opera portanto sobre vari&aacute;veis
<CODE>static</CODE> que podem existir antes da
cria&ccedil;&atilde;o do primeiro objeto da classe ou quando nenhum objeto
est&aacute; ativo.<p>
<p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1) No lugar da vari&aacute;vel inteira declarada como static faca a
seguinte declara&ccedil;&atilde;o: <CODE>static armazenagem vivos;
//guarda numero de robos vivos.. </CODE><p>
Inicialize tamb&eacute;m o objeto<CODE> static</CODE> chamando seu
construtor fora de main.<p>
Uma poss&iacute;vel defini&ccedil;&atilde;o para a classe armazenagem seria:<p>
<CODE>class armazenagem {<p>
private:<p>
	int numero;<p>
public:<p>
	armazenagem() {numero=0;}<p>
	void armazenagempp() {numero++;}<p>
	void armazenagemmm() {numero--;}<p>
	int get_numero() {return numero;}<p>
};<p>
</CODE><p>
N&atilde;o se esque&ccedil;a de chamar os fun&ccedil;&atilde;o membros de
armazenagem nos construtores dos robos.<p>
<p>
2)Use vari&aacute;veis static em seus programas para que fazem
aloca&ccedil;&atilde;o din&acirc;mica para controlar o n&uacute;mero de objetos
criados e n&atilde;o deletados. Use por exemplo o objeto lista de 2.1.4 e
verifique a import&acirc;ncia desta t&eacute;cnica para o desenvolvimento de
programas que sejam corretos no uso da mem&oacute;ria din&acirc;mica (heap),
principalmente em C++ que n&atilde;o fornece coleta autom&aacute;tica de lixo.
<p>
	Usar t&eacute;cnicas deste tipo em M&oacute;dula-3 &eacute; imposs&iacute;vel
porque a linguagem n&atilde;o suporta construtores e destrutores, por&eacute;m
a coleta autom&aacute;tica de lixo, "Garbage Collection" , j&aacute; faz grande
parte do trabalho para o programador. Em C++ existem t&eacute;cnicas
avan&ccedil;adas  de programa&ccedil;&atilde;o para conseguir coleta
autom&aacute;tica de lixo para alguns tipos, essas t&eacute;cnicas se baseiam
na chamada de autom&aacute;tica  de um destrutor quando um objeto sai de
escopo, e tamb&eacute;m no uso de "templates".<p>
<p>
3) Existe uma linguagem de programa&ccedil;&atilde;o chamada Logo que &eacute;
muito usada no Brasil em escolas de primeiro e segundo grau. Nesta linguagem
voc&ecirc; pode programar os movimentos na tela de uma tartaruginha ou cursor.
Este cursor descreve movimentos riscando ou n&atilde;o a tela, dentre os
movimentos descritos est&atilde;o c&iacute;rculos, quadrados e sequ&ecirc;ncias
repetitivas (loops). Modifique seu objeto robo para apresentar alguns desses
recursos. Crie ent&atilde;o um programa que l&ecirc; de um arquivo texto
instru&ccedil;&otilde;es para este objeto robo executar movimentos na tela.<p>
	Logo foi criada por um cientista de computa&ccedil;&atilde;o do MIT.<p>
<a name="_Toc342737009"><a name="_Toc345409445"><a name="_Toc345810950"><a name="_Toc345838280"><a name="_Toc345942415"><a name="_Toc345949575"><a name="_Toc346168692"><a name="_Toc348417135"><a name="_Toc348931391"><a name="_Toc353900830"><a name="_Toc353946360">
<h3>
<a name="RTFToC70">4.4.2.
UM TIPO DEFINIDO PELO USU&Aacute;RIO USADO COMO
STATIC</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<b></b><p>
<b>	</b>Trechos de um programa com um objeto<CODE> static
</CODE>representando uma lista parametrizada (templates). A estrutura
poderia  ser  parametrizada de modo a armazenar informa&ccedil;&otilde;es sobre
os estados dos demais objetos, permitindo que eles realizem algum tipo de
intera&ccedil;&atilde;o. Neste exemplo vamos s&oacute; armazenar os
m&oacute;dulos das dist&acirc;ncia que os robos se moveram
(fun&ccedil;&atilde;o membro <CODE>move()</CODE>)<b></b><p>
<b>	</b>Fa&ccedil;a a inclus&atilde;o do arquivo que define sua estrutura de
armazenamento, "storage", no seu projeto:<p>
<p>
<CODE>#include "mlistht.h"</CODE><b></b><p>
<b></b><p>
<b></b>Crie o atributo <CODE>static</CODE> com o encapsulamento
desejado na defini&ccedil;&atilde;o da classe <CODE>robo</CODE>. Se
preciso indique o tipo parametrizado:<p>
<CODE><b></b><p>
<b></b>class faca_estatisticas_sobre_mim {<p>
private:<p>
	static lista&lt;float&gt; registro;  //storage class<p>
public: ...<p>
</CODE><b></b><p>
<b></b>Acesse o atributo<CODE> static</CODE> aonde seu
encapsulamento permite atrav&eacute;s de chamadas de fun&ccedil;&otilde;es
membro como: <CODE><p>
registro.insere_ultimo(a);<b></b><p>
<b></b></CODE><b></b><p>
<b></b>Tente fazer este exemplo sozinho, depois confira com o programa a
seguir: <CODE><p>
<b><hr></b><p>
<b></b>#include &lt;iostream.h&gt;<p>
#include &lt;math.h&gt;<p>
#include "mlistht.h"<p>
<p>
class robot {<p>
private:<p>
	float x,y; //posicoes<p>
	static lista&lt;float&gt; deltas;//guarda os passos dados<p>
public:<p>
	robot(float a,float b)<p>
	{<p>
	x=a;<p>
	y=b;<p>
	} //cria robo<p>
	void move(float dx,float dy)<p>
	{<p>
	 x+=dx;<p>
	 y+=dy;<p>
	 deltas.insere_primeiro(sqrt(x*x+y*y));<p>
	}<p>
	static void mostra_lista(void)<p>
	{<p>
	deltas.mostra();<p>
	cout &lt;&lt; endl;<p>
	}<p>
	~robot(void) {} //mata robo<p>
	};<p>
<p>
lista&lt;float&gt; robot::deltas; //chama o construtor.<p>
<p>
main()<p>
{<p>
<p>
robot *r1=new robot(0.0,0.0); //cria robo 1<p>
r1-&gt;move(1,1);<p>
robot *r2;<p>
robot::mostra_lista(); //mostra lista.<p>
r2=new robot(1.0,1.0);  //cria robo 2<p>
robot::mostra_lista(); //mostra lista.<p>
r2-&gt;move(10,10);<p>
robot::mostra_lista(); //mostra lista.<p>
delete r1;<p>
delete r2;<p>
<p>
return 0;<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Resultado do programa:</b><p>
<b></b>=(1.41421)-<p>
=(1.41421)-<p>
=(15.5563)-(1.41421)-<p>
<b></b><p>
<b>Static e fun&ccedil;&otilde;es comuns: </b><p>
<b>	</b>Fun&ccedil;&otilde;es comuns tamb&eacute;m podem ter vari&aacute;veis
static e n&atilde;o s&oacute; objetos. Neste caso as vari&aacute;veis
permanecem ativas durante chamadas da fun&ccedil;&atilde;o.<p>
<b></b><p>
<b>Exerc&iacute;cios: </b><p>
<b></b>1)Defina uma estrutura de dados mais eficiente para busca que uma lista,
use-a como<CODE> static</CODE> no exemplo acima. Faca com que os
robos atendam ao seguinte fun&ccedil;&atilde;o membro:
<CODE>encontra_proximo(void); </CODE> que faz com que um robo se
mova at&eacute; a posi&ccedil;&atilde;o do companheiro mais pr&oacute;ximo
dele. Perceba que agora voc&ecirc; tem que armazenar a posi&ccedil;&atilde;o de
cada rob&ocirc; na estrutura, juntamente com um identificador deste
rob&ocirc;.<p>
<p>
2)Defina de modo an&aacute;logo ao exerc&iacute;cio anterior
fun&ccedil;&otilde;es membro como agrupa, que faz com que os robos se movam uma
unidade de comprimento em dire&ccedil;&atilde;o ao centro de massa do grupo.
Suponha que todos os robos tenham a mesma massa.<p>
<p>
3)Voc&ecirc; pode desejar armazenar as informa&ccedil;&otilde;es da
classe<CODE> robot</CODE> em outra classe, que computa outros
c&aacute;lculos, neste caso temos pelo menos duas alternativas a
seguir:<b></b><p>
<b></b>	a)Crie uma classe auxiliar externa de armazenagem e para todos
objetos<CODE> robo </CODE>instanciados passe o ponteiro desta
classe auxiliar como argumento do construtor . Assim esses objetos
poder&atilde;o mandar mensagens para esta classe de armazenagem. Essas
mensagens, chamadas de fun&ccedil;&otilde;es membro, podem ter v&aacute;rios
significados, num sentido figurado podemos ter algo parecido com: "Classe
auxiliar, armazene essa informa&ccedil;&atilde;o para mim". "Classe auxiliar,
me mande uma mensagem daqui a cinco segundos, estou passando o ponteiro para
mim mesmo <CODE> (this) </CODE>" , etc. <p>
<b>	</b>As mensagens vistas desse modo ficam mais interessantes, voc&ecirc;
pode at&eacute; achar engra&ccedil;ado, mas &eacute; muito pr&aacute;tico
pensar assim. Quando estudarmos simula&ccedil;&otilde;es dirigidas a eventos em
4.6.2 veremos a import&acirc;ncia destas trocas de mensagens entre
objetos.<b></b><p>
<b></b>	b)Usar friends para que a classe de armazenagem e c&aacute;lculo e a
classe <CODE>robot </CODE>possam interagir.<p>
<b></b><p>
<b></b>4) Em alguma classe que voc&ecirc; criou anteriormente defina
vari&aacute;veis <CODE>static </CODE>com o seguinte objetivo:
Contar, fazer estat&iacute;sticas das chamadas de fun&ccedil;&atilde;o membros
de classe.<p>
<p>
5)Use o que foi aprendido sobre "<CODE>static</CODE> variables" no
programa contas, o objetivo &eacute; armazenar informa&ccedil;&otilde;es sobre
os movimentos de todas as contas num objeto static. Para que a
modifica&ccedil;&atilde;o fique a contento voc&ecirc; pode precisar tornar o
exemplo mais pr&oacute;ximo da realidade, adicionando no construtor de contas
um argumento: n&uacute;mero de conta. Comente se voc&ecirc; usaria
aloca&ccedil;&atilde;o din&acirc;mica para essa classe de armazenagem agregada
em conta, ou n&atilde;o. Tenha em mente a quest&atilde;o do tamanho em bytes do
objeto.<p>
<b>
<a name="_Ref342218224"><a name="_Toc342737010"><a name="_Toc345409446"><a name="_Toc345810951"><a name="_Toc345838281"><a name="_Toc345942416"><a name="_Toc345949576"><a name="_Toc346168693"><a name="_Toc348417136"><a name="_Toc348931392"><a name="_Toc353900831"><a name="_Toc353946361"></b>
<h2>
<a name="RTFToC71">4.5.
TRATAMENTO DE
EXCE&Ccedil;&Otilde;ES</a></a></a></a></a></a></a></a></a></a></a></a>
</a></h2>
<b></b><p>
<b>	</b>Adicionando tratamento de exce&ccedil;&otilde;es ao programa vetor do
item  4.3.1.<p>
<CODE><p>
<b><hr></b><p>
<b></b>//header file para classe vetor ex.h<p>
#include &lt;iostream.h&gt;<p>
<p>
const int inicio=0;<p>
<p>
class excecoesvetor {   //to be throwed<p>
 public:  //nao tenho interesse de encapsular por enquanto.<p>
	excecoesvetor(char* texto);<p>
	char* mensagem;<p>
	char* retorna_mensagem(void);<p>
 };<p>
<p>
class excecaoalocacao:public excecoesvetor{<p>
public:<p>
	 excecaoalocacao(char* texto);<p>
};<p>
<p>
class excecaoinstanciacao:public excecoesvetor{<p>
public:<p>
	excecaoinstanciacao(char* texto,int num);<p>
	int quant; //numero de elementos com que se tentou instanciar vetor<p>
};<p>
<p>
class excecaolimite:public excecoesvetor{ //limite de indice desrespeitado<p>
 public:<p>
	excecaolimite(char* texto,int ind,int max);<p>
	int indice; //armazena o indice que gerou excecao<p>
	int maximo; //armazena o indice maximo<p>
	//indice minimo e' fixo para este programa=0<p>
	};<p>
<p>
<p>
excecoesvetor::excecoesvetor(char* texto)<p>
{ mensagem=texto;}<p>
<p>
char* excecoesvetor::retorna_mensagem(void)<p>
{ return mensagem; }<p>
<p>
excecaolimite::excecaolimite(char* texto,int ind,int
max):excecoesvetor(texto)<p>
{ indice=ind; maximo=max;}<p>
<p>
excecaoinstanciacao::excecaoinstanciacao(char* texto,int
num):excecoesvetor(texto)<p>
{ quant=num; }<p>
<p>
excecaoalocacao::excecaoalocacao(char* texto):excecoesvetor(texto)<p>
{}<p>
<p>
template&lt;class T&gt; class vetor{ //T e' o tipo do elemento do vetor<p>
private:<p>
T* v;  //pode ser qualquer tipo que atenda as operacoes &lt; &gt; =<p>
int tamanho;<p>
public:<p>
vetor (int tamanho) ;<p>
T&amp; operator[] (int i);<p>
T maximo();<p>
int primeiro(void);<p>
int ultimo(void);<p>
};<p>
<p>
template&lt;class T&gt; vetor&lt;T&gt;::vetor (int tam)<p>
{<p>
if (tam&lt;1)<p>
	throw excecaoinstanciacao("Vetores de tamanho &lt;1. Sao invalidos.",tam);<p>
v=new T[tam];<p>
if (v==NULL)<p>
	 throw excecaoinstanciacao("Nao consegui alocar memoria",tam);<p>
tamanho=tam;<p>
}<p>
<p>
template&lt;class T&gt; int vetor&lt;T&gt;::primeiro (void)<p>
{return inicio;}<p>
<p>
template&lt;class T&gt; int vetor&lt;T&gt;::ultimo (void)<p>
{return tamanho-1;}<p>
<p>
template&lt;class T&gt; T&amp; vetor&lt;T&gt;::operator[](int i)<p>
{<p>
 if (i&lt;0 || i&gt;=tamanho)<p>
 throw excecaolimite("Fora dos limites.",i,tamanho);<p>
 return v[i];<p>
}<p>
<p>
template&lt;class T&gt; T vetor&lt;T&gt;:: maximo(void)<p>
{<p>
 int candidato=inicio;<p>
 for (int i=inicio;i&lt;tamanho;i++)<p>
 if (v[i]&gt;v[candidato]) candidato=i;<p>
 return v[candidato];<p>
}<p>
<b></b><p>
<b><hr></b><p>
<b></b><p>
<b></b>//main file<p>
#include &lt;iostream.h&gt;<p>
#include "ex.h"<p>
main()<p>
{<p>
try<p>
{<p>
 int ind; //indice, usado para atualizacoes<p>
 float item; //item, usado para insercoes no vetor<p>
<p>
 vetor&lt;float&gt;* meu;<p>
<p>
 try<p>
  { meu=new vetor&lt;float&gt;(5); }<p>
 catch  (excecaoinstanciacao&amp; e)<p>
  {<p>
	cout &lt;&lt; "Excecao gerada! O  vetor nao pode ser criado." &lt;&lt; endl;<p>
	cout &lt;&lt; e.retorna_mensagem() &lt;&lt; endl;<p>
	cout &lt;&lt; "O indice invalido e':"&lt;&lt; e.quant &lt;&lt; endl;<p>
	cout &lt;&lt; "O programa sera terminado." &lt;&lt; endl;<p>
	throw; //~rethrow<p>
  }<p>
 catch (excecaoalocacao&amp; e)<p>
  {<p>
	cout &lt;&lt; "Excecao gerada! O vetor nao pode ser criado." &lt;&lt; endl;<p>
	cout &lt;&lt; e.retorna_mensagem() &lt;&lt; endl;<p>
	cout &lt;&lt; "O programa sera terminado." &lt;&lt; endl;<p>
	throw;<p>
 }<p>
 catch (excecoesvetor&amp; e)<p>
  {<p>
	cout &lt;&lt; "Esta excecao nao estava prevista em nosso
codigo."&lt;&lt;endl;<p>
	cout &lt;&lt; "Pode ser resultado de uma extensao na hierarquia de
excecoes."&lt;&lt;endl;<p>
   cout &lt;&lt; e.retorna_mensagem() &lt;&lt; endl;<p>
  }<p>
<p>
 for (int i=meu-&gt;primeiro();i&lt;=meu-&gt;ultimo();i++)<p>
 {<p>
  cout &lt;&lt; "Entre com valor da posicao:" &lt;&lt; i &lt;&lt; "\n";<p>
  cin &gt;&gt; meu-&gt;operator[](i);<p>
 }<p>
<p>
 for (int j=meu-&gt;primeiro();j&lt;=meu-&gt;ultimo();j++) cout&lt;&lt;
(*meu)[j]&lt;&lt; " ";<p>
<p>
 cout &lt;&lt; "Entre com o indice da posicao a atualizar:\n";<p>
 cin &gt;&gt; ind;<p>
 cout &lt;&lt; "Entre com o valor a incluir:";<p>
 cin  &gt;&gt; item;<p>
<p>
 try{(*meu)[ind]=item;}<p>
 catch  (excecaolimite&amp; e)<p>
 {<p>
  cout &lt;&lt; "\a Subscripting desconsiderado."&lt;&lt;endl;<p>
  cout &lt;&lt; e.retorna_mensagem() &lt;&lt; endl;<p>
 }<p>
 //incluir um loop ate obter do teclado valores validos.<p>
<p>
 for (int k=meu-&gt;primeiro();k&lt;=meu-&gt;ultimo();k++) cout&lt;&lt;
(*meu)[k]&lt;&lt; " ";<p>
 cout &lt;&lt;endl &lt;&lt; "Maximo:" &lt;&lt; meu-&gt;maximo();<p>
<p>
 return 0;<p>
 }//try<p>
 catch(...)<p>
 {<p>
  cout &lt;&lt; "Excecoes nao tratadas, fim do programa."&lt;&lt;endl;<p>
 }<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Resultado normal do programa:</b><p>
<b></b>Entre com valor da posicao:0<p>
5.2<p>
Entre com valor da posicao:1<p>
5632.2<p>
Entre com valor da posicao:2<p>
12.5<p>
Entre com valor da posicao:3<p>
12<p>
Entre com valor da posicao:4<p>
2.21<p>
5.2 5632.2 12.5 12 2.21 Entre com o indice da posicao a atualizar:<p>
0<p>
Entre com o valor a incluir:2<p>
2 5632.2 12.5 12 2.21<p>
Maximo:5632.2<p>
<b></b><p>
<b>Resultado anormal devido a &iacute;ndice inv&aacute;lido dado ao
programa:</b><p>
<b></b>Entre com valor da posicao:0<p>
2.2<p>
Entre com valor da posicao:1<p>
5.9<p>
Entre com valor da posicao:2<p>
4.1<p>
Entre com valor da posicao:3<p>
65.5<p>
Entre com valor da posicao:4<p>
2.3<p>
2.2 5.9 4.1 65.5 2.3 Entre com o indice da posicao a atualizar:<p>
6<p>
Entre com o valor a incluir:4.5<p>
 Subscripting desconsiderado.<p>
Fora dos limites.<p>
2.2 5.9 4.1 65.5 2.3<p>
Maximo:65.5<p>
<b></b><p>
<b>Resultado anormal devido a falha de aloca&ccedil;&atilde;o de
mem&oacute;ria</b>:<p>
Excecao gerada! O  vetor nao pode ser criado.<p>
Nao consegui alocar memoria<p>
O indice invalido e':5<p>
O programa sera terminado.<p>
Excecoes nao tratadas, fim do programa.<p>
<b></b><p>
<b>Resultado anormal devido a numero de elementos do vetor &lt; 1:</b><p>
<b></b>Excecao gerada! O  vetor nao pode ser criado.<p>
Vetores de tamanho &lt;1. Sao invalidos.<p>
O indice invalido e':-5<p>
O programa sera terminado.<p>
Excecoes nao tratadas, fim do programa.<p>
<b></b><p>
<b>Exerc&iacute;cios:</b><p>
<b></b>1) Implemente, adicione tratamento de exce&ccedil;&otilde;es para o
exemplo de 4.1.2. Antes fa&ccedil;a um levantamento das exce&ccedil;&otilde;es
que podem ser geradas, lembre das restri&ccedil;&otilde;es matem&aacute;ticas
para o denominador em uma divis&atilde;o. Leve em conta tamb&eacute;m o
overflow de vari&aacute;veis<CODE> long</CODE> que s&atilde;o uma
representa&ccedil;&atilde;o com n&uacute;mero de bits finito da sequencia dos
n&uacute;meros inteiros (conjunto Z da matem&aacute;tica). Compare este
tratamento com o de outros programas por exemplo na divis&atilde;o por zero,
quais as vantagens que voc&ecirc; pode apontar e desvantagens?<p>
<b>
<a name="_Toc342737011"><a name="_Toc345409447"><a name="_Toc345810952"><a name="_Toc345838282"><a name="_Toc345942417"><a name="_Toc345949577"><a name="_Toc346168694"><a name="_Toc348417137"><a name="_Toc348931393"><a name="_Toc353900832"><a name="_Toc353946362"></b>
<h2>
<a name="RTFToC72">4.6.
CONCLUS&Otilde;ES</a></a></a></a></a></a></a></a></a></a></a>
</a></h2>
<p>
	Neste t&oacute;pico apresentaremos programas mais elaborados dentre eles uma
simula&ccedil;&atilde;o dirigida a eventos e uma implementa&ccedil;&atilde;o de
uma &aacute;rvore bin&aacute;ria.<p>
<a name="_Toc342737012"><a name="_Toc345409448"><a name="_Toc345810953"><a name="_Toc345838283"><a name="_Toc345942418"><a name="_Toc345949578"><a name="_Toc346168695"><a name="_Toc348417138"><a name="_Toc348931394"><a name="_Toc353900833"><a name="_Toc353946363">
<h3>
<a name="RTFToC73">4.6.1.
&Aacute;RVORE BIN&Aacute;RIA.</a></a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
Este programa implementa uma &aacute;rvore bin&aacute;ria e testa-a:
<CODE><p>
<b><hr></b><p>
#include&lt;iostream.h&gt;<p>
const TRUE=1;<p>
const FALSE=0;<p>
<p>
class no //no agregado na classe arvore, por razoes de encapsulamento<p>
{<p>
private:<p>
 int info;    //atributo informacao, use template depois...<p>
 no* esq;   //subarvore esquerda<p>
 no* dir; //subarvore direita<p>
 int busca_maisesq(void);<p>
public:<p>
 no(int a);  //sem filhos<p>
 no(int a,no* b,no* c);  //com filhos<p>
 int retorna_quant(void);<p>
 no* insere(int a,int&amp; res);<p>
 no* remove(int b,int&amp; res);//res = resultado (sucesso?)<p>
 int busca(int c); //busca binaria<p>
 void in_order(); //parentisada<p>
 ~no(void); //destrutor da arvore/subarvore<p>
 static int quant; //so para testes, pode ser public.<p>
};<p>
<p>
<p>
class arv_bin { //encapsula no e redireciona chamadas de metodos<p>
private:<p>
 no* ar;<p>
public:<p>
arv_bin(void);<p>
arv_bin(int a);<p>
void insere(int a,int&amp; result);<p>
void remove(int b,int&amp; result);<p>
int busca(int c); //busca binaria<p>
void in_order(); //parentisada<p>
~arv_bin(void);<p>
};<p>
<p>
<b><hr></b><p>
<p>
#include&lt;iostream.h&gt;<p>
#include&lt;stdlib.h&gt;<p>
#include"binatree.h"<p>
<p>
int no::quant=0; //aqui eu uso uma variavel static<p>
<p>
no::no(int a)<p>
{info=a; esq=NULL; dir=NULL;quant++;}<p>
<p>
no::no(int a,no* b,no* c) //constructor<p>
{info=a;esq=b;dir=c;quant++;}<p>
<p>
int no::retorna_quant(void)<p>
{ return quant; }<p>
<p>
int no:: busca_maisesq(void)<p>
{<p>
 if  ((*this).esq==0) return info;<p>
 else return ((*this).esq-&gt;busca_maisesq());<p>
//chamada recursiva.<p>
}<p>
<p>
no* no::insere(int a,int&amp; res)<p>
{<p>
 res=1;<p>
 if (this==NULL) return new no(a,NULL,NULL);<p>
 if (a&gt;=info) if (dir==NULL) dir=new no(a,NULL,NULL);<p>
				 else dir=(*dir).insere(a,res);<p>
 else  if (a&lt;info) if (esq==NULL) esq=new no(a,NULL,NULL);<p>
						 else esq=(*esq).insere(a,res);<p>
 return this; //nao e necessario.<p>
};<p>
<p>
<p>
no* no::remove(int b,int&amp; res)<p>
{<p>
  int copy;<p>
  no* delete_aux;<p>
  no* return_aux; //usado para deletar um no<p>
  if (this==NULL) {<p>
							res=FALSE;<p>
							return NULL; //arvore ou subarvore vazia<p>
						}<p>
  else //not a nill pointer<p>
	if (b&gt;(*this).info) (*this).dir=(*this).dir-&gt;remove(b,res);<p>
	 if (b&lt;(*this).info) (*this).esq=(*this).esq-&gt;remove(b,res);<p>
	  if (b==(*this).info) //preciso deletar aqui<p>
	  {<p>
		res=TRUE;<p>
		if (((*this).dir==NULL) &amp;&amp; ((*this).esq==NULL)) //sem filhos<p>
			{<p>
			delete this;<p>
			return NULL;<p>
			}<p>
		else if ((*this).esq==NULL) //como remover de lista linear<p>
			  {<p>
			  delete_aux=this;<p>
			  return_aux=((*this).dir);<p>
			  (*delete_aux).dir=NULL; //evita deletar subarvore<p>
			  delete delete_aux;<p>
			  return return_aux;<p>
			  }<p>
			  else if ((*this).dir==NULL) //como lista linear<p>
					 {<p>
					 delete_aux=this;<p>
					 return_aux=(*this).esq;<p>
					 (*delete_aux).esq=NULL;<p>
					 delete delete_aux;  //nao esqueca<p>
					 return return_aux;<p>
					 }<p>
					 else //o caso mais complicado<p>
					 {<p>
					  copy=(*this).dir-&gt;busca_maisesq();<p>
					  info=copy;<p>
					  (*this).dir=(*this).dir-&gt;remove(copy,res);<p>
					 }<p>
	  }<p>
  return this; //para muitos casos.<p>
}<p>
<p>
<p>
int no::busca(int c)<p>
{<p>
 if (this!=NULL)<p>
  if (c==info) return c;<p>
  else if (c&gt;info) return ((*dir).busca(c));<p>
		 else return ((*esq).busca(c));<p>
 else return -c;<p>
<p>
}<p>
<p>
<p>
void no::in_order(void)   //percurso in_order<p>
{<p>
 if (this!=NULL)<p>
 {<p>
 cout &lt;&lt; "(" ;<p>
 (*esq).in_order();<p>
 cout &lt;&lt; info;<p>
 (*dir).in_order();<p>
 cout &lt;&lt; ")";<p>
 };<p>
}<p>
<p>
no::~no(void)<p>
{<p>
if (this!=NULL)<p>
 {<p>
 quant--;<p>
 if (dir!=NULL) delete dir; //primeiro chama destrutor depois deleta no<p>
 if (esq!=NULL) delete esq; //o destrutor e chamado para toda a arvore e
entao<p>
 }<p>
//ela volta deletando os nos<p>
}<p>
<p>
<p>
<p>
arv_bin::arv_bin(void)<p>
{ ar=NULL;} <p>
<p>
arv_bin::arv_bin(int a)<p>
 { ar=new no(a);}<p>
<p>
//inline<p>
void arv_bin::insere(int a,int&amp; result)<p>
 { ar=ar-&gt;insere(a,result); }<p>
<p>
//inline<p>
 void arv_bin::remove(int a,int&amp; result)<p>
 { ar=ar-&gt;remove(a,result);}<p>
<p>
//inline<p>
 int arv_bin::busca(int a)<p>
 { return ar-&gt;busca(a); }<p>
<p>
//inline<p>
 void arv_bin::in_order(void)<p>
 { ar-&gt;in_order(); }<p>
<p>
arv_bin::~arv_bin()<p>
 { delete ar; }<p>
<p>
<b><hr></b><p>
<p>
#include &lt;iostream.h&gt;<p>
#include "binatree.h"<p>
<p>
main() //testa a arvore com menu.<p>
{<p>
int n; //lido para ser inserido ou removido.<p>
int flag;<p>
arv_bin my_tree;<p>
char option='w';<p>
do<p>
{<p>
cout &lt;&lt; endl;<p>
cout &lt;&lt; " I-Insere\n";<p>
cout &lt;&lt; " R-Remove\n";<p>
cout &lt;&lt; " N-In Order (Percurso)\n";<p>
cout &lt;&lt;7 " B-Busca\n";<p>
cout &lt;&lt; " S-Sair\n";<p>
cout &lt;&lt; " Entre opcao:";<p>
cout &lt;&lt; " \n";<p>
cin &gt;&gt;option; //entre a opcao do menu<p>
 switch(option) //executes user option<p>
 {<p>
  case 'I':<p>
  case 'i':<p>
				cout &lt;&lt; "\n Digite numero a inserir:";<p>
				cin &gt;&gt; n;<p>
				cout &lt;&lt; "\n";<p>
				flag=FALSE;<p>
				my_tree.insere(n,flag);<p>
				cout &lt;&lt; "flag:"&lt;&lt;flag &lt;&lt; endl;<p>
				break;<p>
  case 'R':<p>
  case 'r':<p>
				cout &lt;&lt; "\n Digite numero a remover:";<p>
				cin &gt;&gt; n;<p>
				cout &lt;&lt; "\n";<p>
				flag=FALSE;<p>
				my_tree.remove(n,flag);<p>
				cout &lt;&lt; "flag:"&lt;&lt;flag &lt;&lt; endl;<p>
				break;<p>
  case 'N':<p>
  case 'n':<p>
				cout &lt;&lt; "\n";<p>
				my_tree.in_order();<p>
				cout &lt;&lt; " " &lt;&lt; no::quant &lt;&lt; ":Nos\n";<p>
				cout &lt;&lt; "\n";<p>
				break;<p>
  case 'B':<p>
  case 'b':<p>
				cout &lt;&lt; "\n Digite numero a achar:";<p>
				cin &gt;&gt; n;<p>
				cout &lt;&lt; "\n";<p>
				cout &lt;&lt; " " &lt;&lt; my_tree.busca(n);<p>
				cout &lt;&lt; "\n";<p>
				break;<p>
  case 'S':<p>
  case 's':<p>
				cout &lt;&lt; "\n BYE \n";<p>
				break;<p>
  default:  ;<p>
 }  //switch-case code block<p>
} while ((option!='s')&amp;&amp;(option!='S'));<p>
cout &lt;&lt; " Nodes:" &lt;&lt; no::quant &lt;&lt; endl;<p>
return 0;<p>
}<p>
<b><hr></b><p>
</CODE><b></b><p>
<b>Resultado do programa:</b><p>
<b></b>	N&atilde;o pode ser exibido por ser muito extenso.<p>
<b>
<a name="_Ref345754631"><a name="_Toc345810954"><a name="_Toc345838284"><a name="_Toc345942419"><a name="_Toc345949579"><a name="_Toc346168696"><a name="_Toc348417139"><a name="_Toc348931395"><a name="_Toc353900834"><a name="_Toc353946364"></b>
<h3>
<a name="RTFToC74">4.6.2.
SIMULA&Ccedil;&Atilde;O DIRIGIDA A
EVENTOS.</a></a></a></a></a></a></a></a></a></a>
</a></h3>
<p>
<p>
	Este t&oacute;pico &eacute; o &uacute;ltimo e o &uacute;nico que ainda
est&aacute; sendo editado.<p>
	Este exemplo apresenta uma simula&ccedil;&atilde;o dirigida a eventos.
Simulamos um banco, as vari&aacute;veis da simula&ccedil;&atilde;o s&atilde;o:
tempo m&eacute;dio de entrada de clientes no banco, tempo m&eacute;dio de
atendimento, n&uacute;mero de atendentes. <p>
A  linguagem precursora das atuais linguagens orientadas a objetos, Simula,
n&atilde;o por acaso foi criada para programar simula&ccedil;&otilde;es. Em
programa&ccedil;&atilde;o orientada a objetos estamos frequentemente
preocupados em modelar entidades, objetos, do mundo real, &eacute; justamente
esta a tarefa de uma simula&ccedil;&atilde;o.<p>
	Voc&ecirc; notar&aacute; que nosso programa principal &eacute; bastante
pequeno. Ocorre que <CODE>main</CODE> &eacute; usado para apenas
inicializar os objetos e a simula&ccedil;&atilde;o, a maioria das
a&ccedil;&otilde;es ocorre atrav&eacute;s de chamadas de fun&ccedil;&otilde;es
membro entre os objetos, isto &eacute; muito bom, evitamos ao m&aacute;ximo a
presen&ccedil;a de vari&aacute;veis locais e passagem por refer&ecirc;ncia.<p>
<A href="bancosim.gif">Click here for Picture </A><p>
	O diagrama mostra o cen&aacute;rio de nossa simula&ccedil;&atilde;o:<p>
<p>
<p>
Neste diagrama est&atilde;o presentes as classes com que iremos trabalhar:
<CODE>costumer, clerk, scheduler</CODE>, <CODE>manager,
front_door, geometric. Costumer e clerk </CODE>s&atilde;o subclasses de
<CODE>active</CODE>, uma classe base abstrata. <CODE>
Manager, costumer, clerk </CODE>s&atilde;o objetos reais, existiriam no
mundo real. <CODE>Scheduler</CODE> e <CODE>front_door,
</CODE> <CODE>geometric </CODE>n&atilde;o s&atilde;o objetos
reis, s&atilde;o criados para auxiliar na simula&ccedil;&atilde;o.<p>
Nossa simula&ccedil;&atilde;o &eacute; do tipo discreta, dirigida a eventos, em
contraposi&ccedil;&atilde;o com o tipo cont&iacute;nuo. Ou seja estaremos
atentos, monitorando,eventos tais como o fato de um cliente entrar no banco ou
ser atendido e n&atilde;o grandezas continuas como a vaz&atilde;o de uma bomba
hidr&aacute;ulica ou a velocidade de um motor el&eacute;trico. <p>
Nossa simula&ccedil;&atilde;o &eacute; dita discreta porque os eventos ocorrem
em intervalos fixos de tempo e n&atilde;o entre eles, o n&uacute;mero desses
intervalos &eacute; escolhido pelo usu&aacute;rio e deve ser grande com
rela&ccedil;&atilde;o aos tempos usados na simula&ccedil;&atilde;o (tempo
m&eacute;dio de atendimento, etc). Estes tempos m&eacute;dios por serem
inteiros devem ser escolhidos de forma a n&atilde;o gerar casos degenerados, ou
seja se voc&ecirc; estimou que em seu banco o tempo de atendimento &eacute; em
geral tr&ecirc;s vezes maior que o tempo m&eacute;dio de entrada de clientes no
banco, ent&atilde;o prefira uma rela&ccedil;&atilde;o do tipo (27/9) ao
env&eacute;s de (9/3), esses tempos continuar&atilde;o pequenos perto do tempo
de durac&atilde;o da simula&ccedil;&atilde;o: 10000, por&eacute;m n&atilde;o
t&atilde;o pequenos que possam ser pouco
[[dieresis]]representativos[[dieresis]] em termos de tempos diferentes que
podem ocorrer. Entenda por casos degenerados, casos que n&atilde;o ser&atilde;o
capazes de representar, modelar corretamente o que aconteceria em seu banco,
fornecendo resultados discrepantes com outras op&ccedil;&otilde;es equivalentes
(em termos de propor&ccedil;&otilde;es) de valores iniciais da
simula&ccedil;&atilde;o.<p>
	Um pouco sobre estat&iacute;stica e probalilidade. Vamos precisar de conceitos
de estat&iacute;stica neste problema. A tempo de atendimento de clientes segue
usualmente uma distribui&ccedil;&atilde;o geom&eacute;trica (lembre-se que em
estat&iacute;stica existem distribui&ccedil;&otilde;es discretas e
cont&iacute;nuas), a nossa &eacute; discreta. A linguagem s&oacute; oferece a
distribui&ccedil;&atilde;o de n&uacute;meros conhecida como uniforme ,aquela em
que todos n&uacute;meros tem a mesma probabilidade de serem sorteados, ela pode
ser gerada por chamadas a fun&ccedil;&atilde;o rand() da
[[dieresis]]library[[dieresis]] stdlib.h, rand() gera n&uacute;meros
pseudo-aleat&oacute;rios na faixa de 0 at&eacute; RAND_MAX (n&atilde;o se
preocupe, RAND_MAX est&aacute; definido na stdlib.h e &eacute;
geralmente==32767).<p>
	Dizemos que <CODE>rand()</CODE> gera n&uacute;meros
pseudo-aleat&oacute;rios porque esta fun&ccedil;&atilde;o utiliza uma semente
para gerar uma sequ&ecirc;ncia de n&uacute;meros, esta sequ&ecirc;ncia de
n&uacute;meros pode ser repetida, basta utilizar a mesma semente. Esta
poss&iacute;bilidade de repeti&ccedil;&atilde;o ser&aacute; importante para
realizar testes do programa, frequentemente o programador deseja repetir o
resultado da &uacute;ltima execu&ccedil;&atilde;o, isto s&oacute; &eacute;
poss&iacute;vel se for fornecida a mesma semente de gera&ccedil;&atilde;o dos
n&uacute;meros atrav&eacute;s de uma chamada a fun&ccedil;&atilde;o
<CODE>void srand(unsigned s) </CODE>, j&aacute; importada com as
"libraries" que voc&ecirc; utilizar&aacute; na simula&ccedil;&atilde;o.<p>
	Felizmente dispomos de uma maneira de construir um gerador de n&uacute;meros
que obedecem uma distribui&ccedil;&atilde;o geom&eacute;trica, a partir de um
gerador de n&uacute;meros aleat&oacute;rios. A distribui&ccedil;&atilde;o
uniforme precisa como parametro um valor m&aacute;ximo, enquanto que a
geom&eacute;trica precisa de um valor m&eacute;dio. <p>
Na distribui&ccedil;&atilde;o geom&eacute;trica, se um cliente &eacute;
atendido em um tempo m&eacute;dio de 10, ent&atilde;o podemos dizer que se ele
tiver come&ccedil;ado a ser atendido agora, existe em m&eacute;dia uma chance
em dez de ele terminar de ser atendido no pr&oacute;ximo instante. Vamos supor
que o cliente n&atilde;o foi atendido logo no primeiro instante, ent&atilde;o
existe uma chance em dez de ele ser atendido no pr&oacute;ximo instante e assim
por diante. As probabilidades s&atilde;o iguais e independentes uma das outras.
A soma das probabilidades de cada instante completa 1 no tempo m&eacute;dio de
atendimento que no caso &eacute; 10. Por&eacute;m isto n&atilde;o significa que
10 &eacute; um limite m&aacute;ximo, mas apenas a m&eacute;dia!<p>
	Se a probabilidade p de o cliente ser atendido no instante atual &eacute;
p==(1/m&eacute;dia) ent&atilde;o a probabilidade de ele n&atilde;o ser atendido
&eacute; (1-p). Seguindo o racioc&iacute;nio anterior, a probabilidade de o
cliente ser atendido no primeiro tique do rel&oacute;gio &eacute; p. A
probabilidade que o mesmo cliente seja atendido s&oacute; no segundo tique
&eacute; igual a probabilidade de ele n&atilde;o ser atendido no primeiro
tique==(1-p) <b>e (*)</b> a probabilidade de ele ser atendido no segundo
tique==p (igual a p para todos os instantes isolados). Seguindo o mesmo
racioc&iacute;nio, a probabilidade de o cliente vir a ser atendido s&oacute; no
terceiro tique &eacute; (1-p)*(1-p)*p. A formula geral da probabilidade de um
cliente esperar t tiques enquanto &eacute; atendido &eacute;:
p*((1-p)&#136;(t-1)).<p>
	Suponha que tomamos n=100 bolas, das quais pintamos (n/m&eacute;dia) de branco
e o restante de preto (m&eacute;dia&lt;n). Chamemos de p a probabilidade de se
retirar numa &uacute;nica tentativa uma bola branca de nossas n bolas, p
&eacute; igual a (1/m&eacute;dia). A probabilidade do evento complementar
&eacute; (1-(1/m&eacute;dia))==(1-p). A probabilidade de se obter uma bola
branca s&oacute; na segunda retirada com reposi&ccedil;&atilde;o &eacute;
(1-p)*p, enquanto que s&oacute; na terceira retirada &eacute; (1-p)*(1-p)*p e
assim por diante, como no exemplo anterior.<p>
	Pois bem, as nossas n bolas podem ser vistas como os n&uacute;meros da
distribui&ccedil;&atilde;o uniforme gerada por rand(). Pintar de branco parte
das bolas de branco e o restante de preto equivale a dividir o intervalo de 0
at&eacute; RAND_MAX em n&uacute;meros menores que <CODE>
(RAND_MAX+1/m&eacute;dia)==ways_to_occur </CODE> (brancos) e
n&uacute;meros maiores que isso (pretos). Sortear uma bola e verificar a cor
equivale a chamar <CODE>rand()</CODE> e ver em que intervalo o
resultado cai. Temos ent&atilde;o o procedimento para obter n&uacute;meros
segundo uma distribui&ccedil;&atilde;o geom&eacute;trica a partir de um gerador
de n&uacute;meros aleat&oacute;rios. Construiremos uma classe em nosso programa
para obter estes n&uacute;meros, ser&aacute; a classe geometric. Sua
implementa&ccedil;&atilde;o est&aacute; no arquivo geometric.cpp. <p>
<p>
<A href="cpp153.gif">Click here for Picture </A><p>
<p>
<p>
<CODE><p>
<b><hr></b><p>
//File repair.h<p>
//Header file for costumer-servement simulation<p>
#include &lt;stdlib.h&gt;<p>
#include &lt;iostream.h&gt;<p>
<p>
enum Boolean {FALSE,TRUE};   //0 ou 1<p>
<p>
class scheduler; //classe nao real<p>
class manager;   //classe real<p>
<p>
//class of geometric-distribution random number generators<p>
<p>
class geometric{<p>
            int geo_max;			//maximum value of random number<p>
	int ways_to_occur;  //no. ways desired event can occur<p>
 public:<p>
	geometric(double mean,int max);<p>
	int draw(); //return next random number<p>
	Boolean e_agora(void); //verifica se e agora que entra costumer<p>
 };<p>
<p>
 //Abstract base class of active objects<p>
<p>
 class active{<p>
	active* next; //next-object pointer for linked lists<p>
 public:<p>
	void set_next(active* p) {next=p;}<p>
	active* get_next(void) {return next;}<p>
	virtual void event()=0; //trigger scheduled event<p>
};<p>
<p>
//Class for costumer objects<p>
<p>
class costumer:public active{<p>
	scheduler* sp; //pointer to scheduler<p>
	manager* mp;    //pointer to service manager<p>
	geometric g;	//random number generator<p>
	Boolean is_up;  //state_variable<p>
	int tot_up_time; //tempo total de pe<p>
	int up_time_start; //start of most recent up-period<p>
	static double servedcost; //total number of served costumers<p>
	static double waitedtime; //total waited time for all costumers<p>
public:<p>
	costumer(double mean,int max,scheduler* s,manager* m);<p>
	void event(); //time to be served<p>
	void served(); //Come back home costumer. (Killed)<p>
	static double g_servedcost() {return servedcost;}<p>
	static double g_waitedtime() {return waitedtime;}<p>
	static int vivos; //numero de costumers vivos, so p/debugging<p>
	~costumer() {vivos--;} //so para controle de alocacao dinamica<p>
};<p>
<p>
//Class for clerk objects<p>
<p>
class clerk:public active{<p>
	scheduler* sp; //pointer to scheduler<p>
	manager* mp;   //pointer to service manager<p>
	geometric g;   //random number generator<p>
	costumer* workp; //pointer to costumer under repair<p>
	Boolean is_busy; //state variable<p>
	int busy_time_start; //start of most recent busy period<p>
	int tot_busy_time; //total busy time<p>
public:<p>
	clerk(double mean,int max,scheduler* s,manager*  m);<p>
	void event(); //time to complete repair<p>
	void serve(costumer* p); //acept work assigment<p>
	int busy_time(); //return total busy time<p>
};<p>
<p>
class manager {<p>
	enum who {COSTUMERS,CLERKS,NONE};<p>
	who waiting; //kind of objects in queue<p>
	active* first; //points to first object in queue<p>
	active* last; //points to last object in queue<p>
	double llsum; //line lenght sum (sum every tick, when with costumers)<p>
	int lenght; //comprimento da fila<p>
<p>
	//Private functions for manipulating queue<p>
<p>
	void insert_first(active* p)<p>
		{first=last=p; p-&gt;set_next(0);lenght++;}<p>
	void insert(active* p)<p>
		{last-&gt;set_next(p); p-&gt;set_next(0); last=p;lenght++;}<p>
	void remove()<p>
		{first=first-&gt;get_next();lenght--;}<p>
<p>
//vamos percorrer a lista e sortear clerk desocupado<p>
	clerk* escolhe_randomico(void)<p>
		{  //escolhe randomico<p>
		  int posicao;<p>
		  posicao=(rand() % lenght)+1;  //1..lenght posicao a deletar<p>
		  active* corr=first; //corrente, itera sobre lista<p>
		  active* prev=NULL; //ainda nao esta sobre a lista<p>
		  for (int i=0;i&lt;(posicao-1);i++) //i=local do previo (0...lenght-1)<p>
			{<p>
			prev=corr;<p>
			corr=corr-&gt;get_next(); //desloca ponteiros na lista<p>
			}<p>
			clerk* retorne=(clerk*) corr; //type cast<p>
			if (last==corr) last=prev;<p>
			if (prev==NULL) first=corr-&gt;get_next();<p>
			else prev-&gt;set_next(corr-&gt;get_next());<p>
			lenght--;<p>
			return retorne;<p>
		}	 //escolhe_randomico<p>
public:<p>
	manager() {first=last=0; waiting=NONE;lenght=0;llsum=0;}<p>
	void request_service(costumer* p); //service request<p>
	costumer* request_work(clerk* p); //work request<p>
	void tick(void)<p>
	{ if (waiting==COSTUMERS) llsum+=lenght;}<p>
	double g_llsum(void)<p>
		{ return llsum;}<p>
	~manager()<p>
	 {<p>
	 while (first!=NULL)<p>
	 {active* aux=first; first=first-&gt;get_next(); delete aux;}<p>
	 }<p>
};<p>
<p>
//Class for scheduler<p>
class front_door{<p>
private:<p>
	double media;<p>
	int maximo;<p>
	scheduler* sp;<p>
	manager* mp;<p>
	geometric* g;<p>
public:<p>
  void init(double mean,int max,scheduler* s,manager* m)<p>
		{<p>
		media=mean;<p>
		maximo=max;<p>
		sp=s;<p>
		mp=m;<p>
		g=new geometric(mean,max);<p>
		}<p>
	void sorteia_cost(void)<p>
	 {<p>
	 costumer* esquecame;<p>
	 if (g-&gt;e_agora()) esquecame=new costumer(media,maximo,sp,mp);<p>
	 //nao se preocupe com delecao, o costumer se pendura nas listas<p>
	 //(this) e vai acabar sendo deletado pelo clerk<p>
	 }<p>
	 ~front_door(void) { delete g;}<p>
};<p>
<p>
class scheduler {<p>
	int clock;        	//simulation clock<p>
	int calendar_size;   //size of calendar_queue array<p>
	active** calendar; //pointer to calendar queue array<p>
	int index; //calendar queue array subscript for current time<p>
	front_door* fd;<p>
	manager* m;<p>
public:<p>
	scheduler(int sz,front_door* fdp,manager* mp);<p>
	int time() {return clock;} //return time<p>
	void schedule(active* p,int delay); //schedule event<p>
	void run(int ticks); //run simulation<p>
	~scheduler(void)<p>
	 {<p>
	  for (int i=0;i&lt;calendar_size;i++)<p>
		 {<p>
		  while (calendar[i]!=NULL)<p>
			{<p>
			active* aux;<p>
			aux=calendar[i];<p>
			calendar[i]=calendar[i]-&gt;get_next();<p>
			delete aux;<p>
			}<p>
		 }<p>
	 }<p>
};<p>
<p>
<b><hr></b><p>
<p>
//File geometrc.cpp<p>
//Source file for class geometric<p>
<p>
#include &lt;stdlib.h&gt;<p>
#include "repair.h"<p>
<p>
#ifndef RAND_MAX<p>
#define RAND_MAX 32767<p>
#endif<p>
<p>
//RAND_COUNT is number of different values that<p>
//rand() can return<p>
<p>
const double RAND_COUNT=double(RAND_MAX)+1.0;<p>
<p>
//Initialize geometric-distribution object<p>
<p>
geometric::geometric(double mean, int max)<p>
{<p>
	ways_to_occur=int(RAND_COUNT/mean+0.5);<p>
	geo_max=max;<p>
}<p>
<p>
//Return next geometrically distributed random number<p>
<p>
int geometric::draw()<p>
{<p>
 for (int i=1;i&lt;geo_max;i++)<p>
	if(rand()&lt;ways_to_occur) return i;<p>
 return geo_max;<p>
}<p>
<p>
Boolean geometric::e_agora(void)<p>
{<p>
return (rand()&lt;ways_to_occur);  //chances de entrar agora pela porta<p>
}<p>
<p>
<b><hr></b><p>
<p>
//File active.cpp<p>
//Source file for classes costumer and clerk<p>
#include &lt;iostream.h&gt;<p>
#include "repair.h"<p>
<p>
//Initialize costumer object and schedule first breakdown<p>
<p>
costumer::costumer(double mean,int max,scheduler* s,manager* m):g(mean,max)<p>
{<p>
 sp=s;<p>
 mp=m;<p>
 vivos++; //controle de alocacao dinamica.<p>
 tot_up_time=0;<p>
 is_up=TRUE;<p>
 sp-&gt;schedule(this,g.draw());<p>
 //up_time_start is not initialized here but when costumers enter in bank<p>
}<p>
<p>
//Request service for disabled costumer<p>
<p>
void costumer::event() //entering in the bank, start counting wait time<p>
{<p>
	is_up=FALSE; //not outside the bank<p>
	up_time_start=sp-&gt;time();<p>
	mp-&gt;request_service(this);  //entrou no banco, fica na fila ou vai direto
ao caixa<p>
}<p>
<p>
//Return repaired costumer to service<p>
<p>
void costumer::served()   //may be killed, deleted now.<p>
{<p>
	is_up=TRUE;<p>
	tot_up_time+=sp-&gt;time()-up_time_start;<p>
	waitedtime+=tot_up_time;<p>
	servedcost+=1;<p>
}<p>
<p>
//Initialize clerk object and, if possible, get object's<p>
//First work assignment<p>
<p>
clerk::clerk(double mean,int max,scheduler* s,manager* m):g(mean,max)<p>
{<p>
	sp=s;<p>
	mp=m;<p>
	tot_busy_time=0;<p>
	workp=mp-&gt;request_work(this);<p>
	if (workp==0)<p>
		is_busy=FALSE;<p>
	else {<p>
		is_busy=TRUE;<p>
		busy_time_start=sp-&gt;time();<p>
		sp-&gt;schedule(this,g.draw());<p>
		}<p>
}<p>
<p>
//Complete repair on current costumer; if possible get<p>
//new work assignment<p>
<p>
void clerk::event()<p>
{<p>
	tot_busy_time+=sp-&gt;time()-busy_time_start;<p>
	workp-&gt;served(); //grava estatisticas.<p>
	delete workp;  //mata costumer<p>
	workp=mp-&gt;request_work(this);<p>
	if (workp==0) is_busy=FALSE;<p>
	else {<p>
			is_busy=TRUE;<p>
			busy_time_start=sp-&gt;time();<p>
			sp-&gt;schedule(this,g.draw());<p>
			}<p>
}<p>
<p>
//Acept work assignment<p>
<p>
void clerk::serve(costumer* p)<p>
{<p>
	workp=p;<p>
	is_busy=TRUE;<p>
	busy_time_start=sp-&gt;time();   //comeca contar tempo de ocupado<p>
	sp-&gt;schedule(this,g.draw()); //me tire do atendimente daqui a g.draw
tempos<p>
}<p>
<p>
//Return total busy time<p>
<p>
int clerk::busy_time()<p>
{<p>
	int t=tot_busy_time;<p>
	if (is_busy) t+=sp-&gt;time()-busy_time_start;<p>
	return t;<p>
}<p>
	<p>
<b><hr></b><p>
<p>
//File manager.cpp<p>
//Source file for class manager<p>
#include &lt;iostream.h&gt;<p>
#include "repair.h"<p>
<p>
//Handle service request from disabled costumer<p>
<p>
void manager::request_service(costumer* p)<p>
{<p>
	clerk* q;<p>
	switch(waiting) {<p>
	 case COSTUMERS:<p>
		insert(p);<p>
		return;<p>
	 case CLERKS:<p>
		q=escolhe_randomico(); //pega um clerk desocupado qualquer, ja converte
(clerk*)<p>
		if (first==NULL) waiting=NONE;<p>
		q-&gt;serve(p);<p>
		return;<p>
	 case NONE:<p>
		waiting=COSTUMERS;<p>
		insert_first(p);<p>
		return;<p>
	 }<p>
};<p>
<p>
//Handle work request from idle clerk<p>
<p>
costumer* manager::request_work(clerk* p)<p>
{<p>
 costumer* q;<p>
<p>
 switch (waiting){<p>
  case COSTUMERS:<p>
	q=(costumer*) first;<p>
	remove();<p>
	if (first==NULL) waiting=NONE;<p>
	return q;<p>
  case CLERKS:<p>
	insert(p);<p>
	return NULL;<p>
  case NONE:<p>
	waiting=CLERKS;<p>
	insert_first(p);<p>
	return NULL;<p>
  }<p>
  return NULL;<p>
}<p>
<b></b><p>
<b><hr></b><p>
<p>
//File schedule.cpp<p>
//Source file for class scheduler<p>
#include &lt;iostream.h&gt;<p>
#include "repair.h"<p>
<p>
//Create scheduler with calendar queue having sz elements<p>
<p>
scheduler::scheduler(int sz,front_door* fdp,manager* mngrp)<p>
{<p>
	fd=fdp; //armazena o front_door pointer<p>
	m=mngrp;   //armazena o manager pointer<p>
	clock=0;<p>
	calendar_size=sz;<p>
	calendar=new active*[sz];<p>
	for (int i=0;i&lt;sz;i++) calendar[i]=0;<p>
	index=0;<p>
}<p>
<p>
//Schedule object *p to receive event message<p>
//after delay ticks have elapsed<p>
<p>
void scheduler::schedule(active* p,int delay)<p>
{<p>
	int t=index+delay;<p>
	if (t&gt;=calendar_size) t-=calendar_size;<p>
	p-&gt;set_next(calendar[t]);<p>
	calendar[t]=p;<p>
}<p>
<p>
//Run simulation for given number of ticks<p>
<p>
void scheduler::run(int ticks)<p>
{<p>
	active* p;<p>
for (int i=0;i&lt;ticks;i++) {<p>
		fd-&gt;sorteia_cost(); //agenda entrada do novo costumer enquanto<p>
		//nao comecou a mexer em listas ainda, senao corrompe estado<p>
		m-&gt;tick(); //faz manager gravar estatisticas das listas<p>
		while((p=calendar[index])!=0)<p>
			{ calendar[index]=p-&gt;get_next();<p>
			  p-&gt;event();<p>
			}<p>
			clock++;<p>
			if (++index==calendar_size) index=0;<p>
		}<p>
}<p>
	<p>
<b><hr></b><p>
<p>
//File simula.cpp<p>
//programa demonstracao para simulacao de cliente-atendente<p>
<p>
#include &lt;iostream.h&gt;<p>
#include &lt;stdlib.h&gt;<p>
#include "repair.h"<p>
<p>
//inicializando os membros static da classe costumer<p>
double costumer::servedcost=0.0;<p>
double costumer::waitedtime=0.0;<p>
int costumer::vivos=0; //para controle da alocacao dinamica<p>
<p>
main()<p>
{<p>
//declaracao de variaveis obtencao de valores do usuario<p>
unsigned semente; //seed for rand()<p>
int num_adj;  //numero de clerks<p>
double m_mean; //tempo medio entre entradas no estabelecimento<p>
double a_mean; //tempo medio de atendimento<p>
<p>
cout &lt;&lt; "Numero de atendentes?";<p>
cin &gt;&gt; num_adj;<p>
cout &lt;&lt; "Tempo medio de entrada de clientes pela porta?";<p>
cin &gt;&gt; m_mean;<p>
cout &lt;&lt; "Tempo medio de servico, atendimento?";<p>
cin &gt;&gt; a_mean;<p>
cout &lt;&lt; "Semente de numeros randomicos?";<p>
cin &gt;&gt; semente;<p>
<p>
//Seed rand(); set max_time to ten times maximum of<p>
//m_mean and a_mean<p>
<p>
srand(semente);<p>
int max_time=10*int(m_mean&gt;a_mean?m_mean:a_mean);<p>
int i;<p>
<p>
//Cria manager e scheduler<p>
<p>
manager mngr;<p>
front_door criador;<p>
scheduler sch(max_time+1,&amp;criador,&amp;mngr);<p>
criador.init(m_mean,max_time,&amp;sch,&amp;mngr); //inicializa criador de
costumers<p>
//com as caracteristicas esperadas dos costumers, como nao e construtor,
posso<p>
//modificar as caracteristicas dos costumers durante programa.<p>
<p>
//Cria clerks<p>
clerk** a_list=new clerk*[num_adj];<p>
for (i=0;i&lt;num_adj;i++)<p>
	a_list[i]=new clerk(a_mean,max_time,&amp;sch,&amp;mngr);<p>
<p>
//Faz sucessivos loops da simulacao; imprime estatisticas cumulativas<p>
//depois de cada conjunto de iteracoes completo<p>
<p>
char ch;<p>
do<p>
	{<p>
	//Get number of ticks for this run<p>
	int duration;<p>
	cout &lt;&lt; "\nNumber of time steps?";<p>
	cin &gt;&gt; duration;<p>
<p>
	//Run duration<p>
<p>
sch.run(duration);<p>
<p>
//COMPUTA E IMPRIME TEMPO MEDIO DE FILA (por costumer)<p>
long tempo_medio=(costumer::g_waitedtime())/(costumer::g_servedcost());<p>
	cout &lt;&lt; "Tempo medio na fila:" &lt;&lt; tempo_medio &lt;&lt; endl;<p>
<p>
//computa e imprime utilizacao media dos atendentes<p>
<p>
double a_factor=100.0/double(sch.time())/double(num_adj);<p>
long tot_busy_time=0;<p>
for (i=0;i&lt;num_adj;i++)<p>
	tot_busy_time+=a_list[i]-&gt;busy_time();<p>
	cout &lt;&lt; "Media da utilizacao dos atendentes:" &lt;&lt;
tot_busy_time*a_factor&lt;&lt;"%\n";<p>
<p>
double avll; //average costumer line lenght<p>
avll=mngr.g_llsum()/sch.time();<p>
cout &lt;&lt; "Comprimento medio da fila:" &lt;&lt; avll &lt;&lt; endl;<p>
<p>
//Determine if user wants to do more runs<p>
<p>
cout &lt;&lt; "Clientes ainda nao atendidos:" &lt;&lt; costumer::vivos &lt;&lt;
endl;<p>
//estes ou estao na fila para serem atendidos, ou se penduraram no<p>
//calendar queue, e so para controle da alocacao dinamica.<p>
<p>
cout &lt;&lt; "Continue (Y/N)?";<p>
cin &gt;&gt; ch;<p>
} while (ch=='y' || ch=='y');<p>
<p>
delete []a_list;<p>
return 0;<p>
}<p>
<p>
//RESULTADOS DO PROGRAMA, A PARTIR DOS VALORES INICIAIS DO PRIMEIRO TESTE<p>
//(TESTE A SEGUIR) FUI VARIANDO UM PARAMETRO POR VEZ E VENDO SE O<p>
//RESULTADO ERA COERENTE.<p>
//Numero de atendentes?1<p>
//Tempo medio de entrada de clientes pela porta?8<p>
//Tempo medio de servico, atendimento?3<p>
//Semente de numeros randomicos?31416<p>
//<p>
//Number of time steps?5000<p>
//Tempo medio na fila:3<p>
//Media da utilizacao dos atendentes:36.14%<p>
//Comprimento medio da fila:0.1384<p>
//Clientes ainda nao atendidos:1<p>
//Continue (Y/N)?y<p>
//<p>
//Number of time steps?10000<p>
//Tempo medio na fila:4<p>
//Media da utilizacao dos atendentes:37.7933%<p>
//Comprimento medio da fila:0.153667<p>
//Clientes ainda nao atendidos:4<p>
//Continue (Y/N)?n<p>
//<p>
//Numero de atendentes?2<p>
//Tempo medio de entrada de clientes pela porta?8<p>
//Tempo medio de servico, atendimento?3<p>
//Semente de numeros randomicos?31416<p>
//<p>
//Number of time steps?5000<p>
//Tempo medio na fila:2<p>
//Media da utilizacao dos atendentes:18.3%<p>
//Comprimento medio da fila:0.0088<p>
//Clientes ainda nao atendidos:0<p>
//Continue (Y/N)?y<p>
//<p>
//Number of time steps?10000<p>
//Tempo medio na fila:3<p>
//Media da utilizacao dos atendentes:18.4033%<p>
//Comprimento medio da fila:0.0068<p>
//Clientes ainda nao atendidos:2<p>
//Continue (Y/N)?<p>
//<p>
//Numero de atendentes?1<p>
//Tempo medio de entrada de clientes pela porta?6<p>
//Tempo medio de servico, atendimento?3<p>
//Semente de numeros randomicos?31416<p>
//<p>
//Number of time steps?5000<p>
//Tempo medio na fila:4<p>
//Media da utilizacao dos atendentes:50.06%<p>
//Comprimento medio da fila:0.3104<p>
//Clientes ainda nao atendidos:0<p>
//Continue (Y/N)?y<p>
//<p>
//Number of time steps?10000<p>
//Tempo medio na fila:5<p>
//Media da utilizacao dos atendentes:51%<p>
//Comprimento medio da fila:0.356933<p>
//Clientes ainda nao atendidos:1<p>
//Continue (Y/N)?<p>
//<p>
//Numero de atendentes?1<p>
//Tempo medio de entrada de clientes pela porta?8<p>
//Tempo medio de servico, atendimento?5<p>
//Semente de numeros randomicos?31416<p>
//<p>
//Number of time steps?5000<p>
//Tempo medio na fila:11<p>
//Media da utilizacao dos atendentes:59.54%<p>
//Comprimento medio da fila:0.7616<p>
//Clientes ainda nao atendidos:1<p>
//Continue (Y/N)?y<p>
<b><hr></b><p>
</CODE><p>

<b>Conte&uacute;do:</b><p>
<b></b><p>
<b>Bibliografia:</b><p>
<b></b>
<a name="ref1"></a><p>
[1]	Rumbaugh, Blaha M., Premerlani W., Eddy F. &amp; Lorensen W.
,"Object-Oriented Modeling and Design". Prentice Hall, 1991.    <p>
	       
<a name="ref2"></a><p>
[2]	Budd. T ,"Classical Data Structures  In C++". Addison-Wesley 1994.
<p>
	    
<a name="ref3"></a><p>
[3]	Mitchel M. ,"Data Abstraction in C++"           <p>
	
<a name="ref4"></a><p>
[4]	Graham. N.,"Learning C++". McGRAW-HILL, 1991.        <p>
	
<a name="ref5"></a><p>
[5]	 Stroustrup. B., "The C++ Programming Language". Addison-Wesley 1991.<p>
<A HREF="http://spidey.cs.rit.edu/exercises.html"> "Tutoriais e exerc&iacute;cios online sobre C++ e Eiffel" Departamento de ci&ecirc;ncia da computa&ccedil;&atilde;o, Rochester Institute of Technology </A>
<p>

<p>
</body></html>
